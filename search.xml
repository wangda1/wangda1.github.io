<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>about</title>
    <url>/2020/01/05/about/</url>
    <content><![CDATA[<hr>
<p>title: about<br>date: 2020-01-05 11:07:10<br>tags:</p>
<hr>
]]></content>
  </entry>
  <entry>
    <title>README</title>
    <url>/2019/11/12/README/</url>
    <content><![CDATA[<h1 id="Blogs"><a href="#Blogs" class="headerlink" title="Blogs"></a>Blogs</h1><p>今天(10/21/2017)突然发现我的github不能这样子用，我完全把这玩意儿当成博客网站了，代码倒是没放多少<br>于是乎，打算把blogs都搬移到这里来，以便管理:)（只怪自己太菜了   </p>
<p>打算分为以下模块：  </p>
<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p>这里记录学习算法的历程</p>
<h2 id="Operating-System"><a href="#Operating-System" class="headerlink" title="Operating System"></a>Operating System</h2><p>这里记录自己学习操作系统的历程  </p>
<h2 id="Complier"><a href="#Complier" class="headerlink" title="Complier"></a>Complier</h2><p>这里记录自己学习编译原理的历程  </p>
<h2 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h2><p>这里记录自己在写C/C++时的一些细节的感悟  </p>
<h2 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h2><p>这里记录自己在用数据库时的一些常用命令</p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>这里记录自己用Linux过程中做的一些笔记与摘抄吧  </p>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>这里记录自己了解了的python的一点皮毛  </p>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>这里记录自己了解的JavaScript的一点皮毛  </p>
<h2 id="Cypher-Security"><a href="#Cypher-Security" class="headerlink" title="Cypher Security"></a>Cypher Security</h2><p>这里记录自己学习的一些网络小技能  </p>
<h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><p>这里记录自己了解的SQL的一点皮毛  </p>
<h2 id="Something"><a href="#Something" class="headerlink" title="Something"></a>Something</h2><p>这里是一些杂记:)</p>
<h2 id="Matlab"><a href="#Matlab" class="headerlink" title="Matlab"></a>Matlab</h2><p>这里记录自己用matlab时的一些笔记与摘抄  </p>
<h2 id="NLP"><a href="#NLP" class="headerlink" title="NLP"></a>NLP</h2><p>这里记录自己学习自然语言处理所遇到的坑和心得、方法总结</p>
<p>写到这里，发现我真的在过去两年里学的好杂啊，但其实也未必是件坏事，至少它让我没闲着或者说开阔了一定的视野，让我在遇到问题的时候能有一丁点的解决思路<br>同时这中间也踩了不少坑，当然这些坑没白踩，对自己的自学能力也有一定的提高；<br>今天为什么突然心血来潮把这上面的笔记整理一下呢？因为一方面为了github pages做准备，以后有时间就搞一下好看一些，并且这里实现太乱了，看不下去；但最最重要的是接下来我要好好使用github码代码了，fork别人好的项目看看，自己做点有意思的项目，提高自己工程能力  也是为了增加一些自己的硬通货，嗯，就这样了好好写代码，好好思考，不要傻傻地当搬运工。   </p>
<h2 id="个人感悟"><a href="#个人感悟" class="headerlink" title="个人感悟"></a>个人感悟</h2><p>初步学习一个领域的知识时，不要纠结于细节的实现，这会让你抓不到大观，也不建议开始啃大部头书，这会打击学习兴趣<br>个人感觉最佳学习路线应该是：先明白做什么 –&gt; 再明白原理与原因 （为什么）–&gt; 后学习实现细节 –&gt; 最后尝试修改实现来优化效果</p>
]]></content>
  </entry>
  <entry>
    <title>anti-optimum</title>
    <url>/2019/12/14/Algorithm/anti-optimum/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>README</title>
    <url>/2019/11/08/Algorithm/README/</url>
    <content><![CDATA[<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>dynamic_Programming_sum</title>
    <url>/2019/11/08/Algorithm/dynamic_Programming_sum/</url>
    <content><![CDATA[<h1 id="Dynamic-Programming-总结"><a href="#Dynamic-Programming-总结" class="headerlink" title="Dynamic Programming 总结"></a>Dynamic Programming 总结</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>1.把多阶段决策过程转化成一系列的单阶段决策，利用各个阶段之间的递推关系来逐个确定每个阶段的最优化决策</p>
<h2 id="算法设计步骤"><a href="#算法设计步骤" class="headerlink" title="算法设计步骤"></a>算法设计步骤</h2><p>1.定义最优子问题</p>
<p>2.定义状态</p>
<p>3.定义决策与状态转移方程</p>
<p>4.确定边界条件</p>
<p>重点在于<strong>状态转移方程 + 边界条件</strong></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>dynamic_Programming0</title>
    <url>/2020/01/05/Algorithm/dynamic_Programming0/</url>
    <content><![CDATA[<h1 id="Dynamic-Programming-（动态规划）"><a href="#Dynamic-Programming-（动态规划）" class="headerlink" title="Dynamic Programming （动态规划）"></a>Dynamic Programming （动态规划）</h1><p>参考：</p>
<p>博客园 <a href="http://www.cnblogs.com/Anker/archive/2013/03/15/2961725.html" target="_blank" rel="noopener">http://www.cnblogs.com/Anker/archive/2013/03/15/2961725.html</a></p>
<p>适合于求解多阶段决策问题的最优解</p>
<p>常见的有以下几类问题：</p>
<ul>
<li>装配站问题</li>
<li>背包问题</li>
<li>最长公共子序列问题</li>
</ul>
<h2 id="装配站问题"><a href="#装配站问题" class="headerlink" title="装配站问题"></a>装配站问题</h2><p>问题描述：</p>
<p>　一个汽车公司在有2条装配线的工厂内生产汽车，每条装配线有n个装配站，不同装配线上对应的装配站执行的功能相同，<br>但是每个站执行的时间是不同的。在装配汽车时，为了提高速度，可以在这两天装配线上的装配站中做出选择，即可以将部<br>分完成的汽车在任何装配站上从一条装配线移到另一条装配线上。装配过程如下图所示：</p>
<p><img src="/2020/01/05/Algorithm/dynamic_Programming0/dp_zp0.png" alt=""></p>
<p>装配过程的时间包括：进入装配线时间e、每装配线上各个装配站执行时间a、从一条装配线移到另外一条装配线的时间t<br>离开最后一个装配站时间x。举个例子来说明，现在有2条装配线，每条装配线上有6个装配站，各个时间如下图所示：<br><img src="/2020/01/05/Algorithm/dynamic_Programming0/dp_zp1.png" alt="">  </p>
<p>从图中可以看出按照红色箭头方向进行装配汽车最快，时间为38。分别现在装配线1上的装配站1、3和6，装配线2上装配站2、4和5。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul>
<li>最小子问题与状态：求到第几个站的最短时间 f[0][i],f[1][i]</li>
<li>状态转换方程：f[0][i] = min{f[0][i-1]+a[0][j],f[1][i-1]+t[1][i-1]+a[0][i]},f[2][i]同理</li>
<li>边界条件：f[0][0],f[1][0]，这个可以根据状态转换方程加以确定</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">6</span>] = &#123;&#123;<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">4</span>&#125;,&#123;<span class="number">8</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> t[<span class="number">2</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> e[<span class="number">2</span>] = &#123;<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x[<span class="number">2</span>] = &#123;<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>][<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> l[<span class="number">2</span>][<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> fs,ls;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = e[<span class="number">0</span>]+a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>] = e[<span class="number">1</span>]+a[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;<span class="number">6</span>;j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[<span class="number">0</span>][j<span class="number">-1</span>] + a[<span class="number">0</span>][j] &lt;= f[<span class="number">1</span>][j<span class="number">-1</span>] + t[<span class="number">1</span>][j<span class="number">-1</span>] + a[<span class="number">0</span>][j]) &#123;</span><br><span class="line">            f[<span class="number">0</span>][j] = f[<span class="number">0</span>][j<span class="number">-1</span>] + a[<span class="number">0</span>][j];</span><br><span class="line">            l[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            f[<span class="number">0</span>][j] = f[<span class="number">1</span>][j<span class="number">-1</span>] + t[<span class="number">1</span>][j<span class="number">-1</span>] + a[<span class="number">0</span>][j];</span><br><span class="line">            l[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f[<span class="number">1</span>][j<span class="number">-1</span>] + a[<span class="number">1</span>][j] &lt;= f[<span class="number">0</span>][j<span class="number">-1</span>] + t[<span class="number">0</span>][j<span class="number">-1</span>] + a[<span class="number">1</span>][j]) &#123;</span><br><span class="line">            f[<span class="number">1</span>][j] = f[<span class="number">1</span>][j<span class="number">-1</span>] + a[<span class="number">1</span>][j];</span><br><span class="line">            l[<span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            f[<span class="number">1</span>][j] = f[<span class="number">0</span>][j<span class="number">-1</span>] + t[<span class="number">0</span>][j<span class="number">-1</span>] + a[<span class="number">1</span>][j];</span><br><span class="line">            l[<span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[<span class="number">0</span>][<span class="number">5</span>]+x[<span class="number">0</span>] &lt;= f[<span class="number">1</span>][<span class="number">5</span>]+x[<span class="number">1</span>]) &#123;</span><br><span class="line">        fs = f[<span class="number">0</span>][<span class="number">5</span>]+x[<span class="number">0</span>];</span><br><span class="line">        ls = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        fs = f[<span class="number">1</span>][<span class="number">5</span>]+x[<span class="number">1</span>];</span><br><span class="line">        ls =<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_station</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    r = l[r][i];</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"装配站："</span>&lt;&lt;l[r][i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        print_station(r,i<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"装配站："</span>&lt;&lt;r&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dp();</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"最短时间为"</span>&lt;&lt;fs&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"装配站："</span>&lt;&lt;ls&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    r = ls;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">5</span>;j&gt;<span class="number">0</span>;j--) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"装配站："</span>&lt;&lt;l[r][j]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        r = l[r][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"reverse output!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    print_station(ls,<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"装配站："</span>&lt;&lt;ls&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>八皇后问题</title>
    <url>/2020/04/28/Algorithm/eight-queen/</url>
    <content><![CDATA[<h1 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h1><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># [-1, -1 ....]</span></span><br><span class="line">        self.helper([<span class="number">-1</span>] * n, <span class="number">0</span>, n)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, columnPosition, rowindex, n)</span>:</span>  <span class="comment"># ding</span></span><br><span class="line">        <span class="comment"># print(rowindex)</span></span><br><span class="line">        <span class="keyword">if</span> rowindex == n:</span><br><span class="line">            self.printSolution(columnPosition, n)</span><br><span class="line">            <span class="comment"># print(columnPosition)</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># for column in range(n-rowindex):</span></span><br><span class="line">        <span class="keyword">for</span> column <span class="keyword">in</span> range(n):</span><br><span class="line">            columnPosition[rowindex] = column</span><br><span class="line">            <span class="comment"># columnPosition[0] = 0</span></span><br><span class="line">            <span class="keyword">if</span> self.isValid(columnPosition, rowindex):</span><br><span class="line">                self.helper(columnPosition, rowindex + <span class="number">1</span>, n)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, columnPosition, rowindex)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(set(columnPosition[:rowindex + <span class="number">1</span>])) != len(columnPosition[:rowindex + <span class="number">1</span>]):</span><br><span class="line">            <span class="comment"># print(columnPosition, rowindex)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rowindex):</span><br><span class="line">            <span class="keyword">if</span> abs(columnPosition[i] - columnPosition[rowindex]) == int(rowindex - i):</span><br><span class="line">                <span class="comment"># print(columnPosition, rowindex)</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printSolution</span><span class="params">(self, columnPosition, n)</span>:</span></span><br><span class="line">        <span class="comment"># print(columnPosition)</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(n):</span><br><span class="line">            line = <span class="string">""</span></span><br><span class="line">            <span class="keyword">for</span> column <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> columnPosition[row] == column:</span><br><span class="line">                    line += <span class="string">"Q\t"</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    line += <span class="string">".\t"</span></span><br><span class="line">            print(line, <span class="string">"\n"</span>)</span><br><span class="line">        print(<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">solution().solveNQueens(<span class="number">8</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>dynamic_Programming1</title>
    <url>/2020/01/05/Algorithm/dynamic_Programming1/</url>
    <content><![CDATA[<h1 id="Dynamic-Programming-（动态规划）"><a href="#Dynamic-Programming-（动态规划）" class="headerlink" title="Dynamic Programming （动态规划）"></a>Dynamic Programming （动态规划）</h1><h2 id="背包问题（0-1背包问题）"><a href="#背包问题（0-1背包问题）" class="headerlink" title="背包问题（0-1背包问题）"></a>背包问题（0-1背包问题）</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小偷发现了n个商品，第i个商品重量为wi,价值为vi。小偷希望尽量拿走价值高的商品，但是他的背包只能容纳W重的商品。  </span><br><span class="line">求如何取舍这些商品？   </span><br><span class="line">由于对一个商品，要么被拿走要么不被拿走，所以被称为0-1背包问题</span><br></pre></td></tr></table></figure>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul>
<li>最小子问题：拿到第i-1个商品是最优的，这个怎么考虑呢？（即在容量为<strong>w-vi</strong>的背包里，这里其实是错的），拿到第i-1个商品时，此时达到最优情况</li>
<li>状态：由以上分析，状态参数应该至少有2个，g[i][v]代表在v的容量下，第i次是最优的，g当然代表v之和啦</li>
<li><strong>第i次该如何选取呢？</strong>这个不像装配站问题，有前面确定的路可走，这里考虑<strong>拿与不拿</strong>,什么意思？拿，g[i-1][W-Wi]最优；不拿，g[i-1][W]最优；</li>
<li>状态转换方程：<strong>g[i][v] = max{g[i-1][W],g[i-1][W-Wi]+vi}</strong> 为什么会有拿与不拿呢？当然是背包总容量限制啦</li>
<li>边界条件：g[0][0] = 0 肯定是最优的</li>
</ul>
<h3 id="题目引用"><a href="#题目引用" class="headerlink" title="题目引用"></a>题目引用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有编号分别为a,b,c,d,e的五件物品，它们的重量分别是2,2,6,5,4，它们的价值分别是6,3,5,4,6，现在给你个承重为10的背包，如何让背包里装入的物品具有最  </span><br><span class="line">的价值总和</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/05/Algorithm/dynamic_Programming1/package.png" alt=""></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const int w[6]=&#123;0,2,2,6,5,4&#125;;//商品重量 第一数值为0，为了方便编程</span><br><span class="line">const int v[6]=&#123;0,6,3,5,4,6&#125;;//商品价值 第一数值为0，为了方便编程</span><br><span class="line">const int W = 10; //背包容量</span><br><span class="line">int c[6][11] = &#123;0&#125;;//c[i][j]表示在商品1到i中，背包容量为j时，最大价值</span><br><span class="line">int l[6]=&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">void dp_package() &#123;</span><br><span class="line">    for(int i=1;i&lt;=W;i++)               //i 代表此时背包容量</span><br><span class="line">        for(int j=1;j&lt;6;j++) &#123;          //j 代表第j个背包</span><br><span class="line">            if(i&gt;=w[j]) &#123;</span><br><span class="line">                if(c[j-1][i] &lt; c[j-1][i-w[j]] + v[j]) &#123;</span><br><span class="line">                    c[j][i] = c[j-1][i-w[j]] + v[j];        //此时为拿第i个商品的情况</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    c[j][i] = c[j-1][W];                    //此时为不拿第i个商品的情况</span><br><span class="line">    </span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                c[j][i] = c[j-1][i];                         </span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    dp_package();</span><br><span class="line">    cout&lt;&lt;c[5][10]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h3><p>第一遍看这个算法，没看明白！后来看到这个<a href="http://blog.csdn.net/mu399/article/details/7722810#reply" target="_blank" rel="noopener">http://blog.csdn.net/mu399/article/details/7722810#reply</a> 才有点头绪；  </p>
<ul>
<li>从容量为1-W递归考虑，这个是由于每次我们需要的是试探i-Wi时的最优情况，因此不得不从头考虑  </li>
</ul>
<h3 id="部分背包问题"><a href="#部分背包问题" class="headerlink" title="部分背包问题"></a>部分背包问题</h3><p>部分背包问题的意思是商品可以拿去部分，这样就可以用<strong>贪心算法</strong>做了，每次寻求<strong>商品价值/商品重量</strong>最大的加入到背包中</p>
<h2 id="最大公共子序列问题-LCS-Longest-Common-Sequence"><a href="#最大公共子序列问题-LCS-Longest-Common-Sequence" class="headerlink" title="最大公共子序列问题(LCS:Longest Common Sequence)"></a>最大公共子序列问题(LCS:Longest Common Sequence)</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><ul>
<li>公共子序列：两个序列中公共的子序列，如:”1A2C3D4B56”与”B1D23CA45B6A” 的公共子序列有 123456 或者其它</li>
<li>最长公共子序列即最长的：上题中，LCS即”123456“与”12C4B6”</li>
</ul>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个字符串str1和str2，返回两个字符串的最长公共子序列</p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LCS的最优子结构定理：设X=&#123;x1，x2，……，xm&#125;和Y=&#123;y1，y2，……，yn&#125;为两个序列，并设Z=&#123;z1、z2、……，zk&#125;为X和Y的任意一个LCS，则：</span><br><span class="line">（1）如果xm=yn，那么zk=xm=yn，而且Zk-1是Xm-1和Yn-1的一个LCS。</span><br><span class="line">（2）如果xm≠yn，那么zk≠xm蕴含Z是是Xm-1和Yn的一个LCS。</span><br><span class="line">（3）如果xm≠yn，那么zk≠yn蕴含Z是是Xm和Yn-1的一个LCS。</span><br><span class="line">定理说明两个序列的一个LCS也包含两个序列的前缀的一个LCS，即LCS问题具有最优子结构性质。</span><br></pre></td></tr></table></figure>
<p>状态转换方程与边界条件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">          |- 0; i,j=0</span><br><span class="line">c[i][j]-- |- c[i-1][j-1]+1; i,j&gt;0,Xi=Yj</span><br><span class="line">          |- max&#123;c[i-1][j],c[i][j-1]&#125;;i,j&gt;0,Xi!=Yj</span><br></pre></td></tr></table></figure>
<p>如何求得该LCS呢？贴出一段伪码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PRINT_LCS(b,X,i,j)</span><br><span class="line">    if i==0 or j==0</span><br><span class="line">        then return</span><br><span class="line">    if b[i][j] == &apos;\&apos;</span><br><span class="line">        then PRINT_LCS(b,X,i-1,j-1)</span><br><span class="line">             print X[i]</span><br><span class="line">     else if b[i][j] == &apos;|&apos;</span><br><span class="line">                then PRINT_LCS(b,X,i-1,j)</span><br><span class="line">             else PRINT_LSC(b,X,i,j-1)</span><br></pre></td></tr></table></figure>
<p>这里分析了一下思想就是在一路走来的路上留下痕迹，最后便于通过递归来寻迹，不过这样开销太大了</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>assert_h</title>
    <url>/2019/11/08/C/assert_h/</url>
    <content><![CDATA[<h1 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h1><p>这是一个断言语句，常用来过滤条件与检测错误信息</p>
<p>原型定义：</p>
<figure class="highlight plain"><figcaption><span>assert(int expression)```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">用法示例：</span><br></pre></td></tr></table></figure>
<p>#include <iostream><br>#include <cassert></p>
<p>using namespace std;</p>
<p>int main()<br>{<br>    int i = 1;</p>
<pre><code>assert(i&lt;0);

return 0;</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出：  </span><br><span class="line">`Assertion failed: i&lt;0, file D:\codes\acm\Test\main.cpp, line 10`</span><br><span class="line"></span><br><span class="line">常用来调试程序，当调试结束时，可以在 include &lt;assert.h&gt; 前加上 **#define NDEBUG** 来禁用函数，具体见原型声明，</span><br><span class="line">或</span><br></pre></td></tr></table></figure>
<p>#ifdef BOUNDS_CHECK<br>    assert( 0 &lt;= i );<br>    assert( i &lt; nRow );<br>#endif</p>
<pre><code>来方便调试</code></pre>]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Extern_Static_Const</title>
    <url>/2019/11/08/C/Extern_Static_Const/</url>
    <content><![CDATA[<h1 id="extern-amp-static-amp-const"><a href="#extern-amp-static-amp-const" class="headerlink" title="extern &amp; static &amp; const"></a>extern &amp; static &amp; const</h1><p>今天在写LCS算法代码时遇到了关于把局部变量声明为全局变量的问题，于是就查找资料搞了一波：</p>
<h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>遗传算法</title>
    <url>/2020/01/05/Algorithm/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="优化问题（一）遗传算法"><a href="#优化问题（一）遗传算法" class="headerlink" title="优化问题（一）遗传算法"></a>优化问题（一）遗传算法</h1><blockquote>
<p>遗传算法（Genetic Algorithm, GA）起源于对生物系统所进行的计算机模拟研究。它是模仿自然界生物进化机制发展起来的随机全局搜索和优化方法，借鉴了达尔文的进化论和孟德尔的遗传学说。其本质是一种高效、并行、全局搜索的方法，能在搜索过程中自动获取和积累有关搜索空间的知识，并自适应地控制搜索过程以求得最佳解。</p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>遗传算法是以面为单位的搜索，比以点为单位的搜索，更能发现全局最优解。</strong></p>
<p><img src="/2020/01/05/Algorithm/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/genetic_algorithm_process.jpeg" alt="process"></p>
<h2 id="验证函数"><a href="#验证函数" class="headerlink" title="验证函数"></a>验证函数</h2><p>$$f(x)=xsin(10\pi x)+2$$</p>
<h2 id="遗传算法的几个重要步骤"><a href="#遗传算法的几个重要步骤" class="headerlink" title="遗传算法的几个重要步骤"></a>遗传算法的几个重要步骤</h2><h3 id="1-基因的编码"><a href="#1-基因的编码" class="headerlink" title="1. 基因的编码"></a>1. 基因的编码</h3><p>编码的主要目的是为后期的遗传变异建立基础。</p>
<p><img src="/2020/01/05/Algorithm/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/genetic_algorithm.png" alt="code"></p>
<p>1.1 基因的编码方式</p>
<ul>
<li>二进制编码</li>
<li>浮点数编码</li>
</ul>
<p>在我们常用的问题中，基因型–编码；表现型–坐标；我们只需要在相应的坐标精度下使用一种编码表方式将坐标编码出来。</p>
<h3 id="2-适应性评价与选择函数"><a href="#2-适应性评价与选择函数" class="headerlink" title="2. 适应性评价与选择函数"></a>2. 适应性评价与选择函数</h3><p>这里是对个体的评价和选择的过程，也是对搜索空间的修剪。</p>
<p>2.1 适应度函数（fitness function）— 目标函数</p>
<p>适应度函数即是衡量该基因型的个体对环境的适应度评估标准。它是我们作为选择函数选择的依据。我们可以很明显地以<strong>目标函数</strong>作为我们的适应度函数</p>
<p>2.2 选择函数（selection）</p>
<p><em>为什么这里会出现选择函数而不是直接对适应度最高的函数进行选择呢？</em></p>
<p>模拟生物界的遗传进化规律，并不是所有的优良个体都会被保存，也不是所有的劣势个体都会被淘汰。</p>
<p>常用方法：</p>
<ul>
<li>轮盘赌（Roulette Wheel Selection）</li>
</ul>
<p><em>转盘游戏</em></p>
<p><img src="/2020/01/05/Algorithm/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/roulette_wheel_selection.png" alt="roulette_wheel"></p>
<h3 id="3-基因重组与基因突变"><a href="#3-基因重组与基因突变" class="headerlink" title="3. 基因重组与基因突变"></a>3. 基因重组与基因突变</h3><p>这部分是对搜索空间的扩大，通过对个体进行变异从而得到更多基因型和表现型的个体，这部分会有大量的随机操作</p>
<p>3.1 基因重组</p>
<p>通过对两个基因的编码进行部分替换得到</p>
<p><img src="/2020/01/05/Algorithm/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/ga_ge_reconstruct.png" alt="ge_reconstruct"></p>
<p>3.2 基因突变</p>
<p>对单个个体的基因型进行改变</p>
<ul>
<li>二进制的编码： <code>0</code> 与 <code>1</code> 之间的互换</li>
<li>浮点数的编码：对浮点数增加/减少一个随机数</li>
</ul>
<h3 id="4-遗传算子总结"><a href="#4-遗传算子总结" class="headerlink" title="4. 遗传算子总结"></a>4. 遗传算子总结</h3><p><img src="/2020/01/05/Algorithm/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/ga_operator.png" alt="ga_operator"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/u010451580/article/details/51178225" target="_blank" rel="noopener">遗传算法详解</a></li>
<li><a href="https://blog.csdn.net/zzzzjh/article/details/80633573" target="_blank" rel="noopener">遗传算法python实现</a></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>README</title>
    <url>/2019/11/08/C/README/</url>
    <content><![CDATA[<h1 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h1><p>C/C++一些小知识和一些常用的代码  </p>
<ul>
<li>1.2017/5/25  typedef及一些复杂的声明  <a href="https://github.com/wangda1/oh/blob/master/typedef.md" target="_blank" rel="noopener">https://github.com/wangda1/oh/blob/master/typedef.md</a></li>
</ul>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>typedef</title>
    <url>/2019/11/08/C/typedef/</url>
    <content><![CDATA[<h1 id="typedef及一些复杂的声明"><a href="#typedef及一些复杂的声明" class="headerlink" title="typedef及一些复杂的声明"></a>typedef及一些复杂的声明</h1><p>今天在做微机原理实验时，看了一些API的声明，被里面的一些函数的声明搞得有点头晕了，哎呀！我个C语言的渣。慌得我赶紧补了一发！</p>
<h2 id="typedef-与-define"><a href="#typedef-与-define" class="headerlink" title="typedef 与 #define"></a>typedef 与 #define</h2><blockquote>
<ul>
<li>与 #define 不同，typedef给出的符号名称仅限于对类型，而不是对值；   </li>
<li>typedef的解释由编译器，而不是由预处理器；  </li>
<li>但在有限的范围内,typedef 比 #define 灵活。</li>
</ul>
</blockquote>
<p>经典用法：<br>typedef unsigned char byte;  </p>
<h1 id="define-byte-unsigned-char-同"><a href="#define-byte-unsigned-char-同" class="headerlink" title="define byte unsigned char;  同"></a>define byte unsigned char;  同</h1><p>但是，<br>typedef char * STRING；</p>
<h1 id="define-STRING-char"><a href="#define-STRING-char" class="headerlink" title="define STRING char *"></a>define STRING char *</h1><p>前者,STRING name,sign 表示 char * name, * sign;<br>后者,STRING name,sign 表示 char * name,sign;    </p>
<p><strong>另一个不可告人的原因是：</strong><br>typedef 常用于 复杂类型      </p>
<p>来来来，这个告诉我是啥？  <em>* typedef char (</em> FRPTC()) [5] **    </p>
<p>表示函数返回一个指向5个元素的char数组的指针；<br>** typedef char * FRPTC() [5] **<br>表示函数返回一个含有5个指向char的指针的数组；   </p>
<h2 id="C的奇特的声明"><a href="#C的奇特的声明" class="headerlink" title="C的奇特的声明"></a>C的奇特的声明</h2><p>char * fump ();       //返回指向 char 的指针的函数；<br>char (* fump) ();     //指向返回类型为char 的函数的指针；<br>char (* flump[3])();  //由3个指针组成的数组，每个指针指向返回类型为char的函数；   </p>
<p>注：(),[]的优先级相同，高于 * 的优先级</p>
<p><strong>鄙人认为这些奇特的声明的辨认就严格按照优先级顺序进行结合</strong></p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>string_h</title>
    <url>/2019/11/08/C/string_h/</url>
    <content><![CDATA[<h1 id="string-h-vs-string"><a href="#string-h-vs-string" class="headerlink" title="string.h vs string"></a>string.h vs string</h1><p>string.h C的头文件，无string类，有strcpy()函数<br>cstring 这个完全是string.h的C++版本只不过多了std的命名空间，也就是必须用 std::strcpy()<br>string C++新生头文件，与string.h无半毛钱关系，亲儿子  </p>
<h2 id="string-h"><a href="#string-h" class="headerlink" title="string.h"></a>string.h</h2><p>C 的头文件  </p>
<ul>
<li><p><strong>无string类型的定义</strong><br>想定义个字符串，char string[] = “string”;  char *string = “string”;</p>
</li>
<li><p><strong>常用的字符串操作函数</strong><br><code>int strcmp(char * str1,char * str2);</code><br>这个返回值比较有意思，按照字符ASCII码，若str1 &lt; str2,返回负数；同理  </p>
</li>
</ul>
<p>  <code>unsigned int strlen(char * str);</code> 注意：统计字符个数不包括\0  </p>
<p>  <code>void *memset(void *s, int c, size_t n);</code>   </p>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>C++ 亲生儿子，属于STL  </p>
<ul>
<li><strong>string类出现</strong></li>
</ul>
<ul>
<li><strong>重载了操作符</strong></li>
</ul>
<h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><p>1.其实iostream.h也是C的头文件，C++里面使用iostream就必须使用命名空间了，与此类似，当用一些C里面的函数时：<br>  eg:   </p>
<ul>
<li>math.h 可以直接使用里面的函数，不用管命名空间  </li>
<li>cmath  必须申明命名空间来使用头文件里的一些函数  </li>
</ul>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>stdlib_h</title>
    <url>/2019/11/08/C/stdlib_h/</url>
    <content><![CDATA[<h1 id="stdlib-h"><a href="#stdlib-h" class="headerlink" title="stdlib.h"></a>stdlib.h</h1><p>这个头文件经常遇到，仅知道几个函数与其有关，还是总结一下比较好</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C Standard General Utilities Library</span><br><span class="line">This header defines several general purpose functions, including dynamic memory management, random number generation, </span><br><span class="line">communication with the environment, integer arithmetics, searching, sorting and converting.</span><br></pre></td></tr></table></figure>
<h2 id="函数-Functions"><a href="#函数-Functions" class="headerlink" title="函数 Functions"></a>函数 Functions</h2><ul>
<li><p>String conversion</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">atof</span><br><span class="line">Convert string to double (function )</span><br><span class="line">atoi</span><br><span class="line">Convert string to integer (function )</span><br><span class="line">atol</span><br><span class="line">Convert string to long integer (function )</span><br><span class="line">atoll </span><br><span class="line">Convert string to long long integer (function )</span><br><span class="line">strtod</span><br><span class="line">Convert string to double (function )</span><br><span class="line">strtof </span><br><span class="line">Convert string to float (function )</span><br><span class="line">strtol</span><br><span class="line">Convert string to long integer (function )</span><br><span class="line">strtold </span><br><span class="line">Convert string to long double (function )</span><br><span class="line">strtoll </span><br><span class="line">Convert string to long long integer (function )</span><br><span class="line">strtoul</span><br><span class="line">Convert string to unsigned long integer (function )</span><br><span class="line">strtoull </span><br><span class="line">Convert string to unsigned long long integer (function )</span><br></pre></td></tr></table></figure></li>
<li><p>Pseudo-random sequence generation 伪随机数生成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rand</span><br><span class="line">Generate random number (function )</span><br><span class="line">srand</span><br><span class="line">Initialize random number generator (function )</span><br></pre></td></tr></table></figure></li>
<li><p>Dynamic memory management 动态内存分配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">calloc</span><br><span class="line">Allocate and zero-initialize array (function )</span><br><span class="line">free</span><br><span class="line">Deallocate memory block (function )</span><br><span class="line">malloc</span><br><span class="line">Allocate memory block (function )</span><br><span class="line">realloc</span><br><span class="line">Reallocate memory block (function )</span><br></pre></td></tr></table></figure>
</li>
<li><p>Environment</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abort</span><br><span class="line">Abort current process (function )</span><br><span class="line">atexit</span><br><span class="line">Set function to be executed on exit (function )</span><br><span class="line">at_quick_exit </span><br><span class="line">Set function to be executed on quick exit (function )</span><br><span class="line">exit</span><br><span class="line">Terminate calling process (function )</span><br><span class="line">getenv</span><br><span class="line">Get environment string (function )</span><br><span class="line">quick_exit </span><br><span class="line">Terminate calling process quick (function )</span><br><span class="line">system</span><br><span class="line">Execute system command (function )</span><br><span class="line">_Exit </span><br><span class="line">Terminate calling process (function )</span><br></pre></td></tr></table></figure>
</li>
<li><p>Searching and sorting</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bsearch</span><br><span class="line">Binary search in array (function )</span><br><span class="line">qsort</span><br><span class="line">Sort elements of array (function )</span><br></pre></td></tr></table></figure>
</li>
<li><p>Integer arithmetics 整数运算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abs</span><br><span class="line">Absolute value (function )</span><br><span class="line">div</span><br><span class="line">Integral division (function )</span><br><span class="line">labs</span><br><span class="line">Absolute value (function )</span><br><span class="line">ldiv</span><br><span class="line">Integral division (function )</span><br><span class="line">llabs </span><br><span class="line">Absolute value (function )</span><br><span class="line">lldiv </span><br><span class="line">Integral division (function )</span><br></pre></td></tr></table></figure>
</li>
<li><p>Multibyte characters</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mblen</span><br><span class="line">Get length of multibyte character (function )</span><br><span class="line">mbtowc</span><br><span class="line">Convert multibyte sequence to wide character (function )</span><br><span class="line">wctomb</span><br><span class="line">Convert wide character to multibyte sequence (function )</span><br></pre></td></tr></table></figure>
</li>
<li><p>Multibyte strings </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mbstowcs</span><br><span class="line">Convert multibyte string to wide-character string (function )</span><br><span class="line">wcstombs</span><br><span class="line">Convert wide-character string to multibyte string (function )</span><br></pre></td></tr></table></figure>
<h2 id="Macro-宏"><a href="#Macro-宏" class="headerlink" title="Macro 宏"></a>Macro 宏</h2></li>
<li><p>Macro constants</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXIT_FAILURE</span><br><span class="line">Failure termination code (macro )</span><br><span class="line">EXIT_SUCCESS</span><br><span class="line">Success termination code (macro )</span><br><span class="line">MB_CUR_MAX</span><br><span class="line">Maximum size of multibyte characters (macro )</span><br><span class="line">NULL</span><br><span class="line">Null pointer (macro )</span><br><span class="line">RAND_MAX</span><br><span class="line">Maximum value returned by rand (macro )</span><br></pre></td></tr></table></figure>
</li>
<li><p>Types</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div_t</span><br><span class="line">Structure returned by div (type )</span><br><span class="line">ldiv_t</span><br><span class="line">Structure returned by ldiv (type )</span><br><span class="line">lldiv_t </span><br><span class="line">Structure returned by lldiv (type )</span><br><span class="line">size_t</span><br><span class="line">Unsigned integral type (type )</span><br></pre></td></tr></table></figure>

</li>
</ul>
<pre><code></code></pre>]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>README</title>
    <url>/2019/11/08/Complier/README/</url>
    <content><![CDATA[<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>尝试学了几次，终没有坚持下去</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ul>
<li>2020/5/14: 增加 <code>LLVM</code> 相关知识</li>
</ul>
]]></content>
      <categories>
        <category>Complier</category>
      </categories>
      <tags>
        <tag>Complier</tag>
      </tags>
  </entry>
  <entry>
    <title>求排列组合</title>
    <url>/2019/11/08/C/%E6%B1%82%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double Com(int low,int high)</span><br><span class="line">&#123;</span><br><span class="line">    double up,down;</span><br><span class="line">    double result;</span><br><span class="line">    up = 1;</span><br><span class="line">    down = 1;</span><br><span class="line">    for(int i=1;i&lt;=high;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      up = up * (low - i +1);</span><br><span class="line">      down = down * i;</span><br><span class="line">    &#125;</span><br><span class="line">    result = up / down;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>README</title>
    <url>/2019/11/08/CypherSecurity/README/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>CypherSecurity</category>
      </categories>
      <tags>
        <tag>CypherSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake</title>
    <url>/2019/11/08/CMake/CMake/</url>
    <content><![CDATA[<h1 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h1><p>首先，CMake是什么？<br>引用官方网站</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CMake is an open-source, cross-platform family of tools designed to build, test and package software. </span><br><span class="line">CMake is used to control the software compilation process using simple platform and compiler independent configuration files, </span><br><span class="line">and generate native makefiles and workspaces that can be used in the compiler environment of your choice. </span><br><span class="line">The suite of CMake tools were created by Kitware in response to the need for a powerful, cross-platform build environment </span><br><span class="line">for open-source projects such as ITK and VTK.</span><br></pre></td></tr></table></figure>

<p>其次，怎么用？<br>1.CMake工具链：cmake  + make    </p>
<p>2.编写  CMakeLists.txt文档，使用cmake语言与语法</p>
<p>2.建议语言： C C++ Java</p>
<p>3.安装：官方网站下载安装(一般Linux发行版都已经包含该组件)   </p>
<p>现在开始……</p>
<h1 id="cmake语言与语法"><a href="#cmake语言与语法" class="headerlink" title="cmake语言与语法"></a>cmake语言与语法</h1><p>一份最简化的  CMakeLists.txt  如下：     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PROJECT(HELLO)</span><br><span class="line">ADD_EXECUTABLE(hello main.c)</span><br></pre></td></tr></table></figure>

<p>扩充一下，加一些提示性信息：      </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PROJECT(HELLO)</span><br><span class="line">SET(SRC_LIST  main.c)</span><br><span class="line">MESSAGE(STATUS  &quot;This is BINARY DIR&quot;  $&#123;HELLO_BINARY_DIR&#125;)</span><br><span class="line">MESSAGE(STATUS  &quot;This is BINARY DIR&quot;  $&#123;HELLO_SOURCE_DIR&#125;)</span><br><span class="line">ADD_EXECUTABLE(hello main.c)</span><br></pre></td></tr></table></figure>

<p>等等，我知道你用SET设置了变量，并且那个 ${} 就是取变量的值，这和  make  脚本编写是一样的，但  HELLO_BINARY_DIR,HELLO_SOURCE_DIR<br>哪来的？？？    </p>
<p>原来在那个 PROJECT 命令里，隐式地定义了两个  cmake 变量  </p>
<ul>
<li><projectname>_BINARY_DIR, <projectname>_SOURCE_DIR<br>因为我们就一个文件 main.c  所以就都指的是当前目录了      </li>
<li>PROJECT_BINARY_DIR, PROJECT_SOURCE_DIR<br>这两个系统预定义的变量与上述两者的含义是完全一致的</li>
</ul>
<p><strong>下面开始语法</strong></p>
<p>1.PROJECT指令：<br><code>PROJECT(projectname  [CXX] [C] [Java])</code><br>后面是支持的语言list,默认是全部支持，当然你也可以自己指定</p>
<p>2.SET指令：<br><code>SET(VAR  [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</code><br>显式地定义变量     </p>
<p>如：SET(SRC_LIST  main.c  hello.c hello1.c)</p>
<p>3.MESSAGE指令：<br><code>MESSAGE([SEND_ERROR  | STATUS  | FATAL_ERROR]  &quot;messageto display&quot;...)</code><br>用于向终端输出用户定义的消息</p>
<p>4.ADD_EXECUTABLE指令：<br>ADD_EXECUTABLE(HELLO  ${SRC_LIST})        </p>
<p>定义该工程会生成一个名为hello的可执行文件，即最终目标文件，后面是相关的源文件列表</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ol>
<li>变量使用  ${}来取值，但是在  IF  控制语句中是直接使用变量名<br>目前，还没遇到，遇到再说吧 :)</li>
</ol>
<p>2.指令是<strong>大小写无关的</strong>，不过一般的指令都是大写的</p>
]]></content>
      <categories>
        <category>C</category>
        <category>CMake</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title>README</title>
    <url>/2019/11/08/CMake/README/</url>
    <content><![CDATA[<h1 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h1><p>用 CLion 写信号处理的软件课设的时候出现了链接找不到函数实现的情况，问了老司机，一眼指出我的 CMakeLists.txt 写的有问题    </p>
<p>这是什么鬼？  查查才知道，于是乎，还是好好学习一下    </p>
<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul>
<li>《CMake Practice》及网上 blogs</li>
<li>CMake 官方网站  <a href="https://cmake.org/" target="_blank" rel="noopener">https://cmake.org/</a></li>
</ul>
]]></content>
      <categories>
        <category>C</category>
        <category>CMake</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title>Database</title>
    <url>/2020/01/05/Database/Database/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="CAP原理"><a href="#CAP原理" class="headerlink" title="CAP原理"></a>CAP原理</h2><p><img src="/2020/01/05/Database/Database/multi-storage.png" alt="multi-storage"></p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>Cassandra</title>
    <url>/2019/11/27/Database/Cassandra/</url>
    <content><![CDATA[<h1 id="Cassandra"><a href="#Cassandra" class="headerlink" title="Cassandra"></a>Cassandra</h1><blockquote>
<p><em>wikipedia:</em> Cassandra 是一套开源式分布式 NoSQL 数据库系统。 最初由 Facebook 开发，用于储存收件箱等简单格式数据，集 Google BigTable 的数据模型与 Amazon Dynamo的完全分布式架构于一身。</p>
</blockquote>
<h2 id="1-数据模型"><a href="#1-数据模型" class="headerlink" title="1. 数据模型"></a>1. 数据模型</h2><p>Cassandra使用了 Google 设计的 BigTable 的数据模型，与面向行（row）的传统关系型数据库或键值存储（key-value）数据库不同，Cassandra使用的是宽列存储模型（wide column stores。</p>
<h2 id="2-存储模型"><a href="#2-存储模型" class="headerlink" title="2. 存储模型"></a>2. 存储模型</h2><p>与 BigTable、HBase不同，Cassandra的数据并不存储在分布式文件系统如 GFS 或 HDFS 中，而是直接存储于本地。与 BigTable 一样，Cassandra 也是日志型数据库，采用 <code>LSM-Tree</code> 存储算法，特点是适合于写入较多的场景。</p>
<p>旧版的Cassandra与客户端交互的方法是通过thrift，而当前新版本的Cassandra采用与SQL语言类似的 <code>CQL</code> 语言来实现数据模型的定义和数据的读写。其中BigTable中的 <code>列族(Column Family)</code> 在Cassandra中被称作类似关系型数据库中的称呼——<code>表(table)</code>，而/2019/11/27/Database/Cassandra/BigTable中的 <code>row key</code> 和 <code>column key</code> 并称为主键 <code>(primary key)</code>。</p>
<p>Cassandra的row key决定了该行数据存储在哪些节点中，因此row key需要按哈希来存储，不能顺序的扫描或读取，而一个row内的column key是顺序存储的，可以进行有序的扫描或范围查找</p>
<h2 id="3-分布式架构"><a href="#3-分布式架构" class="headerlink" title="3. 分布式架构"></a>3. 分布式架构</h2><p>Cassandra 的系统架构与 Dynamo 类似，属于一致性哈希的完全 P2P 架构，每行数据通过哈希来决定应该存在哪个节点或哪些节点。集群没有 master 节点，所有节点都是同样的角色，避免了系统的单点瓶颈，集群间的状态同步通过 Gossip 协议来进行 P2P 通信。</p>
<p>在 CAP（Consistency、Available、Partition）问题的 trade-off 上，Cassandra 和 Dynamo一样比较灵活。Cassandra的每个 keyspace 可配置一行数据会写入多少个节点才算写入成功(设这个数为N)，来保证数据不因为机器宕机或磁盘损坏而丢失数据，即保证了CAP中的P。用户在读写数据时可以指定要求成功写到多少个节点才算写入成功(设为W)，以及成功从多少个节点读取到了数据才算成功(设为R)。可推理得出，当 <code>W+R&gt;N</code> 时，读到的数据一定是上一次写入的，即维护了 <code>强一致性</code>，确保了 <code>CAP</code> 中的 <code>C</code>。当 <code>W+R&lt;=N</code> 时，数据是 <code>最终一致性</code> 因为存在一段时间可能读到的并不是最新版的数据。当 <code>W=N</code> 或 <code>R=N</code> 时，意味着系统只要有一个节点无响应或宕机，就有一部分数据无法成功写或者读，即失去了CAP中的可用性A。 <em>from wikipedia</em></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://zh.wikipedia.org/wiki/Cassandra" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Cassandra</a></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>mongodb</title>
    <url>/2019/11/27/Database/mongodb/</url>
    <content><![CDATA[<h1 id="mongo-DB"><a href="#mongo-DB" class="headerlink" title="mongo DB"></a>mongo DB</h1><h2 id="1-插入"><a href="#1-插入" class="headerlink" title="1. 插入"></a>1. 插入</h2><h2 id="2-删除"><a href="#2-删除" class="headerlink" title="2. 删除"></a>2. 删除</h2><h2 id="3-修改"><a href="#3-修改" class="headerlink" title="3. 修改"></a>3. 修改</h2><h2 id="4-查询"><a href="#4-查询" class="headerlink" title="4. 查询"></a>4. 查询</h2><p>mongodb的查询分为两种：</p>
<ul>
<li>普通查询：类似于 sql 中的 <code>select where</code></li>
<li>聚合查询：类似于 sql 中的 <code>group by</code></li>
</ul>
<h3 id="4-1-普通查询"><a href="#4-1-普通查询" class="headerlink" title="4.1 普通查询"></a>4.1 普通查询</h3><p>mongo的普通查询是通过在 {} 中指定过滤参数来进行查询</p>
<ul>
<li><code>db.collection.find()</code> 查询所有</li>
<li><code>db.collection.find( { status: &quot;D&quot; } )</code> 查询 status 为D的记录</li>
<li><code>db.collection.find( { status: { $in: [&quot;A&quot;, &quot;D&quot;] } } )</code> 查询 status 为 数组中的记录</li>
</ul>
<p>AND 与 OR 运算符的使用</p>
<ul>
<li><code>db.collection.find( { status: &quot;A&quot;, qty: { $lt: 30 } } )</code> 查询 status 为 A， qty 小于 30 的记录，类似于 AND 的记录查询</li>
<li><code>db.collection.find( { $or: [ {status: &quot;A&quot; }, { qty: { $lt: 30 } } ] } )</code> OR 的记录查询</li>
</ul>
<p>指定字段</p>
<ul>
<li><code>db.collection.find( {}, { user_id: 1, status: 1, _id: 0}</code> 不显示 ID</li>
</ul>
<h2 id="5-函数"><a href="#5-函数" class="headerlink" title="5. 函数"></a>5. 函数</h2><ul>
<li>指定数据的数量：<code>limit(NUM)</code></li>
<li>跳过指定的数量：<code>skip(NUM)</code></li>
</ul>
<h2 id="6-使用-PyMongo"><a href="#6-使用-PyMongo" class="headerlink" title="6. 使用 PyMongo"></a>6. 使用 PyMongo</h2><p>在 Pymongo 中使用命令与 mongo 命令相同，少许对应关系：</p>
<ul>
<li><code>null</code> &lt;–&gt; <code>None</code></li>
<li><code>false</code> &lt;–&gt; <code>False</code></li>
</ul>
<h3 id="6-1-查询"><a href="#6-1-查询" class="headerlink" title="6.1 查询"></a>6.1 查询</h3><p>使用 Pymongo 进行查询的时候返回 <code>cursor</code> 对象，这是一个可迭代的对象</p>
<ul>
<li><p>查询字段是否为设置<br><code>db.find({&#39;news_abstract_ne_with_nltk&#39;: {&#39;$exists&#39;: False}})</code></p>
</li>
<li><p>查询字段是否为空或不存在<br><code>db.find({&#39;news_abstract_ne_with_nltk&#39;: None)</code></p>
</li>
<li><p>查询字段存在且为空<br><code>db.find({&#39;news_abstract_ne_with_nltk&#39;: {&#39;$exists&#39;: True, &#39;$in&#39;: [None]}})</code></p>
</li>
<li><p>返回指定字段</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只输出id和title字段，第一个参数为查询条件，空代表查询所有</span></span><br><span class="line">db.news.find( &#123;&#125;, &#123; id: <span class="number">1</span>, title: <span class="number">1</span> &#125; )</span><br><span class="line"><span class="comment"># 如果需要输出的字段比较多，不想要某个字段，可以用排除字段的方法</span></span><br><span class="line"><span class="comment"># 不输出内容字段，其它字段都输出</span></span><br><span class="line">db.news.find( &#123;&#125;, &#123;content: <span class="number">0</span> &#125; )</span><br></pre></td></tr></table></figure>

<h3 id="6-2-计数"><a href="#6-2-计数" class="headerlink" title="6.2 计数"></a>6.2 计数</h3><ul>
<li><code>count_documents({})</code></li>
<li><code>db.find({&#39;news_abstract_ne_with_nltk&#39;: None).count()</code></li>
</ul>
<h3 id="6-3-修改文档"><a href="#6-3-修改文档" class="headerlink" title="6.3 修改文档"></a>6.3 修改文档</h3><ul>
<li><code>update_one()</code> 更新一条记录 </li>
<li><code>update_many()</code> 批量更新记录</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line"></span><br><span class="line">myclient = pymongo.MongoClient(<span class="string">"mongodb://localhost:27017/"</span>)</span><br><span class="line">mydb = myclient[<span class="string">"runoobdb"</span>]</span><br><span class="line">mycol = mydb[<span class="string">"sites"</span>]</span><br><span class="line"> </span><br><span class="line">myquery = &#123; <span class="string">"alexa"</span>: <span class="string">"10000"</span> &#125;</span><br><span class="line">newvalues = &#123; <span class="string">"$set"</span>: &#123; <span class="string">"alexa"</span>: <span class="string">"12346"</span> &#125; &#125;</span><br><span class="line"> </span><br><span class="line">mycol.update_one(myquery, newvalues)</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://www.yangyanxing.com/article/specialUse-in-pymongo.html" target="_blank" rel="noopener">https://www.yangyanxing.com/article/specialUse-in-pymongo.html</a></li>
</ul>
<h2 id="学习参考"><a href="#学习参考" class="headerlink" title="学习参考"></a>学习参考</h2><ul>
<li><a href="https://www.jianshu.com/p/dbf966f8d314" target="_blank" rel="noopener">https://www.jianshu.com/p/dbf966f8d314</a></li>
<li><a href="https://docs.mongodb.com/manual/tutorial/query-documents/" target="_blank" rel="noopener">https://docs.mongodb.com/manual/tutorial/query-documents/</a></li>
<li><a href="https://api.mongodb.com/python/current/tutorial.html#querying-for-more-than-one-document" target="_blank" rel="noopener">https://api.mongodb.com/python/current/tutorial.html#querying-for-more-than-one-document</a></li>
</ul>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>LLVM</title>
    <url>/2020/05/14/Complier/llvm/</url>
    <content><![CDATA[<h1 id="LLVM"><a href="#LLVM" class="headerlink" title="LLVM"></a>LLVM</h1><p>LLVM（Low Level Virtual Machine）底层虚拟机</p>
<h2 id="LLVM-与-clang"><a href="#LLVM-与-clang" class="headerlink" title="LLVM 与 clang"></a>LLVM 与 clang</h2><blockquote>
<p>Clang（发音为/ˈklæŋ/） 是一个C、C++、Objective-C和Objective-C++编程语言的编译器前端。它采用了底层虚拟机（LLVM）作为其后端。它的目标是提供一个GNU编译器套装（GCC）的替代品。作者是克里斯·拉特纳，在苹果公司的赞助支持下进行开发，而源代码授权是使用类BSD的伊利诺伊大学厄巴纳-香槟分校开源码许可。<br>Clang项目包括Clang前端和Clang静态分析器等</p>
</blockquote>
<h2 id="LLVM-与-clang-的安装"><a href="#LLVM-与-clang-的安装" class="headerlink" title="LLVM 与 clang 的安装"></a>LLVM 与 clang 的安装</h2><p><img src="/2020/05/14/Complier/llvm/compile_process.png" alt="源文件的编译过程"></p>
<h2 id="LLVM-IR表示"><a href="#LLVM-IR表示" class="headerlink" title="LLVM IR表示"></a>LLVM IR表示</h2><ul>
<li>IR</li>
</ul>
<p><code>LLVM</code>的 IR 包含了几个部分，主要是：Modules、Functions、Basic Block、Instructions几类。</p>
<ul>
<li>Pass：<blockquote>
<p>The passes, which transform IR to IR. In ordinary circumstances, passes usually optimize the code: that is, they produce an IR program as output that does the same thing as the IR they took as input, except that it’s faster. This is where you want to hack. Your research tool can work by looking at and changing IR as it flows through the compilation process.</p>
</blockquote>
</li>
</ul>
<h2 id="LLVM-使用"><a href="#LLVM-使用" class="headerlink" title="LLVM 使用"></a>LLVM 使用</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cs.cornell.edu/~asampson/blog/llvm.html" target="_blank" rel="noopener">LLVM for Grad Students</a></li>
<li><a href="https://juejin.im/post/5a30ea0ff265da43094526f9" target="_blank" rel="noopener">Clang-LLVM</a></li>
<li><a href="https://www.zhihu.com/question/60299862" target="_blank" rel="noopener">LLVM/clang在ubuntu下的安装</a></li>
</ul>
]]></content>
      <categories>
        <category>Complier</category>
      </categories>
      <tags>
        <tag>Complier</tag>
      </tags>
  </entry>
  <entry>
    <title>Go README</title>
    <url>/2020/02/08/Go/README/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>antenna</title>
    <url>/2019/12/22/HAM/antenna/</url>
    <content><![CDATA[<h1 id="天线的基本知识"><a href="#天线的基本知识" class="headerlink" title="天线的基本知识"></a>天线的基本知识</h1><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><em>天线的工作原理以前上电磁波课的时候一直不明白，看了这个视频茅塞顿开</em></p>
<ul>
<li><a href="https://www.youtube.com/watch?v=ZaXm6wau-jc" target="_blank" rel="noopener">video</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/51098683" target="_blank" rel="noopener">知乎-看完这个，你就是半个天线专家</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/28552572" target="_blank" rel="noopener">无线电频谱划分及相关基础知识</a></li>
</ul>
]]></content>
      <categories>
        <category>HAM</category>
      </categories>
      <tags>
        <tag>HAM</tag>
      </tags>
  </entry>
  <entry>
    <title>README</title>
    <url>/2019/12/16/Git/README/</url>
    <content><![CDATA[<h1 id="Github常用命令"><a href="#Github常用命令" class="headerlink" title="Github常用命令"></a>Github常用命令</h1><p>今日又重新启用了    github  来管理软件课设，渣渣以前还没用过呢</p>
<p>主要阐述一下关于    远程库与本地库的关联<br>至于多人协作开发部分，学了再记</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>gitignore</title>
    <url>/2019/11/27/Git/gitignore/</url>
    <content><![CDATA[<p><code>.gitignore</code> 文件常用于在 git 中忽略一些文件或目录</p>
<h2 id="语法规范"><a href="#语法规范" class="headerlink" title="语法规范"></a>语法规范</h2><ul>
<li>空行或是以#开头的行即注释行将被忽略。</li>
<li>可以在前面添加正斜杠/来避免递归,下面的例子中可以很明白的看出来与下一条的区别。</li>
<li>可以在后面添加正斜杠/来忽略文件夹，例如build/即忽略build文件夹。</li>
<li>可以使用!来否定忽略，即比如在前面用了*.apk，然后使用!a.apk，则这个a.apk不会被忽略。</li>
<li>*用来匹配零个或多个字符，如*.[oa]忽略所有以”.o”或”.a”结尾，*<del>忽略所有以</del>结尾的文件（这- 种文件通常被许多编辑器标记为临时文件）；[]用来匹配括号内的任一字符，如[abc]，也可以在括号内加连接符，如[0-9]匹配0至9的数；?用来匹配单个字符。<br>看了这么多，还是应该来个栗子：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 忽略 .a 文件</span></span><br><span class="line">*.a</span><br><span class="line"><span class="comment"># 但否定忽略 lib.a, 尽管已经在前面忽略了 .a 文件</span></span><br><span class="line">!lib.a</span><br><span class="line"><span class="comment"># 仅在当前目录下忽略 TODO 文件， 但不包括子目录下的 subdir/TODO</span></span><br><span class="line">/TODO</span><br><span class="line"><span class="comment"># 忽略 build/ 文件夹下的所有文件</span></span><br><span class="line">build/</span><br><span class="line"><span class="comment"># 忽略 doc/notes.txt, 不包括 doc/server/arch.txt</span></span><br><span class="line">doc/*.txt</span><br><span class="line"><span class="comment"># 忽略所有的 .pdf 文件 在 doc/ directory 下的</span></span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure>

<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>在文件夹前使用 <code>/</code> 可以用来避免递归如：</p>
<ul>
<li><code>*.txt</code> 表示忽略当前文件夹及子文件夹下的 <code>.txt</code> 文件</li>
<li><code>/*.txt</code> 表示仅忽略当前文件夹下的 <code>*.txt</code> 文件</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git/how-to-use-git</title>
    <url>/2020/05/30/Git/how-to-use-git/</url>
    <content><![CDATA[<hr>
<p>title: How To Use Git<br>date: 2020/1/5 18:22<br>categories:</p>
<ul>
<li>Git<br>tags:</li>
<li>Git</li>
</ul>
<hr>
<ul>
<li>版本管理</li>
</ul>
<p>git 的版本管理主要靠<code>HEAD</code>指向的<code>commitId</code>来改变，是针对于一个<code>branch</code>而言，每个版本的内容除文件外还有日志<code>git log</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard  commitId      // 版本的切换</span><br><span class="line">git reflog                      // 可以查看向后的commitId</span><br></pre></td></tr></table></figure>

<h2 id="远程库与本地库"><a href="#远程库与本地库" class="headerlink" title="远程库与本地库"></a>远程库与本地库</h2><p>首先来一波本地库的操作<br><code>git init</code>来创建一个本地库 </p>
<p><code>git remote add [name] git@github.com:username/xxxx.git</code></p>
<p>来关联一个远程库</p>
<p>然后，你可能在本地库里经过了一番骚操作:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m [message]</span><br></pre></td></tr></table></figure>

<p>然后 push <code>git push -u origin master</code>  嘻嘻，报错，报错信息类似这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">To https://github.com/USERNAME/REPOSITORY.git</span><br><span class="line"> ! [rejected]        master -&gt; master (non-fast-forward)</span><br><span class="line">error: failed to push some refs to &apos;https://github.com/USERNAME/REPOSITORY.git&apos;</span><br><span class="line">To prevent you from losing history, non-fast-forward updates were rejected</span><br><span class="line">Merge the remote changes (e.g. &apos;git pull&apos;) before pushing again.  See the</span><br><span class="line">&apos;Note about fast-forwards&apos; section of &apos;git push --help&apos; for details.</span><br></pre></td></tr></table></figure>

<p>为啥呢？因为远程库里有东西啊，想想也是，肯定不能随随便便    push    上去，那还版本管理啥啊，</p>
<p>于是乎，三条建议：</p>
<ol>
<li><code>git pull origin master</code></li>
</ol>
<p>把远程库先<code>pull</code>下来然后再<code>push</code></p>
<ol start="2">
<li><code>git fetch origin</code>  <code>git merge origin master</code></li>
</ol>
<p>这种方法与 1 原理相同</p>
<p>前面两种都属于 正规做法，还有下面的非主流做法：</p>
<ol>
<li><code>git push origin master -f</code></li>
</ol>
<p>强推！！！当然了这一推远程库就被更改地与你一致了。:)不建议</p>
<h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><ol>
<li><p><code>github.com</code> 的链接可以使用锚链接了！！ <code>https://github.com/python/cpython/blob/2.7/Python/bltinmodule.c#L1580</code> 指示在该 <code>.c</code> 文件的 1580 行</p>
</li>
<li><p>当出现 <code>Failed to connect to github.com port 443: Timed out</code> 的错误，是 http.proxy 的问题</p>
</li>
</ol>
<ul>
<li><code>git config --global http.proxy (127.0.0.1:1080)</code></li>
<li><code>git config --get http.proxy</code></li>
<li><code>git config --list</code></li>
</ul>
<ol start="3">
<li><code>git status</code> 显示的中文为八进制字符，而不是中文</li>
</ol>
<ul>
<li><code>git config --global core.quotepath false</code> 设置 <code>core.quotepath</code> 为 <code>false</code></li>
</ul>
<ol start="4">
<li><p><code>git clone</code>之后拉取远程分支：</p>
<ol>
<li><code>git branch -a</code> 显示远程所有分支；<code>git checkout origin/branch</code> 切换至某一远程分支（此时并没有建立本地与之对应的分支）；<code>git checkout xxx_branch</code> 建立与远程分支对应的分支；</li>
<li><code>git pull -all</code> 拉取所有分支到本地；</li>
<li><code>git clone -b xxx_branch https://xxx</code> 克隆某一分支到本地；</li>
</ol>
</li>
</ol>
<h2 id="分支的管理"><a href="#分支的管理" class="headerlink" title="分支的管理"></a>分支的管理</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch YourBranch      //  创建分支MyBranch</span><br><span class="line">git branch -d YourBranch   //　删除分支MyBranch</span><br><span class="line">git checkout YourBranch    //  切换分支</span><br><span class="line">//  git checkout -b YourBranch    </span><br><span class="line">git merge  Branch          // 合并分支，需要解决冲突</span><br><span class="line">git diff branch1 branch2 --stat // 显示出所有有差异的文件列表</span><br><span class="line">git diff branch1 branch2    // 显示出差异文件的详细差异</span><br></pre></td></tr></table></figure>

<p><strong>注：</strong>　合并分支时可以 master-&gt;dev，也可以　dev-&gt;master　只需要解决冲突一次即可</p>
<ul>
<li>remote, local的管理</li>
</ul>
<p>查看远程库信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>

<p>远程仓库的名字一般为：<code>origin</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:url        //  将远程仓库克隆到本地，此时自动构建master分支与远程master分支关联</span><br><span class="line">git remote add origin git@github.com:xxxx/xxxx.git        //  关联远程仓库</span><br><span class="line">git push origin master        //  将本地master分支提交到远程仓库master分支</span><br></pre></td></tr></table></figure>

<p>创建远程分支 dev 到本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure>

<p>将本地分支与远程分支建立链接，以便 <code>git pull</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/dev dev</span><br></pre></td></tr></table></figure>

<ul>
<li><code>git stash</code>命令的使用</li>
</ul>
<p><code>git stash</code>会把当前暂存区与工作区的改动保存起来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">git stash</span><br><span class="line">git stash save &apos;message&apos; ...        // 保存当前进度并添加一些注释</span><br><span class="line"></span><br><span class="line">git stash list      // 显示保存进度的列表</span><br><span class="line"></span><br><span class="line">git stash pop       // 恢复进度至工作区</span><br><span class="line">git stash pop stash@&#123;1&#125;</span><br><span class="line"></span><br><span class="line">git stash drop [stash_id]   // 删除存储的进度</span><br><span class="line"></span><br><span class="line">git stash clear             // 删除所有存储的进度</span><br></pre></td></tr></table></figure>

<p>ref: <a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的git教程</a></p>
]]></content>
  </entry>
  <entry>
    <title>README</title>
    <url>/2019/12/02/Java/README/</url>
    <content><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="Java环境的配置"><a href="#Java环境的配置" class="headerlink" title="Java环境的配置"></a>Java环境的配置</h2><p>Java 环境变量的配置：</p>
<ul>
<li><code>JAVA_HOME</code> 指向 JDK 的路径</li>
<li><code>CLASS_PATH</code> 的路径常用： <code>.;%JAVA_HOME%\lib\;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</code></li>
<li><code>PATH</code> 的路径常用： <code>%JAVA_HOME%\bin\;%JAVA_HOME%\jre\bin\;</code></li>
</ul>
<h2 id="IDEA-的环境配置（必要配置部分）"><a href="#IDEA-的环境配置（必要配置部分）" class="headerlink" title="IDEA 的环境配置（必要配置部分）"></a>IDEA 的环境配置（必要配置部分）</h2><p>JDK、Java Language Level的配置：</p>
<p><code>File</code> - <code>Project Structure</code> - <code>Project</code> 可以配置：</p>
<ul>
<li><code>Project SDK</code> </li>
<li><code>Project language level</code></li>
<li><code>Project compiler output</code></li>
</ul>
<p>导入 jar 包：</p>
<p><code>File</code> - <code>Project Structure</code> - <code>Modules</code> - <code>Dependencies</code> 点击 + 添加 jar 包的路径</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Chapter1</title>
    <url>/2019/11/08/Java/Chapter1/</url>
    <content><![CDATA[<h1 id="Java概述"><a href="#Java概述" class="headerlink" title="Java概述"></a>Java概述</h1><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>起源于sun公司后被Oracel公司合并<br>java.sun.com—oracel.com</p>
<p>Java三大平台</p>
<ul>
<li>Java SE</li>
<li>Java EE</li>
<li>Java ME</li>
</ul>
<h2 id="相关词"><a href="#相关词" class="headerlink" title="相关词"></a>相关词</h2><p>1.<strong>JVM</strong> Java Virtual Meachine<br>JVM Java虚拟机，定义了Java程序运行的环境，如指令集，寄存器集……虚拟cpu与内存结构等<br>JVM 给Java程序带来了很多优点，如安全性，跨平台，自动垃圾回收  </p>
<p>2.<strong>JRE</strong> Java Runtime Environment<br>当不作java程序开发，而仅仅是运行java程序时，下载安装JRE即可<br>3.<strong>JDK</strong> Java Development Kit<br>java开发者必备</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">三者的关系大致是这样的：  </span><br><span class="line">JRE = JVM + API(Lib)  </span><br><span class="line">JDK = JRE + Tools(Complier,Debugger...)</span><br></pre></td></tr></table></figure>
<h2 id="核心机制"><a href="#核心机制" class="headerlink" title="核心机制"></a>核心机制</h2><ul>
<li>JVM</li>
<li>Code Security</li>
<li>Garbage Collection</li>
</ul>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>Java语言与C++类似，语法更为简单</p>
<ul>
<li>OOP较纯粹于C++</li>
<li>平台无关性</li>
<li>安全稳定</li>
<li>支持多线程（来源于JVM）</li>
<li>丰富的类库<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java与C++的一些区别:</span><br><span class="line">*** 无直接指针操作</span><br><span class="line">*** 自动内存管理,无delete</span><br><span class="line">*** 数据类型长度固定(JVM)</span><br><span class="line">*** 不用头文件</span><br><span class="line">*** 不包含结构和联合</span><br><span class="line">*** 不支持宏</span><br><span class="line">*** 不用多重继承</span><br><span class="line">*** 无类外全局变量</span><br><span class="line">*** 无 goto</span><br></pre></td></tr></table></figure>
<h2 id="编译与运行机制"><a href="#编译与运行机制" class="headerlink" title="编译与运行机制"></a>编译与运行机制</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                                             |-----JVM for Dos</span><br><span class="line">source.java---source.class（字节码bytecode，用于JVM） |------JVM for Win</span><br><span class="line">                                             |-----JVM for UNIX</span><br></pre></td></tr></table></figure>
<h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2></li>
<li>javac———complier</li>
<li>java———-</li>
<li>jar———–</li>
<li>javaw———</li>
<li>javadoc——-</li>
</ul>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>(1) 直接使用JDK<br>(2) 文本工具 + 调用JDK<br>(3) IDE,如eclipe,NetBeans<br>(4) 自己配置文本编辑器   </p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>README</title>
    <url>/2019/11/08/JavaScript/README/</url>
    <content><![CDATA[<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><p>学习Javascript是因为当初想开发一个Chrome插件，就是在仓库中的Chrome-extension，实现网页的快照功能</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>java</title>
    <url>/2019/12/10/Java/java.util/</url>
    <content><![CDATA[<h1 id="java-util-package"><a href="#java-util-package" class="headerlink" title="java.util package"></a>java.util package</h1><h2 id="查找数据结构"><a href="#查找数据结构" class="headerlink" title="查找数据结构"></a>查找数据结构</h2><p>使用Hash的<code>HashTable</code>、<code>HashMap</code>都具有很高效的查找效率</p>
<ul>
<li><code>java.util.HashMap</code></li>
<li><code>java.util.HashTable</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashTable&lt;String, Double&gt; class_prob = <span class="keyword">new</span> HashTable&lt;String, Double&gt;();</span><br><span class="line">HashTable&lt;Map&lt;String, Double&gt;, Double&gt; class_term_prob = <span class="keyword">new</span> HashTable&lt;Map&lt;String, Double&gt;, Double&gt;();</span><br><span class="line">class_prob.put(classname, Double.valueOf(args[<span class="number">1</span>])/file_total);</span><br><span class="line">prob = class_prob.getOrDefault(classname, defaultValue: <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">map.put(classname,term);</span><br><span class="line">class_term_prob.put(map, (count+<span class="number">1</span>)/(class_term_total.get(classname)+class_term_num.get(classname)));</span><br></pre></td></tr></table></figure>

<ul>
<li><code>java.util.Map</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(String word:words)&#123;</span><br><span class="line">    Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    map.put(classname, word);</span><br><span class="line">    result += Math.log(class_term_prob.getOrDefault(map,<span class="number">1.0</span>/(class_term_total.get(classname)+class_term_num.get(classname))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>README</title>
    <url>/2019/11/08/Linux/README/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim 使用</title>
    <url>/2020/03/22/Linux/VIM/</url>
    <content><![CDATA[<h1 id="查找关键字"><a href="#查找关键字" class="headerlink" title="查找关键字"></a>查找关键字</h1><p>在 <strong>命令模式</strong> 下敲入 <code>/</code> 输入要查找的关键字，回车即可进行查找对应的关键字：<code>n</code> 代表下一个 match，<code>N</code> 代表上一个 match</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/2020/01/05/Java/Maven/</url>
    <content><![CDATA[<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="1-安装与配置"><a href="#1-安装与配置" class="headerlink" title="1. 安装与配置"></a>1. 安装与配置</h2><p><em>Maven3要求JDK1.7以上</em></p>
<p>设置环境变量：</p>
<ul>
<li><code>M2_HOME=&quot;/usr/local/maven&quot;</code></li>
<li><code>M2=/usr/local/maven/bin</code></li>
<li><code>PATH</code></li>
</ul>
<h2 id="2-仓库的配置"><a href="#2-仓库的配置" class="headerlink" title="2. 仓库的配置"></a>2. 仓库的配置</h2><p>这些配置都位于 <code>maven/conf/setting.xml</code>　文件中</p>
<h3 id="2-1-本地仓库的配置"><a href="#2-1-本地仓库的配置" class="headerlink" title="2.1 本地仓库的配置"></a>2.1 本地仓库的配置</h3><ul>
<li><code>localRepository</code> 关键字中</li>
</ul>
<h3 id="2-2-中央仓库的配置"><a href="#2-2-中央仓库的配置" class="headerlink" title="2.2 中央仓库的配置"></a>2.2 中央仓库的配置</h3><p>maven 下载依赖包的执行流程：</p>
<p><img src="/2020/01/05/Java/Maven/maven.jpg" alt="maven"></p>
<p>修改默认中央仓库的位置（以阿里云为例）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*,!jeecg,!jeecg-snapshots<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-项目的创建"><a href="#3-项目的创建" class="headerlink" title="3. 项目的创建"></a>3. 项目的创建</h2><h3 id="3-1-POM-Project-Object-Model-项目对象模型"><a href="#3-1-POM-Project-Object-Model-项目对象模型" class="headerlink" title="3.1 POM(Project Object Model)项目对象模型"></a>3.1 POM(Project Object Model)项目对象模型</h3><h3 id="3-2-坐标"><a href="#3-2-坐标" class="headerlink" title="3.2 坐标"></a>3.2 坐标</h3><ul>
<li><code>groupId</code></li>
<li><code>artifactId</code></li>
<li><code>version</code></li>
</ul>
<h2 id="4-常用命令"><a href="#4-常用命令" class="headerlink" title="4. 常用命令"></a>4. 常用命令</h2><h3 id="4-1-项目的创建"><a href="#4-1-项目的创建" class="headerlink" title="4.1 项目的创建"></a>4.1 项目的创建</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId=packageName -DartifactId=projectName -DarchetypeArtifactId=maven-archetype-quickstart/maven-archetype-webapp -DinteractiveMode=false   # 普通　java 项目/Web项目</span><br><span class="line">mvn archetype:create</span><br><span class="line">-X                        # 可打印出构建的过程，方便debug</span><br><span class="line">-DarchetypeCatalog=local  # 读取本地catalog文件，不用从repo.maven下载</span><br></pre></td></tr></table></figure>

<ul>
<li><code>groupId</code> 会自动在<code>name/src/main/java/</code>目录下构建起 package == package name</li>
<li><code>artifactId</code> 是项目文件夹的名字</li>
<li>使用命令行生成maven工程不需要新建文件夹</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-DgroupId=com.sample</span><br><span class="line">-DartifactId=NaiveBayes             #</span><br></pre></td></tr></table></figure>

<h3 id="4-2-代码的编译"><a href="#4-2-代码的编译" class="headerlink" title="4.2 代码的编译"></a>4.2 代码的编译</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn compile         # 源代码的编译</span><br><span class="line">mvn test-compile    # 测试代码的编译</span><br></pre></td></tr></table></figure>

<h3 id="4-3-运行测试"><a href="#4-3-运行测试" class="headerlink" title="4.3 运行测试"></a>4.3 运行测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn test</span><br><span class="line">mvn test -Dtest=xxx.xxx.package_name    # 单个测试文件进行测试</span><br></pre></td></tr></table></figure>

<h3 id="4-4-打包"><a href="#4-4-打包" class="headerlink" title="4.4 打包"></a>4.4 打包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn package             #　打包</span><br><span class="line">mvn jar:jar             #  打jar包</span><br></pre></td></tr></table></figure>

<h3 id="4-5-生成其他项目"><a href="#4-5-生成其他项目" class="headerlink" title="4.5 生成其他项目"></a>4.5 生成其他项目</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn idea:idea           # 生成IDEA项目</span><br><span class="line">mvn eclipse:eclipse     # 生成eclipse项目</span><br></pre></td></tr></table></figure>

<h3 id="4-6-下载依赖包"><a href="#4-6-下载依赖包" class="headerlink" title="4.6 下载依赖包"></a>4.6 下载依赖包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn dependency:sources  #　下载依赖的源码包</span><br></pre></td></tr></table></figure>

<h3 id="4-7-清理"><a href="#4-7-清理" class="headerlink" title="4.7 清理"></a>4.7 清理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean               #  清除　target 目录</span><br></pre></td></tr></table></figure>

<h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/73444114" target="_blank" rel="noopener">知乎</a></li>
<li><a href="https://www.iteye.com/blog/stevenfeng-987623" target="_blank" rel="noopener">https://www.iteye.com/blog/stevenfeng-987623</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/73444114" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/73444114</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA</title>
    <url>/2020/01/05/MLDL/CUDA/</url>
    <content><![CDATA[<h1 id="CUDA"><a href="#CUDA" class="headerlink" title="CUDA"></a>CUDA</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>暑假实习的是关于一个 GPU 开发库的Python版本项目，该项目 C++ 版本与 Python 版本进行同步开发，Python版本使用 <code>swig</code> 进行 C++ interface 的 wrap，这些 GPU 编程库往往都有很多相似的地方，当时借鉴了很多 CUDA 的相关资料，这里进行记录</p>
<h3 id="1-2-高效的-GPU-任务具备条件"><a href="#1-2-高效的-GPU-任务具备条件" class="headerlink" title="1.2 高效的 GPU 任务具备条件"></a>1.2 高效的 GPU 任务具备条件</h3><ol>
<li>具有成千上万的独立工作<ul>
<li>尽量利用大量的 ALU 单元</li>
<li>大量的片元切换隐延迟</li>
</ul>
</li>
<li>可以共享指令流<ul>
<li>适用于 SIMD 处理</li>
</ul>
</li>
<li>最好是计算密集型任务<ul>
<li>通信和计算开销比例适合</li>
<li>不要受制于访存带宽</li>
</ul>
</li>
</ol>
<p><strong>CUDA这一部分应该掌握GPU软硬件之间的对应关系</strong></p>
<h2 id="2-GPU的体系结构"><a href="#2-GPU的体系结构" class="headerlink" title="2. GPU的体系结构"></a>2. GPU的体系结构</h2><h3 id="2-1-硬件"><a href="#2-1-硬件" class="headerlink" title="2.1 硬件"></a>2.1 硬件</h3><ul>
<li>SP（Streaming Processor），亦称 CUDA core，指令和任务的实际执行者</li>
<li>SM（Streaming Multiprocessor），GPu大核，拥有除SP外的其它资源如： wrap scheduler、register、shared memory等。</li>
</ul>
<p>展示GPU的一个SM的示意图（绿色部分为 SP）：</p>
<p><img src="/2020/01/05/MLDL/CUDA/cuda_sm.png" alt="cuda_sm"></p>
<p>GPU 中的内存按照访存速度划分：</p>
<ul>
<li>Register</li>
<li>shared memory (block)</li>
<li>local memory</li>
<li>global memory (device)</li>
<li>constant memory (device)</li>
<li>texture memory</li>
<li>instruction memory (invisible)</li>
</ul>
<h3 id="2-2-软件"><a href="#2-2-软件" class="headerlink" title="2.2 软件"></a>2.2 软件</h3><p>软件的三级结构： </p>
<ul>
<li>thread</li>
<li>block</li>
<li>grid</li>
</ul>
<p><img src="/2020/01/05/MLDL/CUDA/cuda_sw.png" alt="cuda_sw"></p>
<h3 id="2-3-软硬件之间的对应关系"><a href="#2-3-软硬件之间的对应关系" class="headerlink" title="2.3 软硬件之间的对应关系"></a>2.3 软硬件之间的对应关系</h3><p><img src="/2020/01/05/MLDL/CUDA/cuda_sw_hw.png" alt="cuda_sw_hw"></p>
<h2 id="3-CUDA的编程模型"><a href="#3-CUDA的编程模型" class="headerlink" title="3. CUDA的编程模型"></a>3. CUDA的编程模型</h2><h3 id="3-1-CUDA-的算法框架"><a href="#3-1-CUDA-的算法框架" class="headerlink" title="3.1 CUDA 的算法框架"></a>3.1 CUDA 的算法框架</h3><p>1) 在 GPU 上分配显存，拷贝数据 host to device<br>2) kernel invocation code<br>3) 运算结束后，输出数据拷贝 device to host</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>[Introduction-to-GPUs.pdf](/2020/01/05/MLDL/CUDA/Introduction-to-GPUs.pdf</li>
<li><a href="https://blog.csdn.net/junparadox/article/details/50540602" target="_blank" rel="noopener">CUDA编程</a></li>
<li><a href="https://www.bilibili.com/video/av10436982?from=search&seid=450076380525809673" target="_blank" rel="noopener">《CUDA编程教程》 B站视频</a></li>
<li>《CUDA并行程序设计 GPU编程指南》</li>
<li><a href="https://www.easyhpc.net/lab/detail/22/" target="_blank" rel="noopener">超算课堂-CUDA编程实训</a></li>
<li><a href="https://devblogs.nvidia.com/easy-introduction-cuda-c-and-c/" target="_blank" rel="noopener">Nvidia-introductoion-of-cuda-c-and-c</a></li>
</ul>
]]></content>
      <categories>
        <category>MLDL</category>
      </categories>
      <tags>
        <tag>MLDL</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 命令杂谈</title>
    <url>/2020/03/22/Linux/MISC(1)/</url>
    <content><![CDATA[<h1 id="Linux-命令杂谈"><a href="#Linux-命令杂谈" class="headerlink" title="Linux 命令杂谈"></a>Linux 命令杂谈</h1><h2 id="进程查看命令"><a href="#进程查看命令" class="headerlink" title="进程查看命令"></a>进程查看命令</h2><ul>
<li><code>ps -aux</code> 与 <code>ps aux</code> 与 <code>ps -ef</code></li>
</ul>
<p>输出都是一样的，是当前终端机下的所有进程，至于几个的主要区别：<br><code>ps -aux</code> 等价于 <code>ps aux</code>，但可能会截断 COMMAND 列的输出，不适用于 <code>grep</code> 搭配，而 <code>ps -ef</code> 不存在这种情况，可与 <code>grep</code> 进行搭配使用。</p>
<h2 id="nohup-xxx-amp"><a href="#nohup-xxx-amp" class="headerlink" title="nohup xxx &amp;"></a><code>nohup xxx &amp;</code></h2><p>后台不挂断运行</p>
<ul>
<li><code>nohup</code> （no hang up）程序不挂断的运行，即无论终端是否断开，都会一直运行，但没有后台运行的功能；</li>
<li><code>&amp;</code> 后台运行，但没有不可挂断执行的功能；</li>
</ul>
<p>因此常将两者结合使用用于不可挂断的后台执行。</p>
<p>如何查看？</p>
<p>如果终端没有关闭，<code>jobs</code> 可以查看当前终端下的进程</p>
<h2 id="查看内核及操作系统版本"><a href="#查看内核及操作系统版本" class="headerlink" title="查看内核及操作系统版本"></a>查看内核及操作系统版本</h2><h3 id="查看内核版本"><a href="#查看内核版本" class="headerlink" title="查看内核版本"></a>查看内核版本</h3><ul>
<li><code>uname -a</code></li>
<li><code>uname -r</code></li>
</ul>
<p>关于 Linux 内核版本号的格式：</p>
<p>major.minor.patch-build.desc</p>
<h3 id="查看操作系统版本"><a href="#查看操作系统版本" class="headerlink" title="查看操作系统版本"></a>查看操作系统版本</h3><ul>
<li><code>cat /proc/version</code></li>
<li><code>cat /etc/issue</code></li>
<li><code>lsb_release -a</code> 适用于 Ubuntu/Debian</li>
</ul>
<h2 id="wget-下载工具"><a href="#wget-下载工具" class="headerlink" title="wget 下载工具"></a><code>wget</code> 下载工具</h2><ul>
<li><code>wget -b xxx_url</code> 下载 <code>xxx_url</code> 对应的内容并后台下载</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ipdb</title>
    <url>/2020/01/02/MLDL/Ipdb/</url>
    <content><![CDATA[<h1 id="IPDB-Ipython-Debugger"><a href="#IPDB-Ipython-Debugger" class="headerlink" title="IPDB (Ipython Debugger)"></a>IPDB (Ipython Debugger)</h1><p>IPDB和GDB类似，是一款集成了<code>Ipython</code>的Python代码命令行调试工具。</p>
<h2 id="1-集成到源代码中使用"><a href="#1-集成到源代码中使用" class="headerlink" title="1. 集成到源代码中使用"></a>1. 集成到源代码中使用</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ipdb</span><br><span class="line"></span><br><span class="line">x = <span class="number">10</span></span><br><span class="line">ipdb.set_trace() <span class="comment"># 执行到此，程序停止，展开Ipython环境</span></span><br><span class="line">y = <span class="number">20</span></span><br></pre></td></tr></table></figure>

<h2 id="2-交互式使用"><a href="#2-交互式使用" class="headerlink" title="2. 交互式使用"></a>2. 交互式使用</h2><p><code>python -m ipdb code.py</code></p>
]]></content>
      <categories>
        <category>MLDL</category>
      </categories>
      <tags>
        <tag>MLDL</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter</title>
    <url>/2019/11/30/MLDL/Jupyter/</url>
    <content><![CDATA[<h1 id="Jupyter-的使用"><a href="#Jupyter-的使用" class="headerlink" title="Jupyter 的使用"></a>Jupyter 的使用</h1><p>Jupyter 通篇内容有两种格式：Markdown 与 code，Markdown 模式下可以进行 Markdown 的编辑，code 模式下则可以进行代码的运行，这样有机地将代码和注释结合起来。</p>
<h2 id="Markdown-模式"><a href="#Markdown-模式" class="headerlink" title="Markdown 模式"></a>Markdown 模式</h2><p><code>shift</code>+<code>enter</code> 快捷键是个很重要的快捷键，在 Markdown 模式下使用则可以进行预览和编辑的切换</p>
<h2 id="Code-模式"><a href="#Code-模式" class="headerlink" title="Code 模式"></a>Code 模式</h2><p><code>shift</code>+<code>enter</code> 快捷键在 <code>code/md</code> 模式下可以进行代码/字体的创建和运行</p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul>
<li><code>H</code>：查看所有快捷键。</li>
<li><code>S</code>：保存当前 Notebook 内容。</li>
<li><code>P</code>：调出 Notebook 命令栏。</li>
</ul>
<h3 id="对单元格（Cell）的操作"><a href="#对单元格（Cell）的操作" class="headerlink" title="对单元格（Cell）的操作"></a>对单元格（Cell）的操作</h3><ul>
<li><code>A/a</code>: 在当前单元格上方新建单元格 cell</li>
<li><code>B/b</code>：在当前单元格下方新建空白单元格。</li>
<li><code>M</code>：将单元格格式转换为 Markdown。</li>
<li><code>Y</code>：将单元格格式转换为 Code。</li>
<li><code>连续按 D+D/ d+d</code>：删除当前单元格。（慎用，推荐使用 X 剪切单元格代替，因为其可以起到删除效果，且删错了还可以粘贴回来）</li>
<li><code>Shift + Enter</code>：运行当前单元格内容。（当 Markdown 单元格处于编辑状态时，运行即可复原)</li>
<li><code>ESC</code> 在编辑模式（绿色）与非编辑模式（蓝色）下切换</li>
</ul>
<h2 id="服务器-Jupyter-搭建"><a href="#服务器-Jupyter-搭建" class="headerlink" title="服务器 Jupyter 搭建"></a>服务器 Jupyter 搭建</h2><ol>
<li><p>安装 jupyter notebook：<code>pip install jupyter</code></p>
</li>
<li><p>生成配置文件：<code>jupyter notebook --generate-config</code></p>
</li>
<li><p>设置 jupyter notebook 的密码：</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">from</span> IPython.lib <span class="keyword">import</span> passwd</span><br><span class="line">In [<span class="number">2</span>]: passwd()</span><br><span class="line">Enter password: </span><br><span class="line">Verify password:</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>设置配置文件：<code>vim ~/.jupyter/jupyter_notebook_config.py</code></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 常见配置选项</span></span><br><span class="line">c.NotebookApp.ip = <span class="string">'*'</span> <span class="comment">#所有绑定服务器的IP都能访问，若想只在特定ip访问，输入ip地址即可</span></span><br><span class="line">c.NotebookApp.port = <span class="number">6666</span> <span class="comment">#将端口设置为自己喜欢的吧，默认是8888</span></span><br><span class="line">c.NotebookApp.open_browser = <span class="literal">False</span> <span class="comment">#我们并不想在服务器上直接打开Jupyter Notebook，所以设置成False</span></span><br><span class="line">c.NotebookApp.notebook_dir = <span class="string">'/root/jupyter_projects'</span> <span class="comment">#这里是设置Jupyter的根目录，若不设置将默认root的根目录，不安全</span></span><br><span class="line">c.NotebookApp.allow_root = <span class="literal">True</span> <span class="comment"># 为了安全，Jupyter默认不允许以root权限启动jupyter</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>启动远程服务器：<code>jupyter notebook</code></p>
</li>
<li><p>打开浏览器访问对应的url，输入 token 即可。</p>
</li>
</ol>
<p>当对应的 notebook token 忘记时，可以使用 <code>jupyter notebook list</code> 访问不同 notebook 的 token</p>
]]></content>
      <categories>
        <category>MLDL</category>
      </categories>
      <tags>
        <tag>MLDL</tag>
      </tags>
  </entry>
  <entry>
    <title>conda</title>
    <url>/2019/12/12/MLDL/conda/</url>
    <content><![CDATA[<h1 id="Conda"><a href="#Conda" class="headerlink" title="Conda"></a>Conda</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看已创建的 python 环境</span></span><br><span class="line">conda info --env</span><br><span class="line"><span class="comment"># 查看conda下的所有基本配置</span></span><br><span class="line">conda config --show</span><br><span class="line"><span class="comment"># 删除conda的channel</span></span><br><span class="line">conda config --remove channels <span class="string">'default'</span></span><br><span class="line"><span class="comment"># 添加conda的channel</span></span><br><span class="line">conda config --add channels https://xxx</span><br><span class="line"><span class="comment"># 配置清华PyPI镜像（如无法运行，将pip版本升级到&gt;=10.0.0）</span></span><br><span class="line">pip config set <span class="keyword">global</span>.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"><span class="comment"># 创建环境</span></span><br><span class="line">conda create --name envname python=<span class="number">3.6</span></span><br><span class="line"><span class="comment"># 激活环境</span></span><br><span class="line">conda activate envname</span><br><span class="line"><span class="comment"># 获取当前环境中已经安装的包</span></span><br><span class="line">conda list</span><br><span class="line"><span class="comment"># 获取某个环境中安装的包</span></span><br><span class="line">conda list -n envname</span><br><span class="line"><span class="comment"># 退出环境</span></span><br><span class="line">conda deactivate</span><br><span class="line"><span class="comment"># 删除环境</span></span><br><span class="line">conda remove -n envname --all</span><br><span class="line"><span class="comment"># 导出环境</span></span><br><span class="line">conda env export &gt; environment.yml</span><br><span class="line"><span class="comment"># 根据 .yml 文件创建环境</span></span><br><span class="line">conda env create -f environment.yml</span><br></pre></td></tr></table></figure>

<h2 id="pip-源"><a href="#pip-源" class="headerlink" title="pip 源"></a>pip 源</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple -r requirements.txt <span class="comment"># pip 清华源</span></span><br><span class="line">pip install -i http://pypi.douban.com/simple/ -r requirements.txt           <span class="comment"># pip 豆瓣源</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/57287956" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/57287956</a></li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>MLDL</category>
      </categories>
      <tags>
        <tag>MLDL</tag>
      </tags>
  </entry>
  <entry>
    <title>RNN</title>
    <url>/2020/01/05/MLDL/RNN/</url>
    <content><![CDATA[<h1 id="RNN-循环神经网络"><a href="#RNN-循环神经网络" class="headerlink" title="RNN(循环神经网络)"></a>RNN(循环神经网络)</h1><p><em>参考：《深度学习入门之PyTorch》配套代码地址：<a href="https://github.com/L1aoXingyu/code-of-learn-deep-learning-with-pytorch" target="_blank" rel="noopener">https://github.com/L1aoXingyu/code-of-learn-deep-learning-with-pytorch</a></em></p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>卷积神经网络相当于人类的视觉，但是它没有记忆能力，只能处理一种特定的视觉任务，没办法根据以前的记忆来处理新的任务。</p>
<p>循环神经网络的提出是基于记忆模型的想法，期望网络能够记住前面出现的特征，并依据特征推断后面的结果，并且整体的网络结构不断循环，因此得名循环神经网络。</p>
<h2 id="2-网络结构"><a href="#2-网络结构" class="headerlink" title="2. 网络结构"></a>2. 网络结构</h2><p>使神经网络具有记忆性，一个很直观的做法是将隐藏层的信息进行保留作为下一个的输入，由此产生出的有以下几种网络结构：</p>
<h3 id="2-1-基本-RNN"><a href="#2-1-基本-RNN" class="headerlink" title="2.1 基本 RNN"></a>2.1 基本 RNN</h3><p><img src="/2020/01/05/MLDL/RNN/base_rnn.png" alt="base_RNN"></p>
<h3 id="2-2-双向-RNN（BiRNN"><a href="#2-2-双向-RNN（BiRNN" class="headerlink" title="2.2 双向 RNN（BiRNN)"></a>2.2 双向 RNN（BiRNN)</h3><p><img src="/2020/01/05/MLDL/RNN/BiRNN.png" alt="Bi_RNN"></p>
<h3 id="2-3-深层-RNN"><a href="#2-3-深层-RNN" class="headerlink" title="2.3 深层 RNN"></a>2.3 深层 RNN</h3><p><img src="/2020/01/05/MLDL/RNN/deep_RNN.jpg" alt="Deep_RNN"></p>
<p><em>以上图示均为按照时间线展开，实际只是网络的循环，故名循环神经网络</em></p>
<h2 id="3-存在的问题"><a href="#3-存在的问题" class="headerlink" title="3. 存在的问题"></a>3. 存在的问题</h2><p>早期的循环神经网络具有特别好的记忆性，能够记住当前情景下的内容，但这种循环神经网络能够解决短时依赖问题，对于长时依赖问题，由于记忆的信息和预测位置之间的跨度太大，网络并不能记忆这么长时间的信息，而且随着时间跨度的增大，循环神经网络也越来越难学习这些信息。</p>
<h2 id="4-循环神经网络的变式：LSTM-与-GRU"><a href="#4-循环神经网络的变式：LSTM-与-GRU" class="headerlink" title="4. 循环神经网络的变式：LSTM 与 GRU"></a>4. 循环神经网络的变式：LSTM 与 GRU</h2><h3 id="4-1-LSTM"><a href="#4-1-LSTM" class="headerlink" title="4.1 LSTM"></a>4.1 LSTM</h3><p>LSTM 是 Long Short Term Memory Networks的缩写，长短期记忆模型。LSTM 比基本的循环神经网络的网络结构内部要复杂。</p>
<p>LSTM 的三个门：</p>
<ul>
<li>输入门，输入门控制着网络的输入</li>
<li>遗忘门，遗忘门控制着记忆单元</li>
<li>输出门，输出门控制着网络的输出</li>
</ul>
<p><img src="/2020/01/05/MLDL/RNN/LSTM.png" alt="LSTM"></p>
<p><img src="/2020/01/05/MLDL/RNN/LSTM_1.jpg" alt="LSTM"></p>
<p><img src="/2020/01/05/MLDL/RNN/LSTM_2.jpg" alt="LSTM"></p>
<p><img src="/2020/01/05/MLDL/RNN/LSTM_3.jpg" alt="LSTM"></p>
<h3 id="4-2-GRU"><a href="#4-2-GRU" class="headerlink" title="4.2 GRU"></a>4.2 GRU</h3><p>GRU是 Gated Recurrent Unit的缩写，由 cho 在2014年提出。GRU 和 LSTM 最大的不同在于 GRU 将遗忘门和输入门合成了一个 “更新门”， 同时网络只进行传递和保存的状态是 <code>ht</code>.</p>
<p><img src="/2020/01/05/MLDL/RNN/LSTM_4.jpg" alt="LSTM"></p>
<h3 id="4-3-收敛性问题"><a href="#4-3-收敛性问题" class="headerlink" title="4.3 收敛性问题"></a>4.3 收敛性问题</h3><p>RNN 的误差曲面上存在很多陡峭的斜坡，斜坡上误差的变化率特别大，正是这个原因导致道路 loss 曲线在不断跳跃。</p>
<blockquote>
<p>正是因为网络在训练过程中，梯度的变化范围很大，所以设置一个固定的学习率并不能有效收敛，同时梯度的变化并没有规律，所以设置衰减的学习率也不能满足条件。</p>
</blockquote>
<p>可以采用的办法是： <strong>梯度裁剪</strong>，使用梯度裁剪能够将大的梯度裁，在一定程度上避免收敛不好的问题。</p>
<h2 id="5-循环神经网络的-pytorch-实现"><a href="#5-循环神经网络的-pytorch-实现" class="headerlink" title="5. 循环神经网络的 pytorch 实现"></a>5. 循环神经网络的 pytorch 实现</h2><h3 id="5-1-PyTorch-的循环网络模块"><a href="#5-1-PyTorch-的循环网络模块" class="headerlink" title="5.1 PyTorch 的循环网络模块"></a>5.1 PyTorch 的循环网络模块</h3><h4 id="1-标准-RNN"><a href="#1-标准-RNN" class="headerlink" title="1. 标准 RNN"></a>1. 标准 RNN</h4><ul>
<li><code>nn.RNN()</code></li>
</ul>
<p>关于参数设置：</p>
<ul>
<li><code>input_size</code> 表示输入 x 的特征维度</li>
<li><code>hidden_size</code> 表示输出 h 的特征维度</li>
<li><code>num_layers</code> 表示网络层数，默认是 1 层</li>
<li><code>nonlinearity</code> 表示非线性激活函数的选择，默认是 <code>tanh</code>，可以选择 <code>relu</code></li>
<li><code>bias</code> 表示是否使用偏置，默认是 <code>True</code></li>
<li><code>batch_first</code> 决定网络输入的维度顺序，默认网络输入按照 <code>(seq, batch, feature)</code> ，解释为：序列长度、批量、特征维度；如果该参数设置为 <code>True</code>，则顺序变成 <code>(batch, seq, feature)</code></li>
<li><code>dropout</code> 参数接收0-1的数值，会在网络中除了最后一层之外的其他输出层加上 <code>dropout</code> 层</li>
<li><code>bidirectional</code> 默认参数是 False</li>
</ul>
]]></content>
      <categories>
        <category>MLDL</category>
      </categories>
      <tags>
        <tag>MLDL</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy 系列一</title>
    <url>/2020/01/04/MLDL/numpy(%E4%B8%80)/</url>
    <content><![CDATA[<h1 id="Numpy-基础"><a href="#Numpy-基础" class="headerlink" title="Numpy 基础"></a>Numpy 基础</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>

<h2 id="1-函数"><a href="#1-函数" class="headerlink" title="1. 函数"></a>1. 函数</h2><h3 id="1-1-生成序列"><a href="#1-1-生成序列" class="headerlink" title="1.1 生成序列"></a>1.1 生成序列</h3><ul>
<li><code>range()</code> 可生成一定 step 的序列，但只能整数</li>
<li><code>arange()</code> 可生成一定 step 的序列，可以是浮点数</li>
</ul>
<h2 id="Tricks"><a href="#Tricks" class="headerlink" title="Tricks"></a>Tricks</h2><h2 id="2-np-eye-与-np-identity"><a href="#2-np-eye-与-np-identity" class="headerlink" title="2. np.eye() 与 np.identity()"></a>2. <code>np.eye()</code> 与 <code>np.identity()</code></h2><p><code>numpy.eye(N, M=None, k=0, dtype=&lt;class &#39;float&#39;&gt;, order=&#39;C&#39;)[source]</code></p>
<p>可以生成2-D的对角矩阵（不一定对角），零可以被设置放置在任意地方；</p>
<h3 id="2-1-Example"><a href="#2-1-Example" class="headerlink" title="2.1 Example"></a>2.1 Example</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.eye(<span class="number">2</span>, dtype=int)</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.eye(<span class="number">3</span>, k=<span class="number">1</span>)</span><br><span class="line">array([[<span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>]])</span><br><span class="line"><span class="comment"># 常用的可以对数组进行 one-hot 编码</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.eye(<span class="number">3</span>)[[<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>]]</span><br><span class="line">array([[<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure>

<p><code>np.identity(n, dtype=None)</code></p>
<p>仅能生成对角方阵</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.identity(<span class="number">3</span>)</span><br><span class="line">array([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure>

<h3 id="2-2-numpy-ndarray-flatten"><a href="#2-2-numpy-ndarray-flatten" class="headerlink" title="2.2 numpy.ndarray.flatten"></a>2.2 <code>numpy.ndarray.flatten</code></h3><p><code>ndarray.flatten(order=&#39;C&#39;)</code> 返回一个变换为1-D的副本</p>
<ul>
<li>paramenter: ‘C’- 行；’F’ - 列；’C’是默认的；</li>
</ul>
<p>Example:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.flatten()</span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.flatten(<span class="string">'F'</span>)</span><br><span class="line">array([<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>

<h3 id="2-3-numpy-argmax"><a href="#2-3-numpy-argmax" class="headerlink" title="2.3 numpy.argmax"></a>2.3 <code>numpy.argmax</code></h3><p><code>numpy.argmax(a, axis=None, out=None)</code> 找出 ndarray 中最大值对应的索引</p>
<p>Parameters:</p>
<ul>
<li>axis: 默认是将 array flatten，取其最大值对应的索引，当指定 axis = 0时，每一列的最大值 index；当 axis = 1时，每一行的最大值 index</li>
</ul>
<p>Examples：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">6</span>).reshape(<span class="number">2</span>,<span class="number">3</span>) + <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>],</span><br><span class="line">       [<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.argmax(a)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.argmax(a, axis=<span class="number">0</span>)</span><br><span class="line">array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.argmax(a, axis=<span class="number">1</span>)</span><br><span class="line">array([<span class="number">2</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MLDL</category>
      </categories>
      <tags>
        <tag>MLDL</tag>
      </tags>
  </entry>
  <entry>
    <title>pyplot</title>
    <url>/2020/01/04/MLDL/pyplot/</url>
    <content><![CDATA[<h1 id="pyplot"><a href="#pyplot" class="headerlink" title="pyplot"></a>pyplot</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>

<p>使用该库绘制图形</p>
<h2 id="2-矩阵-数组的可视化"><a href="#2-矩阵-数组的可视化" class="headerlink" title="2. 矩阵/数组的可视化"></a>2. 矩阵/数组的可视化</h2><p><code>matshow()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">samplemat</span><span class="params">(dims)</span>:</span></span><br><span class="line">    <span class="string">"""Make a matrix with all zeros and increasing elements on the diagonal"""</span></span><br><span class="line">    aa = np.zeros(dims)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(min(dims)):</span><br><span class="line">        aa[i, i] = i</span><br><span class="line">    <span class="keyword">return</span> aa</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Display matrix</span></span><br><span class="line">plt.matshow(samplemat((<span class="number">15</span>, <span class="number">15</span>)))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MLDL</category>
      </categories>
      <tags>
        <tag>MLDL</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy</title>
    <url>/2020/01/04/MLDL/numpy/</url>
    <content><![CDATA[<h1 id="Numpy-学习"><a href="#Numpy-学习" class="headerlink" title="Numpy 学习"></a>Numpy 学习</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>

<h2 id="1-函数"><a href="#1-函数" class="headerlink" title="1. 函数"></a>1. 函数</h2><h3 id="1-1-生成序列"><a href="#1-1-生成序列" class="headerlink" title="1.1 生成序列"></a>1.1 生成序列</h3><ul>
<li><code>range()</code> 可生成一定 step 的序列，但只能整数</li>
<li><code>arange()</code> 可生成一定 step 的序列，可以是浮点数</li>
</ul>
<h2 id="Tricks"><a href="#Tricks" class="headerlink" title="Tricks"></a>Tricks</h2><h2 id="2-np-eye-与-np-identity"><a href="#2-np-eye-与-np-identity" class="headerlink" title="2. np.eye() 与 np.identity()"></a>2. <code>np.eye()</code> 与 <code>np.identity()</code></h2><p><code>numpy.eye(N, M=None, k=0, dtype=&lt;class &#39;float&#39;&gt;, order=&#39;C&#39;)[source]</code></p>
<p>可以生成2-D的对角矩阵（不一定对角），零可以被设置放置在任意地方；</p>
<h3 id="2-1-Example"><a href="#2-1-Example" class="headerlink" title="2.1 Example"></a>2.1 Example</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.eye(<span class="number">2</span>, dtype=int)</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.eye(<span class="number">3</span>, k=<span class="number">1</span>)</span><br><span class="line">array([[<span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>]])</span><br><span class="line"><span class="comment"># 常用的可以对数组进行 one-hot 编码</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.eye(<span class="number">3</span>)[[<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>]]</span><br><span class="line">array([[<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure>

<p><code>np.identity(n, dtype=None)</code></p>
<p>仅能生成对角方阵</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.identity(<span class="number">3</span>)</span><br><span class="line">array([[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MLDL</category>
      </categories>
      <tags>
        <tag>MLDL</tag>
      </tags>
  </entry>
  <entry>
    <title>numpy 之 维度变换</title>
    <url>/2020/01/04/MLDL/numpy%E4%B9%8B%E7%BB%B4%E5%BA%A6%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="numpy-之维度变换"><a href="#numpy-之维度变换" class="headerlink" title="numpy 之维度变换"></a>numpy 之维度变换</h1><h2 id="维度变换"><a href="#维度变换" class="headerlink" title="维度变换"></a>维度变换</h2><p><code>numpy</code> 中关于维度变换函数有很多：<code>reshape</code>、<code>resize</code>、<code>swapaxes</code>、<code>flatten</code>、<code>transpose</code>等，下面有关于他们一一讲解。</p>
<h2 id="resize-与-reshape-函数"><a href="#resize-与-reshape-函数" class="headerlink" title="resize() 与 reshape() 函数"></a><code>resize()</code> 与 <code>reshape()</code> 函数</h2><p><code>resize()</code> 与 <code>reshape()</code> 功能相同，主要区别在于：</p>
<ul>
<li><code>resize()</code> 会修改原数组</li>
<li><code>reshape()</code> 不会修改原数组</li>
</ul>
<h2 id="swapaxes-与-transpose-函数"><a href="#swapaxes-与-transpose-函数" class="headerlink" title="swapaxes() 与 transpose() 函数"></a><code>swapaxes()</code> 与 <code>transpose()</code> 函数</h2><ul>
<li><code>swapaxes()</code> 将原数组中的两个维度进行替换，并不改变原数组</li>
<li><code>transpose()</code> 可以进行多个维度的变换，类比于矩阵的转置功能，将原来<code>(i,j,k)</code>上的数据变换到<code>(i,k,j)</code>上来</li>
</ul>
<h2 id="flatten-函数"><a href="#flatten-函数" class="headerlink" title="flatten() 函数"></a><code>flatten()</code> 函数</h2><ul>
<li><code>flatten()</code> 主要对数组进行降维，返回一维数组</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/qq1483661204/article/details/70543952" target="_blank" rel="noopener">https://blog.csdn.net/qq1483661204/article/details/70543952</a></li>
</ul>
]]></content>
      <categories>
        <category>MLDL</category>
      </categories>
      <tags>
        <tag>MLDL</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch(2)</title>
    <url>/2020/01/04/MLDL/pytorch(2)/</url>
    <content><![CDATA[<h1 id="pytorch-二"><a href="#pytorch-二" class="headerlink" title="pytorch (二)"></a>pytorch (二)</h1><h2 id="1-Variable-Tensor-numpy-之间的转换"><a href="#1-Variable-Tensor-numpy-之间的转换" class="headerlink" title="1. Variable Tensor numpy 之间的转换"></a>1. <code>Variable</code> <code>Tensor</code> <code>numpy</code> 之间的转换</h2><p><strong>Variable 已经被 depreciate 了！！！</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># numpy --&gt; tensor</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tensor_variable = torch.from_numpy(numpy_variable)</span><br><span class="line"></span><br><span class="line"><span class="comment"># tensor --&gt; numpy</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numpy_variable = tensor_variable.numpy()</span><br><span class="line"></span><br><span class="line"><span class="comment"># numpy -- &gt; Tensor --&gt; Variavle</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v = Variable(torch.from_numpy(numpy_variable))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Variable --&gt; numpy</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>numpy_variable = v.data.numpy()</span><br></pre></td></tr></table></figure>

<h2 id="2-tensor-new"><a href="#2-tensor-new" class="headerlink" title="2. tensor.new()"></a>2. <code>tensor.new()</code></h2><p><em><a href="https://pytorch.org/docs/0.3.1/tensors.html?highlight=new#torch.Tensor.new" target="_blank" rel="noopener">source</a></em></p>
<p><code>new(*args, **kwargs)</code></p>
<p>Constructs a new tensor of the same data type as self tensor.</p>
<blockquote>
<p>For CUDA tensors, this method will create new tensor on the same device as this tensor.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>input = (input.data.new([word2ix[w]])).view(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h_0 = input.data.new(<span class="number">2</span>, batch_size, self.hidden_dim).fill_(<span class="number">0</span>).float()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c_0 = input.data.new(<span class="number">2</span>, batch_size, self.hidden_dim).fill_(<span class="number">0</span>).float()</span><br></pre></td></tr></table></figure>

<h2 id="3-cuda-上-tensor-的定义"><a href="#3-cuda-上-tensor-的定义" class="headerlink" title="3. cuda 上 tensor 的定义"></a>3. <code>cuda</code> 上 <code>tensor</code> 的定义</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = torch.one(<span class="number">1000</span>, <span class="number">1000</span>, <span class="number">3</span>).cuda()     <span class="comment"># 在 cpu 上定义，将数据转移到 cuda 上</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.zeros().cuda()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在某一GPU设备上定义</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cuda1 = torch.deivce(<span class="string">'cuda:1'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = torch.randn((<span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>), device=cuda1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接在 GPU上定义数据，减少cpu的损耗</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.cuda.FloatTensor(batch_size, self.hidden_dim, self.height, self.width).fill_(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MLDL</category>
      </categories>
      <tags>
        <tag>MLDL</tag>
      </tags>
  </entry>
  <entry>
    <title>torchnet</title>
    <url>/2020/01/02/MLDL/torchnet/</url>
    <content><![CDATA[<h1 id="torchnet"><a href="#torchnet" class="headerlink" title="torchnet"></a>torchnet</h1><h2 id="1-torchnet-dataset"><a href="#1-torchnet-dataset" class="headerlink" title="1. torchnet.dataset"></a>1. <code>torchnet.dataset</code></h2><h2 id="2-torchnet-engine"><a href="#2-torchnet-engine" class="headerlink" title="2. torchnet.engine"></a>2. <code>torchnet.engine</code></h2><h2 id="3-torchnet-meter"><a href="#3-torchnet-meter" class="headerlink" title="3. torchnet.meter"></a>3. <code>torchnet.meter</code></h2><h2 id="4-torchnet-utils"><a href="#4-torchnet-utils" class="headerlink" title="4. torchnet.utils"></a>4. <code>torchnet.utils</code></h2>]]></content>
      <categories>
        <category>MLDL</category>
      </categories>
      <tags>
        <tag>MLDL</tag>
      </tags>
  </entry>
  <entry>
    <title>torchtext</title>
    <url>/2019/11/24/MLDL/torchtext/</url>
    <content><![CDATA[<h1 id="torchtext"><a href="#torchtext" class="headerlink" title="torchtext"></a>torchtext</h1>]]></content>
      <categories>
        <category>MLDL</category>
      </categories>
      <tags>
        <tag>MLDL</tag>
      </tags>
  </entry>
  <entry>
    <title>tqdm</title>
    <url>/2020/01/02/MLDL/tqdm/</url>
    <content><![CDATA[<h1 id="tqdm"><a href="#tqdm" class="headerlink" title="tqdm"></a>tqdm</h1><p>tqdm 是快速，可扩展的 python 进度条，用户只需要封装任意的迭代器 <code>tqdm(iterator)</code></p>
<h2 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> tqdm(range(<span class="number">100</span>)):</span><br><span class="line">    time.sleep(<span class="number">0.01</span>)</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/qq_33472765/article/details/82940843" target="_blank" rel="noopener">csdn</a></li>
</ul>
]]></content>
      <categories>
        <category>MLDL</category>
      </categories>
      <tags>
        <tag>MLDL</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorflow</title>
    <url>/2019/11/27/MLDL/tensorflow/</url>
    <content><![CDATA[<h1 id="Tensorflow"><a href="#Tensorflow" class="headerlink" title="Tensorflow"></a>Tensorflow</h1><h2 id="1-Tensorflow-模型文件"><a href="#1-Tensorflow-模型文件" class="headerlink" title="1. Tensorflow 模型文件"></a>1. Tensorflow 模型文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|--checkpoint_dir</span><br><span class="line">|    |--checkpoint                  # 文本文件，记录最新的checkpoint文件及其它checkpoint文件的列表</span><br><span class="line">|    |--MyModel.meta                # 保存图结构，meta文件是pb文件，包含变量、op、集合等</span><br><span class="line">|    |--MyModel.data-00000-of-00001 # 二进制文件，保存了所有的 weights、biases、gradients等变量</span><br><span class="line">|    |--MyModel.index               # 二进制文件和上述文件的作用相同</span><br></pre></td></tr></table></figure>

<h2 id="2-保存-tensorflow-模型"><a href="#2-保存-tensorflow-模型" class="headerlink" title="2. 保存 tensorflow 模型"></a>2. 保存 tensorflow 模型</h2><p>使用 <code>tf.train.Saver</code> 保存模型，在保存变量时需要传入 session，例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">w1 = tf.Variable(tf.random_normal(shape=[<span class="number">2</span>]), name=<span class="string">'w1'</span>)</span><br><span class="line">w2 = tf.Variable(tf.random_normal(shape=[<span class="number">5</span>]), name=<span class="string">'w2'</span>)</span><br><span class="line"></span><br><span class="line">saver = tf.train.Saver()</span><br><span class="line">saver = tf.train.Saver([w1, w2])    <span class="comment"># 只保存一部分数据</span></span><br><span class="line"></span><br><span class="line">sess = tf.Session()</span><br><span class="line">sess.run(tf.global_variables_initializer())</span><br><span class="line"></span><br><span class="line">saver.save(sess, <span class="string">'./checkpoint_dir/MyModel'</span>)</span><br><span class="line">saver.save(sess, <span class="string">'./checkpoint_dir/MyModel'</span>,global_step=<span class="number">1000</span>)   <span class="comment"># 在 1000 次迭代后保存模型</span></span><br><span class="line">saver.save(sess, <span class="string">'./checkpoint_dir/MyModel'</span>,global_step=step,write_meta_graph=<span class="literal">False</span>)    <span class="comment"># 只保存模型数据，不保存计算图</span></span><br></pre></td></tr></table></figure>

<h2 id="3-已保存模型的加载"><a href="#3-已保存模型的加载" class="headerlink" title="3. 已保存模型的加载"></a>3. 已保存模型的加载</h2><h3 id="3-1-加载计算图"><a href="#3-1-加载计算图" class="headerlink" title="3.1 加载计算图"></a>3.1 加载计算图</h3><p><code>saver=tf.train.import_meta_graph(&#39;./checkpoint_dir/MyModel-1000.meta&#39;)</code></p>
<h3 id="3-2-加载模型数据"><a href="#3-2-加载模型数据" class="headerlink" title="3.2 加载模型数据"></a>3.2 加载模型数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    saver = tf.train.import_meta_graph(<span class="string">'./checkpoint_dir/MyModel-1000.meta'</span>)</span><br><span class="line">    saver.restore(sess,tf.train.latest_checkpoint(<span class="string">'./checkpoint_dir'</span>))</span><br><span class="line">    print(sess.run(<span class="string">'w1:0'</span>))         <span class="comment"># 打印出加载进图的 w1 数据</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/huachao1001/article/details/78501928" target="_blank" rel="noopener">https://blog.csdn.net/huachao1001/article/details/78501928</a></li>
</ul>
]]></content>
      <categories>
        <category>MLDL</category>
      </categories>
      <tags>
        <tag>MLDL</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch</title>
    <url>/2020/01/04/MLDL/pytorch/</url>
    <content><![CDATA[<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

<h1 id="PyTorch"><a href="#PyTorch" class="headerlink" title="PyTorch"></a>PyTorch</h1><p><em>参考：《深度学习入门之PyTorch》</em></p>
<h2 id="0-基本数据类型"><a href="#0-基本数据类型" class="headerlink" title="0. 基本数据类型"></a>0. 基本数据类型</h2><h3 id="0-1-数据类型"><a href="#0-1-数据类型" class="headerlink" title="0.1 数据类型"></a>0.1 数据类型</h3><p><code>torch.Tensor</code> 默认是 <code>torch.FloatTensor</code></p>
<table>
<thead>
<tr>
<th>Data tyoe</th>
<th>CPU tensor</th>
<th>GPU tensor</th>
</tr>
</thead>
<tbody><tr>
<td>32-bit floating point</td>
<td>torch.FloatTensor</td>
<td>torch.cuda.FloatTensor</td>
</tr>
<tr>
<td>64-bit floating point</td>
<td>torch.DoubleTensor</td>
<td>torch.cuda.DoubleTensor</td>
</tr>
<tr>
<td>16-bit floating point</td>
<td>N/A</td>
<td>torch.cuda.HalfTensor</td>
</tr>
<tr>
<td>8-bit integer (unsigned)</td>
<td>torch.ByteTensor</td>
<td>torch.cuda.ByteTensor</td>
</tr>
<tr>
<td>8-bit integer (signed)</td>
<td>torch.CharTensor</td>
<td>torch.cuda.CharTensor</td>
</tr>
<tr>
<td>16-bit integer (signed)</td>
<td>torch.ShortTensor</td>
<td>torch.cuda.ShortTensor</td>
</tr>
<tr>
<td>32-bit integer (signed)</td>
<td>torch.IntTensor</td>
<td>torch.cuda.IntTensor</td>
</tr>
<tr>
<td>64-bit integer (signed)</td>
<td>torch.LongTensor</td>
<td>torch.cuda.LongTensor</td>
</tr>
</tbody></table>
<h3 id="0-2-对-torch-Tensor-的操作方法"><a href="#0-2-对-torch-Tensor-的操作方法" class="headerlink" title="0.2 对 torch.Tensor 的操作方法"></a>0.2 对 <code>torch.Tensor</code> 的操作方法</h3><ul>
<li><code>tensor</code>可以由python中的 <code>list</code> 或序列创建</li>
<li>也可以用python中的切片与索引来修改 <code>tensor</code> 中的内容</li>
<li>会改变 <code>tensor</code> 的函数操作会带有下划线表示，例如：<code>abs_()</code>等</li>
</ul>
<p><code>torch.max()</code> 函数用于选出 tensor 中的最大值，用法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">a = torch.randn(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">torch.max(a)    <span class="comment"># 返回 a 中最大的元素</span></span><br><span class="line">torch.max(a)[<span class="number">1</span>] <span class="comment"># 返回 a 中最大的元素的索引</span></span><br><span class="line"></span><br><span class="line">torch.max(a, <span class="number">0</span>) <span class="comment"># 返回 a 中每一列最大的元素</span></span><br><span class="line">torch.max(a, <span class="number">0</span>)[<span class="number">1</span>] <span class="comment"># 返回 a 中每一列最大的元素的索引 index</span></span><br><span class="line"></span><br><span class="line">torch.max(a, <span class="number">1</span>) <span class="comment"># 返回 a 中每一行最大的元素</span></span><br><span class="line">torch.max(a, <span class="number">1</span>)[<span class="number">1</span>] <span class="comment"># 返回 a 中每一行最大的元素的索引 index</span></span><br></pre></td></tr></table></figure>

<h3 id="0-3-变换数据维度"><a href="#0-3-变换数据维度" class="headerlink" title="0.3 变换数据维度"></a>0.3 变换数据维度</h3><p>这里涉及到的总共有 3 种方法：</p>
<p><em>参考：<a href="https://zhuanlan.zhihu.com/p/76583143" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/76583143</a></em></p>
<ul>
<li><code>Tensor.permute(a, b, c...)</code> 可以直接对高纬度矩阵进行转置操作</li>
<li><code>torch.transpose()</code> 与 <code>permute()</code>作用相同，但只能操作两个维度</li>
<li><code>Tensor.view()</code>; <code>view()</code> 仅能作用在连续的内存中，即将连续的内存变换成所需要的维度，如果在调用了 <code>transpose()</code> 或 <code>permute()</code> 则可导致内存不连续，需要使用 <code>contiguous()</code>返回一个连续的内存拷贝；</li>
<li><code>torch.reshape()</code> <em>version &gt;=0.4</em>, <code>== tensor.contiguous().view()</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a=np.array([[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]])</span><br><span class="line">unpermuted=torch.tensor(a)</span><br><span class="line">print(unpermuted.size())              <span class="comment">#  ——&gt;  torch.Size([1, 2, 3])</span></span><br><span class="line"></span><br><span class="line">permuted=unpermuted.permute(<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">print(permuted.size())                <span class="comment">#  ——&gt;  torch.Size([3, 1, 2])</span></span><br><span class="line">print(permuted.is_contiguous())       <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line">view_test = unpermuted.view(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">print(view_test.size())               <span class="comment">#  ——&gt;  torch.Size([1, 3, 2])</span></span><br><span class="line"></span><br><span class="line">view_test = view_test.view(<span class="number">-1</span>, <span class="number">2</span>)     <span class="comment">#  --&gt;  使用 -1 进行自动推导，包含两个维度</span></span><br><span class="line">view_test = view_test.view(<span class="number">-1</span>)        <span class="comment">#  --&gt;  只包含一个维度</span></span><br></pre></td></tr></table></figure>

<h3 id="0-4-数据拼接"><a href="#0-4-数据拼接" class="headerlink" title="0.4 数据拼接"></a>0.4 数据拼接</h3><ul>
<li><code>torch.cat(tensors, dim=0, out=None) → Tensor</code>，在指定维度上进行数据的拼接，如当<code>dim=0</code>时，在第0维度进行扩展</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = torch.randn(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">tensor([[ <span class="number">0.6580</span>, <span class="number">-1.0969</span>, <span class="number">-0.4614</span>],</span><br><span class="line">        [<span class="number">-0.1034</span>, <span class="number">-0.5790</span>,  <span class="number">0.1497</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.cat((x, x, x), <span class="number">0</span>)</span><br><span class="line">tensor([[ <span class="number">0.6580</span>, <span class="number">-1.0969</span>, <span class="number">-0.4614</span>],</span><br><span class="line">        [<span class="number">-0.1034</span>, <span class="number">-0.5790</span>,  <span class="number">0.1497</span>],</span><br><span class="line">        [ <span class="number">0.6580</span>, <span class="number">-1.0969</span>, <span class="number">-0.4614</span>],</span><br><span class="line">        [<span class="number">-0.1034</span>, <span class="number">-0.5790</span>,  <span class="number">0.1497</span>],</span><br><span class="line">        [ <span class="number">0.6580</span>, <span class="number">-1.0969</span>, <span class="number">-0.4614</span>],</span><br><span class="line">        [<span class="number">-0.1034</span>, <span class="number">-0.5790</span>,  <span class="number">0.1497</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.cat((x, x, x), <span class="number">1</span>)</span><br><span class="line">tensor([[ <span class="number">0.6580</span>, <span class="number">-1.0969</span>, <span class="number">-0.4614</span>,  <span class="number">0.6580</span>, <span class="number">-1.0969</span>, <span class="number">-0.4614</span>,  <span class="number">0.6580</span>,</span><br><span class="line">         <span class="number">-1.0969</span>, <span class="number">-0.4614</span>],</span><br><span class="line">        [<span class="number">-0.1034</span>, <span class="number">-0.5790</span>,  <span class="number">0.1497</span>, <span class="number">-0.1034</span>, <span class="number">-0.5790</span>,  <span class="number">0.1497</span>, <span class="number">-0.1034</span>,</span><br><span class="line">         <span class="number">-0.5790</span>,  <span class="number">0.1497</span>]])</span><br></pre></td></tr></table></figure>

<h3 id="0-5-数据压栈"><a href="#0-5-数据压栈" class="headerlink" title="0.5 数据压栈"></a>0.5 数据压栈</h3><ul>
<li><code>torch.stack(tensors, dim=0, out=None) → Tensor</code></li>
</ul>
<p><code>torch.stack()</code> 要求不同的 <code>tensor</code> 之间是相同的维度，它的作用与转置的作用类似，不同的是 <code>torch.stack()</code> 作用于不同的 <code>tensor</code>，通过指定 <code>dim</code> 去除相应维度的数据进行组合成新的维度，也就是 <code>stack</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.IntTensor([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line">b = torch.IntTensor([[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">d0 = torch.stack([a, b], dim=<span class="number">0</span>)</span><br><span class="line">d1 = torch.stack([a, b], dim=<span class="number">1</span>)</span><br><span class="line">d2 = torch.stack([a, b], dim=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="0-6-数据压缩"><a href="#0-6-数据压缩" class="headerlink" title="0.6 数据压缩"></a>0.6 数据压缩</h3><ul>
<li><code>tensor.squeeze()</code></li>
<li><code>tensor.unsqueeze()</code></li>
</ul>
<p>压缩的维度为元素个数为 1 的维度，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.randn(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">a.size()                <span class="comment"># [2, 1]</span></span><br><span class="line">a.squeeze().size()      <span class="comment"># [2]</span></span><br></pre></td></tr></table></figure>

<h3 id="0-7-torch-上的一些数学运算：-torch-bmm-torch-mm-torch-matmul-torch-mul"><a href="#0-7-torch-上的一些数学运算：-torch-bmm-torch-mm-torch-matmul-torch-mul" class="headerlink" title="0.7 torch 上的一些数学运算： torch.bmm(),torch.mm(),torch.matmul(),torch.mul()"></a>0.7 <code>torch</code> 上的一些数学运算： <code>torch.bmm(),torch.mm(),torch.matmul(),torch.mul()</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 矩阵之间的相乘，叉乘</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.mm(mat1, mat2, out=<span class="literal">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.matmul(mat1, mat2, out=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 矩阵的 batch 叉乘运算</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>batch1 = torch.randn(<span class="number">10</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>batch2 = torch.randn(<span class="number">10</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = torch.bmm(batch1, batch2)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res.size()</span><br><span class="line">torch.Size([<span class="number">10</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line"><span class="comment"># 矩阵各元素之间的相乘，是对应位之间的相乘</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.mul(mat1, mat2)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>torch.sum(input, dim, out=None)</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">x = torch.randn(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(x)</span><br><span class="line"></span><br><span class="line">print(x.sum(<span class="number">0</span>)) <span class="comment">#按列求和</span></span><br><span class="line">print(x.sum(<span class="number">1</span>)) <span class="comment">#按行求和</span></span><br><span class="line">print(torch.sum(x))   <span class="comment">#按列求和</span></span><br><span class="line">print(torch.sum(x, <span class="number">0</span>))<span class="comment">#按列求和</span></span><br><span class="line">print(torch.sum(x, <span class="number">1</span>))<span class="comment">#按行求和</span></span><br></pre></td></tr></table></figure>

<h2 id="1-Variable-变量"><a href="#1-Variable-变量" class="headerlink" title="1. Variable(变量)"></a>1. Variable(变量)</h2><blockquote>
<p>Variable 是神经网络计算图里的概念，提供了自动求导的功能。Variable 和 Tensor 本质上没有区别，不过 Variable 会被放入一个计算图中，然后进行前向传播、反向传播、自动求导。</p>
</blockquote>
<p>位置： <code>torch.autograd.Variable</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = Variable(torch.Tensor([<span class="number">1</span>]))</span><br><span class="line">w = Variable(torch.Tensor([<span class="number">2</span>]))</span><br><span class="line">b = Variable(torch.Tensor([<span class="number">3</span>]))</span><br><span class="line"></span><br><span class="line">y = w * x + b</span><br><span class="line"></span><br><span class="line">y.backward()</span><br><span class="line"></span><br><span class="line">pritn(x.grad)</span><br></pre></td></tr></table></figure>

<h3 id="1-1-Parameters"><a href="#1-1-Parameters" class="headerlink" title="1.1 Parameters"></a>1.1 Parameters</h3><p><code>class torch.nn.Parameter()</code></p>
<p><code>Variable</code> 的一种，常被用于模块参数 <code>module parameter</code></p>
<p><code>Variable</code> 已经被废除了。</p>
<p><code>parameter</code> 是类型转换函数，将不可训练的类型<code>Tensor</code>转换成可训练的类型<code>parameter</code>，并将这个<code>parameter</code>绑定到这个 <code>module</code> 里面。（<code>net.parameter()</code> 中就有这个绑定的 <code>parameter</code>，参数优化的时候是可以进行优化的）</p>
<p><code>Variable</code> 与 <code>Parameter</code>  的不同：</p>
<ul>
<li><code>Parameters</code> 是 <code>Variable</code> 的子类。 当把 <code>Parameters</code> 赋值给 <code>Modules</code>的时候，会被自动加到 <code>Module</code> 的参数列表中（会出现在 <code>parameters()</code> 迭代器中）。将 <code>Variable</code> 赋值给 <code>Module</code> 属性则不会有这样的影响。</li>
<li><code>Parameter</code> 不能被 <code>volatile</code>，且默认 <code>requires_grad=True</code>，<code>Variable</code>默认<code>requires_grad=False</code></li>
</ul>
<h2 id="2-Dataset-数据集"><a href="#2-Dataset-数据集" class="headerlink" title="2. Dataset(数据集)"></a>2. Dataset(数据集)</h2><h2 id="3-激励函数"><a href="#3-激励函数" class="headerlink" title="3. 激励函数"></a>3. 激励函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line">x = torch.linspace(<span class="number">-5</span>, <span class="number">5</span>, <span class="number">200</span>)</span><br><span class="line">y_relu = torch.relu(x)</span><br><span class="line">print(y_relu)</span><br><span class="line">y_sigmoid = torch.sigmoid(x)</span><br><span class="line">print(y_sigmoid)</span><br><span class="line">y_tanh = torch.tanh(x)</span><br><span class="line">print(y_tanh)</span><br><span class="line">y_softplus = F.softplus(x)</span><br><span class="line">print(y_softplus)</span><br></pre></td></tr></table></figure>

<h2 id="4-Commonly-used-function"><a href="#4-Commonly-used-function" class="headerlink" title="4. Commonly used function"></a>4. Commonly used function</h2><ul>
<li><code>torch.view()</code> 类似于 <code>numpy.reshape()</code> 但不同的是，<code>view()</code> 函数并不进行变量内存的复制，而只是在原来的内存区域进行操作。</li>
<li><code>torch.Tensor()</code></li>
<li><code>torch.LongTensor()</code></li>
<li><code>torch.optim.SGD()</code></li>
</ul>
<h2 id="5-Containers（容器）-torch-nn-Module"><a href="#5-Containers（容器）-torch-nn-Module" class="headerlink" title="5. Containers（容器） torch.nn Module"></a>5. Containers（容器） <code>torch.nn</code> Module</h2><h3 id="5-1-nn-Linear-in-features-out-features-bias-True"><a href="#5-1-nn-Linear-in-features-out-features-bias-True" class="headerlink" title="5.1 nn.Linear(in_features, out_features, bias=True)"></a>5.1 <code>nn.Linear(in_features, out_features, bias=True)</code></h3><p>$$y=xA^{T}+b$$</p>
<h4 id="5-1-1-Parameters"><a href="#5-1-1-Parameters" class="headerlink" title="5.1.1 Parameters"></a>5.1.1 Parameters</h4><ul>
<li><code>in_features</code> 每个输入样本的大小</li>
<li><code>out_features</code> 每个输出样本的大小</li>
</ul>
<h4 id="5-1-2-Shape"><a href="#5-1-2-Shape" class="headerlink" title="5.1.2 Shape"></a>5.1.2 Shape</h4><ul>
<li><p><code>input:</code><br>$$(N, *, H_{in}), 其中H_{in} = in_features$$</p>
</li>
<li><p><code>output:</code><br>$$(N, *, H_{out}), 其中H_{out} = out_features$$</p>
</li>
</ul>
<h4 id="5-1-3-Example"><a href="#5-1-3-Example" class="headerlink" title="5.1.3 Example"></a>5.1.3 Example</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = nn.Linear(<span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>input = torch.randn(<span class="number">128</span>, <span class="number">20</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>output = m(input)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(output.size())</span><br><span class="line">torch.Size([<span class="number">128</span>, <span class="number">30</span>])</span><br></pre></td></tr></table></figure>

<h3 id="5-2-nn-Dropout-p-0-5-inplace-False"><a href="#5-2-nn-Dropout-p-0-5-inplace-False" class="headerlink" title="5.2 nn.Dropout(p=0.5, inplace=False)"></a>5.2 <code>nn.Dropout(p=0.5, inplace=False)</code></h3><ul>
<li><code>p</code> 将元素置0的概率</li>
<li><code>inplace</code> 若设置为 True，会在原地进行操作</li>
</ul>
<h3 id="5-3-nn-ReLU-inplace-False"><a href="#5-3-nn-ReLU-inplace-False" class="headerlink" title="5.3 nn.ReLU(inplace=False)"></a>5.3 <code>nn.ReLU(inplace=False)</code></h3><p>$$<br>y=\begin{cases}<br>0, \quad x\leq0 \\<br>x, \quad x&gt;0<br>\end{cases}<br>$$</p>
<h3 id="5-4-nn-Embedding-num-embeddings-embedding-dim-padding-idx-None-max-norm-None-norm-type-2-scale-grad-by-freq-False-sparse-False"><a href="#5-4-nn-Embedding-num-embeddings-embedding-dim-padding-idx-None-max-norm-None-norm-type-2-scale-grad-by-freq-False-sparse-False" class="headerlink" title="5.4 nn.Embedding(num_embeddings, embedding_dim, padding_idx=None, max_norm=None, norm_type=2, scale_grad_by_freq=False, sparse=False)"></a>5.4 <code>nn.Embedding(num_embeddings, embedding_dim, padding_idx=None, max_norm=None, norm_type=2, scale_grad_by_freq=False, sparse=False)</code></h3><p>保存了固定字典和大小的简单查找表，该模块保存，这里只是初始化的一些向量，后续还需要进行学习和修改</p>
<ul>
<li><code>num_embeddings</code> 嵌入字典的大小</li>
<li><code>embeddings_dim</code> 每个嵌入向量的大小</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"></span><br><span class="line">word_to_idx = &#123;<span class="string">'hello'</span>: <span class="number">0</span> ,<span class="string">'world'</span>: <span class="number">1</span>&#125;</span><br><span class="line">embeds = nn.Embedding(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">hello_idx = torch.LongTensor([word_to_idx[<span class="string">'hello'</span>]])</span><br><span class="line">hello_variable = Variable(hello_idx)</span><br><span class="line">hello_embed = embeds(hello_variable)</span><br><span class="line">print(hello_embed)</span><br><span class="line"></span><br><span class="line">embeds.weight.data = torch.ones(<span class="number">2</span>, <span class="number">5</span>)   <span class="comment"># embeddings 的 weight 可以设置 </span></span><br><span class="line">print(embeds.weight)</span><br></pre></td></tr></table></figure>

<h3 id="5-5-nn-Sequential-args"><a href="#5-5-nn-Sequential-args" class="headerlink" title="5.5 nn.Sequential(*args)"></a>5.5 <code>nn.Sequential(*args)</code></h3><p>一个时序容器。 <code>Modules</code> 会以他们传入的顺序被添加到容器中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Example of using Sequential</span></span><br><span class="line"></span><br><span class="line">model = nn.Sequential(</span><br><span class="line">          nn.Conv2d(<span class="number">1</span>,<span class="number">20</span>,<span class="number">5</span>),</span><br><span class="line">          nn.ReLU(),</span><br><span class="line">          nn.Conv2d(<span class="number">20</span>,<span class="number">64</span>,<span class="number">5</span>),</span><br><span class="line">          nn.ReLU()</span><br><span class="line">        )</span><br><span class="line"><span class="comment"># Example of using Sequential with OrderedDict</span></span><br><span class="line">model = nn.Sequential(OrderedDict([</span><br><span class="line">          (<span class="string">'conv1'</span>, nn.Conv2d(<span class="number">1</span>,<span class="number">20</span>,<span class="number">5</span>)),</span><br><span class="line">          (<span class="string">'relu1'</span>, nn.ReLU()),</span><br><span class="line">          (<span class="string">'conv2'</span>, nn.Conv2d(<span class="number">20</span>,<span class="number">64</span>,<span class="number">5</span>)),</span><br><span class="line">          (<span class="string">'relu2'</span>, nn.ReLU())</span><br><span class="line">        ]))</span><br></pre></td></tr></table></figure>

<h3 id="5-6-nn-CrossEntropyLoss"><a href="#5-6-nn-CrossEntropyLoss" class="headerlink" title="5.6 nn.CrossEntropyLoss"></a>5.6 <code>nn.CrossEntropyLoss</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.CrossEntropyLoss(weight=<span class="literal">None</span>, size_average=<span class="literal">None</span>, ignore_index=<span class="number">-100</span>, reduce=<span class="literal">None</span>, reduction=<span class="string">'mean'</span>)</span><br></pre></td></tr></table></figure>

<p>该函数相当于组合了 <code>nn.LogSoftmax()</code> 和 <code>nn.NLLLoss()</code></p>
<p>$$loss(x,class) = -log{\frac{exp(x[class])}{\sum_{j}exp(x[j])}}$$</p>
<p>等于（当 <code>weight</code> 参数非零时）</p>
<p>$$loss(x,class) = weight[class]\left(-x[class] + log(\sum_{j}exp\left(x[j]\right)\right)$$</p>
<p>通过以上公式求交叉熵，应用于多分类问题中的<code>loss function</code></p>
<h4 id="5-6-1-Parameters"><a href="#5-6-1-Parameters" class="headerlink" title="5.6.1 Parameters"></a>5.6.1 Parameters</h4><ul>
<li><code>weight</code>，结合上式，赋值给每个class 的 weight</li>
<li><code>reduction</code> 默认为 <code>mean</code>，可以为 <code>none | mean | sum</code>，是对计算后的 output 值的整合</li>
</ul>
<h4 id="5-6-2-Shape"><a href="#5-6-2-Shape" class="headerlink" title="5.6.2 Shape"></a>5.6.2 Shape</h4><ul>
<li>输入1：<code>Input:(N,C)</code> N 代表batch个数，C 代表 class 的个数；</li>
<li>输入2：<code>Target:(N)</code> 代表对应的类别的序号</li>
</ul>
<h4 id="5-6-3-Example"><a href="#5-6-3-Example" class="headerlink" title="5.6.3 Example"></a>5.6.3 Example</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>loss = nn.CrossEntropyLoss(reduction=<span class="string">'none'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>input = torch.randn(<span class="number">3</span>, <span class="number">5</span>, requires_grad=<span class="literal">True</span>)  <span class="comment"># 输入 batch:3,class numbers: 5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>target = torch.empty(<span class="number">3</span>, dtype=torch.long).random_(<span class="number">5</span>) <span class="comment"># 输入 target:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>output = loss(input, target)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>output.backward()</span><br></pre></td></tr></table></figure>

<h3 id="5-7-nn-RNN"><a href="#5-7-nn-RNN" class="headerlink" title="5.7 nn.RNN()"></a>5.7 <code>nn.RNN()</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.RNN(*args, **kwargs)</span><br></pre></td></tr></table></figure>

<p>可以构造多层的RNN，每一层的计算函数为：</p>
<p>$$h_{t} = tanh\left( W_{ih}x_{t} + b_{ih} + W_{hh}h_{(t-1)} + b_{hh}\right)$$</p>
<h4 id="5-7-1-Parameters"><a href="#5-7-1-Parameters" class="headerlink" title="5.7.1 Parameters"></a>5.7.1 Parameters</h4><ul>
<li><code>input_size:</code> input 的 feature 数量</li>
<li><code>hidden_size:</code> hidden layer 的feature 数量</li>
<li><code>num_layers:</code> 循环RNN的数量，可以组成 stacked RNN</li>
<li><code>nonlinearity:</code> 非线性函数，可以为 <code>tanh</code> 或 <code>relu</code>，默认为 <code>tanh</code></li>
<li><code>bidirectional:</code> 设置为 <code>True</code>，则为 bidirectional RNN</li>
</ul>
<h4 id="5-7-2-Shape"><a href="#5-7-2-Shape" class="headerlink" title="5.7.2 Shape"></a>5.7.2 Shape</h4><ul>
<li><p><code>input:</code> shape(seq_len, batch, input_size)，多少个sequence，每个sequence带有多少个batch，每个batch里的 input_size</p>
</li>
<li><p><code>h_0:</code>  shape(num_layers*num_directions, batch, hidden_size)，这里设置 hidden layer 的参数</p>
</li>
<li><p><code>output</code> shape(seq_len, batch, num_directions * hidden_size)，这里的 output 是最后一层 layer 的 output</p>
</li>
</ul>
<h4 id="5-7-3-Example"><a href="#5-7-3-Example" class="headerlink" title="5.7.3 Example"></a>5.7.3 Example</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>rnn = nn.RNN(<span class="number">10</span>, <span class="number">20</span>, <span class="number">2</span>)     <span class="comment"># input_size: 10; hidden_size: 20; num_layers: 2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>input = torch.randn(<span class="number">5</span>, <span class="number">3</span>, <span class="number">10</span>) <span class="comment"># seq_len: 5; batch: 3; input_size: 10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h0 = torch.randn(<span class="number">2</span>, <span class="number">3</span>, <span class="number">20</span>) <span class="comment"># num_layers * num_directions: 2; batch: 3; hidden_size: 20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>output, hn = rnn(input, h0)</span><br></pre></td></tr></table></figure>

<p><strong>Notation:</strong></p>
<ol>
<li><code>RNN</code> 的 output：是最后一层（the last hidden_layer）的每个 <code>batch</code> 每个 <code>time_step/seq_len</code> 的output</li>
<li><code>RNN</code> 的 h_n 是每一个隐藏层（hidden_layer）的每个 <code>batch</code> 的 output</li>
</ol>
<h3 id="5-8-nn-LSTM"><a href="#5-8-nn-LSTM" class="headerlink" title="5.8 nn.LSTM()"></a>5.8 <code>nn.LSTM()</code></h3><p>$$<br>\begin{aligned}<br>i_{t} =&amp; \ \sigma\left(W_{ii}x_{t} + b_{ii} + W_{hi}h_{(t-1)} + b_{hi}\right) \<br>f_{t} =&amp; \ \sigma\left(W_{if}x_{t} + b_{if} + W_{hf}h_{(t-1)} + b_{hf}\right) \<br>g_{t} =&amp; \ tanh(W_{ig}x_{t} + b_{ig} + W_{hg}h_{(t-1)} + b_{hg}) \<br>o_{t} =&amp; \ \sigma(W_{io}x_{t} + b_{io} + W_{ho}h_{(t-1)} + b_{ho}) \<br>c_{t} =&amp; \ f_{t} * c_{(t-1)} + i_{t} * g_{t} \<br>h_{t} =&amp; \ o_{t} * tanh(c_{t})<br>\end{aligned}<br>$$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.LSTM(*args, **kwargs)</span><br></pre></td></tr></table></figure>

<h4 id="5-8-1-Parameters"><a href="#5-8-1-Parameters" class="headerlink" title="5.8.1 Parameters"></a>5.8.1 Parameters</h4><ul>
<li><code>input_size:</code> input 的 feature 数量</li>
<li><code>hidden_size:</code> hidden layer 的feature 数量</li>
<li><code>num_layers:</code> 循环RNN的数量，可以组成 stacked RNN</li>
<li><code>bidirectional:</code> 设置为 <code>True</code>，则为 bidirectional LSTM</li>
</ul>
<h4 id="5-8-2-Shape"><a href="#5-8-2-Shape" class="headerlink" title="5.8.2 Shape"></a>5.8.2 Shape</h4><ul>
<li><code>input:</code> shape(seq_len, batch, input_size)，多少个sequence，每个sequence带有多少个batch，每个batch里的 input_size</li>
<li><code>h_0:</code>  shape(num_layers*num_directions, batch, hidden_size)，这里设置 hidden layer 的参数</li>
<li><code>c_0:</code> shape(num_layers*num_directions, batch, hidden_size), 初始化的 cell state 每个 batch</li>
</ul>
<h4 id="5-8-3-Example"><a href="#5-8-3-Example" class="headerlink" title="5.8.3 Example"></a>5.8.3 Example</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>rnn = nn.LSTM(<span class="number">10</span>, <span class="number">20</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>input = torch.randn(<span class="number">5</span>, <span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h0 = torch.randn(<span class="number">2</span>, <span class="number">3</span>, <span class="number">20</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c0 = torch.randn(<span class="number">2</span>, <span class="number">3</span>, <span class="number">20</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>output, (hn, cn) = rnn(input, (h0, c0))</span><br></pre></td></tr></table></figure>

<h3 id="5-9-nn-GRU"><a href="#5-9-nn-GRU" class="headerlink" title="5.9 nn.GRU()"></a>5.9 <code>nn.GRU()</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.nn.GRU(*args, **kwargs)</span><br></pre></td></tr></table></figure>

<p>$$<br>\begin{aligned}<br>r_{t} =&amp; \ \sigma(W_{ir}x_{t} + b_{ir} + W_{hr}h_{(t-1)} + b_{hr}) \<br>z_{t} =&amp; \ \sigma(W_{iz}x_{t} + b_{iz} + W_{hz}h_{(t-1)} + b_{hz}) \<br>n_{t} =&amp; \ tanh(W_{in}x_{t} + b_{in} + r_{t}*(W_{hn}h_{(t-1)} + b_{hn})) \<br>h_{t} =&amp; \ (1-z_{t}) * n_{t} + z_{t} * h_{(t-1)}<br>\end{aligned}<br>$$</p>
<h4 id="5-9-1-Parameters"><a href="#5-9-1-Parameters" class="headerlink" title="5.9.1 Parameters"></a>5.9.1 Parameters</h4><ul>
<li><code>input_size:</code> input 的 feature 数量</li>
<li><code>hidden_size:</code> hidden layer 的feature 数量</li>
<li><code>num_layers:</code> 循环RNN的数量，可以组成 stacked RNN</li>
<li><code>bidirectional:</code> 设置为 <code>True</code>，则为 bidirectional LSTM</li>
</ul>
<h4 id="5-9-2-Shape"><a href="#5-9-2-Shape" class="headerlink" title="5.9.2 Shape"></a>5.9.2 Shape</h4><ul>
<li><code>input:</code> shape(seq_len, batch, input_size)，多少个sequence，每个sequence带有多少个batch，每个batch里的 input_size</li>
<li><code>h_0:</code>  shape(num_layers*num_directions, batch, hidden_size)，这里设置 hidden layer 的参数</li>
</ul>
<h4 id="5-9-3-Example"><a href="#5-9-3-Example" class="headerlink" title="5.9.3 Example"></a>5.9.3 Example</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>rnn = nn.GRU(<span class="number">10</span>, <span class="number">20</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>input = torch.randn(<span class="number">5</span>, <span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>h0 = torch.randn(<span class="number">2</span>, <span class="number">3</span>, <span class="number">20</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>output, hn = rnn(input, h0)</span><br></pre></td></tr></table></figure>

<h2 id="6-torch-optim"><a href="#6-torch-optim" class="headerlink" title="6. torch.optim"></a>6. <code>torch.optim</code></h2><p><code>torch.optim</code> 是一个实现了各种优化算法的库。</p>
<h3 id="6-1-如何使用-optimizer"><a href="#6-1-如何使用-optimizer" class="headerlink" title="6.1 如何使用 optimizer"></a>6.1 如何使用 <code>optimizer</code></h3><p>为了使用 <code>torch.optim</code>，你需要构建一个 optimizer 对象，这个对象能够保持当前参数状态并基于计算得到的梯度进行参数更新。</p>
<ul>
<li>构建</li>
</ul>
<p>为了构建一个 <code>optimizer</code>，需要传入一个包含优化参数（必须都是 <code>Variable</code> 对象）的 iterable，并设置 optimizer 的参数选项，如：学习率、权重衰减等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.01</span>, )</span><br></pre></td></tr></table></figure>

<ul>
<li>进行单次优化</li>
</ul>
<p>采用的方法：</p>
<p><code>optimizer.step()</code> 这个方法会更新所有的参数，所有的 optimizer 都实现了这个方法，一旦梯度被 <code>backward()</code> 之类的函数计算好后，就可以调用这个函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单次优化的常用做法</span></span><br><span class="line"><span class="keyword">for</span> input, target <span class="keyword">in</span> dataset:</span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    output = model(input)</span><br><span class="line">    loss = loss_fn(output, target)</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br></pre></td></tr></table></figure>

<h3 id="6-2-常用函数"><a href="#6-2-常用函数" class="headerlink" title="6.2 常用函数"></a>6.2 常用函数</h3><ul>
<li><code>step(closure)</code> 进行单次优化</li>
<li><code>zero_grad()</code> 清空所有被优化过的 Variable 的梯度</li>
</ul>
<h2 id="7-torch-utils"><a href="#7-torch-utils" class="headerlink" title="7. torch.utils"></a>7. <code>torch.utils</code></h2><h3 id="7-1-torch-utils-data-Dataloader"><a href="#7-1-torch-utils-data-Dataloader" class="headerlink" title="7.1 torch.utils.data.Dataloader"></a>7.1 <code>torch.utils.data.Dataloader</code></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DataLoader(dataset, batch_size=<span class="number">1</span>, shuffle=<span class="literal">False</span>, sampler=<span class="literal">None</span>,</span><br><span class="line">           batch_sampler=<span class="literal">None</span>, num_workers=<span class="number">0</span>, collate_fn=<span class="literal">None</span>,</span><br><span class="line">           pin_memory=<span class="literal">False</span>, drop_last=<span class="literal">False</span>, timeout=<span class="number">0</span>,</span><br><span class="line">           worker_init_fn=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>主要的几个参数：</p>
<ul>
<li>dataset: 数据集来源，可以是 <code>map-style</code> or <code>iterable-style</code> dataset.</li>
<li>batch_size: 每个 <code>batch</code> 有多少个 samples</li>
<li>shuffle: 是否在每个 <code>epoch</code> 进行 reshuffle</li>
</ul>
<p>python 迭代器构造在数据集上。</p>
<h2 id="8-模型的保存与加载"><a href="#8-模型的保存与加载" class="headerlink" title="8. 模型的保存与加载"></a>8. 模型的保存与加载</h2><p><em>参考：<a href="https://zhuanlan.zhihu.com/p/38056115" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/38056115</a></em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Approach 1</span></span><br><span class="line"><span class="comment"># 保存整个网络，保存的后缀可以为 .pt/.pth</span></span><br><span class="line">torch.save(net, PATH)</span><br><span class="line"></span><br><span class="line">model_dict = torch.load(PATH)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Approach 2</span></span><br><span class="line"><span class="comment"># 保存网络中的参数，</span></span><br><span class="line">torch.save(net.state_dict(), PATH)</span><br><span class="line">model = TheModelClass(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">model_dict = model.load_state_dict(torch.load(PATH))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Approach 3: Save model to resume training later</span></span><br><span class="line"><span class="comment"># 用于恢复 training 的过程，除了保存 model， 还需要保存 the state of optimizer,epochs,score等。</span></span><br><span class="line">state = &#123;</span><br><span class="line">    <span class="string">'epoch'</span>: epoch,</span><br><span class="line">    <span class="string">'state_dict'</span>: model.state_dict(),</span><br><span class="line">    <span class="string">'optimizer'</span>: optimizer.state_dict(),</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">torch.save(state, filepath)</span><br><span class="line"></span><br><span class="line">model.load_state_dict(state[<span class="string">'state_dict'</span>])</span><br><span class="line">optimizer.load_state_dict(state[<span class="string">'optimizer'</span>])</span><br></pre></td></tr></table></figure>

<p>对于 approach 2 存在的一些缺点：</p>
<blockquote>
<p>However in this case, the serialized data is bound to the specific classes and the exact directory structure used, so it can break in various ways when used in other projects, or after some serious refactors.</p>
</blockquote>
<h2 id="9-参考"><a href="#9-参考" class="headerlink" title="9. 参考"></a>9. 参考</h2><ul>
<li><a href="https://pytorch-cn.readthedocs.io/zh/latest/package_references/torch-optim/" target="_blank" rel="noopener">PyTorch-官方教程</a></li>
<li><a href="https://pytorch.org/docs/stable/torch.html" target="_blank" rel="noopener">pytorch-文档</a>    </li>
</ul>
]]></content>
      <categories>
        <category>MLDL</category>
      </categories>
      <tags>
        <tag>MLDL</tag>
      </tags>
  </entry>
  <entry>
    <title>Huggingface&#39;s transformers</title>
    <url>/2020/01/14/MLDL/transformers%EF%BC%88pytorch-pretrained-bert%EF%BC%89/</url>
    <content><![CDATA[<h1 id="huggingface’s-transformers（pytorch-pretrained-bert）"><a href="#huggingface’s-transformers（pytorch-pretrained-bert）" class="headerlink" title="huggingface’s transformers（pytorch-pretrained-bert）"></a>huggingface’s <code>transformers</code>（<code>pytorch-pretrained-bert</code>）</h1><h2 id="mdoel-的保存与加载"><a href="#mdoel-的保存与加载" class="headerlink" title="mdoel 的保存与加载"></a>mdoel 的保存与加载</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Save a trained model</span></span><br><span class="line">model_to_save = model.module <span class="keyword">if</span> hasattr(model, <span class="string">'module'</span>) <span class="keyword">else</span> model  <span class="comment"># Only save the model it-self</span></span><br><span class="line">output_model_file = os.path.join(args.output_dir, <span class="string">"pytorch_model.bin"</span>)</span><br><span class="line"><span class="keyword">if</span> args.do_train:</span><br><span class="line">    torch.save(model_to_save.state_dict(), output_model_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load tsaved model</span></span><br><span class="line">model_state_dict = torch.load(output_model_file)</span><br><span class="line">model = BertForSequenceClassification.from_pretrained(args.bert_model, state_dict=model_state_dict, num_labels=num_labels)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MLDL</category>
      </categories>
      <tags>
        <tag>MLDL</tag>
      </tags>
  </entry>
  <entry>
    <title>Viterbi 算法</title>
    <url>/2020/01/14/MLDL/viterbi/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Viterbi</code> 算法常用于解决<code>预测问题</code>，如：在<code>HMM</code>、<code>CRF</code>中由已知序列推出得到观测序列；是一种<code>DP</code>算法。</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>维特比算法适用于解决的问题：</p>
<p><img src="/2020/01/14/MLDL/viterbi/viterbi_pro.png" alt="viterbi"></p>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p>维特比算法的主要思想同其他求解图中的最优路径一样，不能单纯的认为某一条子路径一定时全局最优路径的一部分，因此采用<code>动态规划的思想</code>，对于经过的每一个节点都从前到后计算并保留最优路径。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.zhihu.com/question/20136144" target="_blank" rel="noopener">知乎-如何通俗地讲解 viterbi 算法？</a></li>
</ul>
]]></content>
      <categories>
        <category>MLDL</category>
      </categories>
      <tags>
        <tag>MLDL</tag>
      </tags>
  </entry>
  <entry>
    <title>Basic0</title>
    <url>/2019/11/08/Matlab/Basic0/</url>
    <content><![CDATA[<h1 id="Start-here-for-Matlab"><a href="#Start-here-for-Matlab" class="headerlink" title="Start here for Matlab"></a>Start here for Matlab</h1><h2 id="常用命令总结"><a href="#常用命令总结" class="headerlink" title="常用命令总结"></a>常用命令总结</h2><blockquote>
<ul>
<li>clc 清零命令窗口  clear 清零变量窗口  </li>
<li></li>
</ul>
</blockquote>
<h2 id="函数常用命令"><a href="#函数常用命令" class="headerlink" title="函数常用命令"></a>函数常用命令</h2><blockquote>
<ul>
<li>type 可用于查看函数的定义  type(‘sphere’) 或 type sphere   </li>
<li>global 用于定义全局变量  global G  </li>
<li>nargin 获取输入变量个数  nargout 获取输出变量个数  varargin 用于不确定输入变量的输入  </li>
<li>pathtool 用于设置函数搜索路径  addpath  添加新的搜索路径  </li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Matlab</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>微分与积分</title>
    <url>/2019/11/08/Matlab/%E5%BE%AE%E5%88%86%E4%B8%8E%E7%A7%AF%E5%88%86/</url>
    <content><![CDATA[<h1 id="微积分中一些常用的公式与技巧"><a href="#微积分中一些常用的公式与技巧" class="headerlink" title="微积分中一些常用的公式与技巧"></a>微积分中一些常用的公式与技巧</h1><h2 id="含参变量积分的微分公式，这个经常忘，呜"><a href="#含参变量积分的微分公式，这个经常忘，呜" class="headerlink" title="含参变量积分的微分公式，这个经常忘，呜~"></a>含参变量积分的微分公式，这个经常忘，呜<del>~</del></h2><blockquote>
<ul>
<li>[百度知道]<a href="https://zhidao.baidu.com/question/1832163828264520420.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/1832163828264520420.html</a></li>
<li>三大块，这个是个完整的公式</li>
</ul>
</blockquote>
<h2 id="积分符号内取微分计算积分，据听说费曼提到，很少人用"><a href="#积分符号内取微分计算积分，据听说费曼提到，很少人用" class="headerlink" title="积分符号内取微分计算积分，据听说费曼提到，很少人用"></a>积分符号内取微分计算积分，据听说费曼提到，很少人用</h2><blockquote>
<ul>
<li>[知乎]<a href="https://www.zhihu.com/question/24481887" target="_blank" rel="noopener">https://www.zhihu.com/question/24481887</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Matlab</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>README</title>
    <url>/2019/11/08/Matlab/README/</url>
    <content><![CDATA[<h1 id="MATLAB"><a href="#MATLAB" class="headerlink" title="MATLAB"></a>MATLAB</h1><p>Learn how to use matlab</p>
]]></content>
      <categories>
        <category>Matlab</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>环境部署</title>
    <url>/2019/11/26/MLDL/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="深度学习环境的部署"><a href="#深度学习环境的部署" class="headerlink" title="深度学习环境的部署"></a>深度学习环境的部署</h1><h2 id="0-查看GPU环境"><a href="#0-查看GPU环境" class="headerlink" title="0. 查看GPU环境"></a>0. 查看GPU环境</h2><ul>
<li>查看 GPU 型号： <code>lspci | grep -i nvidia</code></li>
<li>查看 GPU 驱动版本： <code>sudo dpkg --list | grep nvidia-*</code></li>
</ul>
<h2 id="1-CUDA-环境的配置"><a href="#1-CUDA-环境的配置" class="headerlink" title="1. CUDA 环境的配置"></a>1. CUDA 环境的配置</h2><p>refer:<br>    1. <a href="https://www.cnblogs.com/yhjoker/p/10972795.html" target="_blank" rel="noopener">https://www.cnblogs.com/yhjoker/p/10972795.html</a><br>    2. <a href="https://blog.csdn.net/wanzhen4330/article/details/81699769#cudnn%E7%9A%84%E5%AE%89%E8%A3%85" target="_blank" rel="noopener">https://blog.csdn.net/wanzhen4330/article/details/81699769#cudnn%E7%9A%84%E5%AE%89%E8%A3%85</a></p>
<ul>
<li>如何更改 <code>cuda</code> 版本</li>
</ul>
<p>先来看下 pytorch 如何找到 cuda（以下过程为顺序进行，满足条件即停止）</p>
<ol>
<li>先查看环境变量 <code>CUDA_HOME</code> 或 <code>CUDA_PATH</code></li>
<li>检查系统固定路径 <code>/usr/local/cuda</code>，寻找该软链接文件</li>
<li><code>which nvcc</code> 查看 <code>nvcc</code> 所在的 cuda 安装目录，并将其作为运行时的 cuda 版本</li>
</ol>
<p>通过以上可以确定更改 <code>cuda</code> 的方法：</p>
<ol>
<li>对于非 <code>root</code> 账户，可以使用环境变量的方法：指定 <code>CUDA_HOME</code> 与 <code>PATH</code></li>
<li>对于 <code>root</code> 账户，可以在 <code>/usr/local/cuda</code> 修改该软链接文件</li>
</ol>
<ul>
<li>如何查看 <code>cuda</code> 及 <code>cudnn</code> 版本</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> torch</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.version.cuda   <span class="comment"># 该命令查看的是编译 pytorch 使用的 cuda 版本，并不一定是运行的时候的版本</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> torch</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> torch.utils</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> torch.utils.cpp_extension</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>torch.utils.cpp_extension.CUDA_HOME <span class="comment"># 此为查看运行时的 cuda 版本的方法</span></span><br></pre></td></tr></table></figure>

<p>或者通过查看 <code>/usr/local/cuda</code> 目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cuda 版本</span></span><br><span class="line">cat /usr/local/cuda/version.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> cudnn 版本</span></span><br><span class="line">cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2</span><br><span class="line">nvcc --version</span><br></pre></td></tr></table></figure>

<h2 id="2-cudnn-的安装"><a href="#2-cudnn-的安装" class="headerlink" title="2. cudnn 的安装"></a>2. cudnn 的安装</h2><p>cudnn 是用于深度神经网络加速的GPU加速库，可以集成到更高级别的机器学习框架中，如 caffe。相比于标准的 cuda，它在一些常用的神经网络操作上进行了性能的优化。</p>
<p>它的安装只需要将 package 下载下来，解压到 CUDA_HOME 中的 <code>include</code>、<code>lib</code>、<code>bin</code> 目录下即可。</p>
<ul>
<li><p><code>cudnn</code> 版本的查看</p>
<p>  <code>cat $CUDA_HOME/include/cudnn.h | grep CUDNN_MAJOR -A 2</code></p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> !/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Install CUDA Toolkit v8.0 and cudnn v6.0 on ubuntu 16.04</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> instructions from https://developer.nvidia.com/cuda-downloads (linux -&gt; x86_64 -&gt; Ubuntu -&gt; 16.04 -&gt; deb (network))</span></span><br><span class="line">CUDA_REPO_PKG="cuda-repo-ubuntu1604_8.0.61-1_amd64.deb"</span><br><span class="line">wget http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64/$&#123;CUDA_REPO_PKG&#125;</span><br><span class="line">sudo dpkg -i $&#123;CUDA_REPO_PKG&#125;</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install cuda</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> install cuDNN v6.0</span></span><br><span class="line">CUDNN_TAR_FILE="cudnn-8.0-linux-x64-v6.0.tgz"</span><br><span class="line">wget http://developer.download.nvidia.com/compute/redist/cudnn/v6.0/$&#123;CUDNN_TAR_FILE&#125;</span><br><span class="line">tar -xzvf $&#123;CUDNN_TAR_FILE&#125;</span><br><span class="line">sudo cp -P cuda/include/cudnn.h /usr/local/cuda-8.0/include</span><br><span class="line">sudo cp -P cuda/lib64/libcudnn* /usr/local/cuda-8.0/lib64/</span><br><span class="line">sudo chmod a+r /usr/local/cuda-8.0/include/cudnn.h /usr/local/cuda-8.0/lib64/libcudnn*</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">set</span> environment variables</span></span><br><span class="line">export PATH=/usr/local/cuda-8.0/bin$&#123;PATH:+:$&#123;PATH&#125;&#125;</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/cuda-8.0/lib64\$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-pytorch-中查看GPU信息"><a href="#3-pytorch-中查看GPU信息" class="headerlink" title="3. pytorch 中查看GPU信息"></a>3. pytorch 中查看GPU信息</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cuda 是否可用</span></span><br><span class="line">torch.cuda.is_available()</span><br><span class="line"><span class="comment"># 返回 GPU 数量</span></span><br><span class="line">torch.cuda.device_count()</span><br><span class="line"><span class="comment"># 返回 GPu 的名字，设备索引默认从 0 开始</span></span><br><span class="line">torch.cuda.get_device_name(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 返回当前设备索引</span></span><br><span class="line">torch.cuda.current_device()</span><br><span class="line"><span class="comment"># 返回 torch 的版本</span></span><br><span class="line">torch.__version__</span><br><span class="line"><span class="comment"># 返回 cuda 的版本</span></span><br><span class="line">torch.version.cuda()</span><br></pre></td></tr></table></figure>

<h2 id="4-tensorflow-环境配置"><a href="#4-tensorflow-环境配置" class="headerlink" title="4. tensorflow 环境配置"></a>4. tensorflow 环境配置</h2><p><code>tensorflow</code> 与 <code>cuda</code>、<code>cudnn</code> 之间的适配关系参考：<a href="https://blog.csdn.net/oMoDao1/article/details/83241074" target="_blank" rel="noopener">https://blog.csdn.net/oMoDao1/article/details/83241074</a></p>
<h3 id="4-1-安装-tensorflow-gpu"><a href="#4-1-安装-tensorflow-gpu" class="headerlink" title="4.1 安装 tensorflow-gpu"></a>4.1 安装 tensorflow-gpu</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 GPU 版本的 tensorflow</span></span><br><span class="line">pip install tensorflow-gpu</span><br><span class="line"><span class="comment"># 安装 CPU 版本的 tensorflow</span></span><br><span class="line">pip install tensorflow</span><br></pre></td></tr></table></figure>

<p><strong>注意： tensorflow的安装版本应该参考官方发布，与 cuda 的版本保持一致</strong></p>
<h3 id="4-2-安装参考"><a href="#4-2-安装参考" class="headerlink" title="4.2 安装参考"></a>4.2 安装参考</h3><ul>
<li><code>tensorflow:</code> <a href="https://www.tensorflow.org/install#requirements_to_run_tensorflow_with_gpu_support" target="_blank" rel="noopener">https://www.tensorflow.org/install#requirements_to_run_tensorflow_with_gpu_support</a></li>
<li><code>CUDA:</code> <a href="https://developer.nvidia.com/cuda-toolkit-archive" target="_blank" rel="noopener">https://developer.nvidia.com/cuda-toolkit-archive</a></li>
</ul>
<h3 id="4-3-查看信息"><a href="#4-3-查看信息" class="headerlink" title="4.3 查看信息"></a>4.3 查看信息</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line">print(tf.__version__)   <span class="comment"># tensorflow version</span></span><br><span class="line">print(tf.__path__)      <span class="comment"># tensorflow install path</span></span><br></pre></td></tr></table></figure>

<h2 id="5-Tips"><a href="#5-Tips" class="headerlink" title="5. Tips"></a>5. Tips</h2><h3 id="5-1-查看-GPU-的使用情况"><a href="#5-1-查看-GPU-的使用情况" class="headerlink" title="5.1 查看 GPU 的使用情况"></a>5.1 查看 GPU 的使用情况</h3><p><code>nvidia-smi</code> 得到的信息比较少，这里使用 <code>gpustat</code></p>
<p>详见 <a href="https://github.com/wookayin/gpustat" target="_blank" rel="noopener">gpustat</a></p>
<h3 id="5-2-tmux-的使用"><a href="#5-2-tmux-的使用" class="headerlink" title="5.2 tmux 的使用"></a>5.2 <code>tmux</code> 的使用</h3><p>项目地址 <a href="https://github.com/tmux/tmux" target="_blank" rel="noopener">tmux</a>，终端复用工具.<br>命令参考：<a href="https://www.cnblogs.com/kaiye/p/6275207.html" target="_blank" rel="noopener">https://www.cnblogs.com/kaiye/p/6275207.html</a></p>
<p>tmux 中有几个比较重要的概念：</p>
<ul>
<li>session: 建立一个工作区会话</li>
<li>window: 容纳多个窗格</li>
<li>pane: 可以在窗格中分成多个窗格</li>
<li><code>ctrl + B</code> 基本指令，使用该指令之后，输入的下一个指令解释为 <code>tmux</code> 命令</li>
</ul>
<ol>
<li><p>新建 session</p>
<p> <code>tmux new -s name_xxx</code> name_xxx 为 session name</p>
</li>
<li><p>一个 session 中新建 window</p>
<p> <code>ctrl+B</code> -&gt; <code>c</code></p>
<p> sesssion 中 window 之间的切换：<br>  <code>ctrl+B</code> -&gt; <code>n</code> 切换 next wiindow；<br>  <code>ctrl+B</code> -&gt; <code>p</code> 切换 previous window</p>
</li>
<li><p>一个 window 里新建 pane</p>
<p> 左右切分 pane: <code>ctrl+B</code> -&gt; <code>%</code>；<br> 上下切分 pane: <code>ctrl+B</code> -&gt; <code>&quot;</code>；<br> pane 之间的切换使用 <code>ctrl+B</code> -&gt; 上下左右；<br> 关闭 pane: <code>ctrl+B</code> -&gt; <code>x</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>MLDL</category>
      </categories>
      <tags>
        <tag>MLDL</tag>
      </tags>
  </entry>
  <entry>
    <title>线性代数</title>
    <url>/2019/11/08/Matlab/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Matlab</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>figure</title>
    <url>/2019/11/08/Matlab/figure/</url>
    <content><![CDATA[<h1 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h1><h2 id="plot"><a href="#plot" class="headerlink" title="plot"></a>plot</h2><blockquote>
<ul>
<li>plot(x,y);  </li>
<li>plot(x,y1;x,y2);  </li>
<li>plot(matrix);  绘制矩阵每一列的数据，以矩阵行为坐标  </li>
</ul>
</blockquote>
<h2 id="hold-amp-figure"><a href="#hold-amp-figure" class="headerlink" title="hold &amp; figure"></a>hold &amp; figure</h2><blockquote>
<ul>
<li>hold on;hold off;用于在同一幅图形里继续绘图  </li>
<li>figure,figure1,figure2用于绘制第几幅图形  </li>
</ul>
</blockquote>
<h2 id="线条与标注"><a href="#线条与标注" class="headerlink" title="线条与标注"></a>线条与标注</h2><blockquote>
<ul>
<li>plot(x,y,’:ok’)  <strong>线条类型</strong>为点  <strong>点类型</strong>为.   <strong>颜色</strong>为黑色  </li>
<li>axis(v)  思维矢量设置坐标轴  </li>
<li>legend(‘string1’,’string2’,etc)  设置图例  </li>
<li>text(x_coordinate,y_coordinate,’string’)  在图形不同位置添加文本框</li>
<li>gtext(‘string’)  文本框的位置由鼠标确定  </li>
<li>title(‘string’)   设置标题  </li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title(&apos;\alpha \beta \gamma&apos;)  希腊字母  </span><br><span class="line">title(&apos;x^2&apos;)    设置上标   </span><br><span class="line">title(&apos;x_5&apos;)    创建下标  </span><br><span class="line">title(&apos;k^&#123;-1&#125;&apos;)   创建下标</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Matlab</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>输入输出</title>
    <url>/2019/11/08/C/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h1 id="输入输出问题"><a href="#输入输出问题" class="headerlink" title="输入输出问题"></a>输入输出问题</h1><p>以前没有注意过C/C++的输入与输出问题，总觉得很简单，直到今天才发现，输入输出里面还是有很多学问呢</p>
<h2 id="几个特殊的字符"><a href="#几个特殊的字符" class="headerlink" title="几个特殊的字符"></a>几个特殊的字符</h2><blockquote>
<ul>
<li>‘\0’ 空白字符  ASCII码：0x00  出现在字符串结尾</li>
<li>‘ ‘  空格字符  ASCII码：0x20  </li>
<li>‘\n’ 换行符    ASCII码：0x0a</li>
</ul>
</blockquote>
<h2 id="输入函数"><a href="#输入函数" class="headerlink" title="输入函数"></a>输入函数</h2><p><code>scanf()</code><br>头文件 stdio.h  不能输入空格，换行，tab符号，遇到即输入结束<br><code>gets()</code><br>头文件 stdio.h  能够输入空格，换行，tab符号<br><code>cin</code><br>头文件 iostream 不能输入空格，换行，tab符号，遇到即输入结束<br><code>getline()</code><br>头文件 iostream 能够输入空格，换行，tab符号<br><code>int fgets(char *string,int size,FILE *stream)  返回值：成功返回非负值；失败返回EOF</code>   </p>
<p>将字符串定位到文件流输出  eg: fgets(char *string,stdin)标准输入  </p>
<h2 id="输出函数"><a href="#输出函数" class="headerlink" title="输出函数"></a>输出函数</h2><p>与上述对应<br><code>int fputs(char *string,FILE *stream)</code><br>与输入的区别在于无size限制</p>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Bert_ELMO_GPT</title>
    <url>/2020/01/04/NLP/Bert_ELMO_GPT/</url>
    <content><![CDATA[<h1 id="Introduction-of-Bert-ELMO-GPT"><a href="#Introduction-of-Bert-ELMO-GPT" class="headerlink" title="Introduction of Bert, ELMO, GPT"></a>Introduction of Bert, ELMO, GPT</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ul>
<li>传统的 encoding 方式</li>
<li>现在的 word embedding 的几种方式</li>
</ul>
<h2 id="1-传统的-encoding-方式"><a href="#1-传统的-encoding-方式" class="headerlink" title="1. 传统的 encoding 方式"></a>1. 传统的 encoding 方式</h2><ul>
<li><p>1-of-N encoding</p>
<p>  one hot 的方式，但缺乏词汇之间的语义相似度</p>
</li>
<li><p>word embedding</p>
<p>  refer: <a href="https://www.youtube.com/watch?v=X7PH3NuYW0Q" target="_blank" rel="noopener">https://www.youtube.com/watch?v=X7PH3NuYW0Q</a></p>
</li>
</ul>
<p><img src="/2020/01/04/NLP/Bert_ELMO_GPT/word2com_1.png" alt="word2com"></p>
<p><em>In the typical embedding, the same type hase the same embedding.</em></p>
<p><strong>首先明确：下图中的 word， 属于相同的 type，但是不同的 token</strong></p>
<p><img src="/2020/01/04/NLP/Bert_ELMO_GPT/word2com_2.png" alt="word2com"></p>
<p><img src="/2020/01/04/NLP/Bert_ELMO_GPT/word2com_3.png" alt="word2com"></p>
<p><em>Motivaton:</em> 那怎么做才能让language 在不同的 context 中，根据不同的 token拥有不同的 word embedding 呢？，一下介绍几种常见的 model</p>
<h2 id="2-ELMO"><a href="#2-ELMO" class="headerlink" title="2. ELMO"></a>2. ELMO</h2><p>Embeddings from Language Model (ELMO)</p>
<h3 id="2-1-RNN-based-ELMO"><a href="#2-1-RNN-based-ELMO" class="headerlink" title="2.1 RNN-based ELMO"></a>2.1 RNN-based ELMO</h3><ul>
<li>RNN-based language model</li>
<li>不需要标注数据，直接 trainning</li>
</ul>
<p><img src="/2020/01/04/NLP/Bert_ELMO_GPT/word2com_4.png" alt="elmo"></p>
<p>对于每个 input 的 hidden ，都可以代表该 token 在 context 中的 embedding，因为在不同的语境中，虽然是相同的 type， 但 token 的不同能产生不同的 embedding</p>
<h3 id="2-2-LSTM-based-ELMO"><a href="#2-2-LSTM-based-ELMO" class="headerlink" title="2.2 LSTM-based ELMO"></a>2.2 LSTM-based ELMO</h3><ul>
<li>考虑进正向及反向的 contex 信息</li>
</ul>
<p><img src="/2020/01/04/NLP/Bert_ELMO_GPT/word2com_5.png" alt="elmo"></p>
<ul>
<li>how to choose hidden layer?</li>
</ul>
<p>当深度的 LSTM 进行训练的时候，train 得到的有很多 layer 的 hidden ，如何选取不同的 hidden layer作为 output 呢？？</p>
<p>ELMO says, utilize all!</p>
<ul>
<li>how to train ?</li>
</ul>
<p>进行 weight sum，这里的 weight 是 α1，α2，α3…，表示出 deep RNN中 hidden layer 的 weight，这里把 α1，α2…当做 parameter 与 down stream 的 task 接起来一起 train！！</p>
<p><img src="/2020/01/04/NLP/Bert_ELMO_GPT/word2com_6.png" alt="elmo"></p>
<p>在上图中可以看出，down stream 的 tasks 的不同， train 出来的不同 hidden layer 的 weight 也不同，是与 down stream tasks 紧密相关的。</p>
<ul>
<li>SRL: Semantic Role Labelling</li>
<li>Coref: co-reference …</li>
</ul>
<h2 id="3-BERT"><a href="#3-BERT" class="headerlink" title="3. BERT"></a>3. BERT</h2><p><strong>Encoder of Transformer</strong></p>
<p>BERT 是 transformer 的 encoder，相比于前面的 transformer 需要大量的 annotation text， <em>Bert 不需要 annotation text</em>，train 之后的 model，输入 word 输出 embedding. Bert 的内部并不是 RNN，而是 self-attention 的 transformer 的 encoder.</p>
<p><img src="/2020/01/04/NLP/Bert_ELMO_GPT/word2com_7.png" alt="bert"></p>
<p><em>在中文中，也许使用 character 更为有效，因为中文中的词（word）是无穷无尽的，字（character）是有限的</em></p>
<h3 id="3-1-Training-of-Bert"><a href="#3-1-Training-of-Bert" class="headerlink" title="3.1 Training of Bert"></a>3.1 Training of Bert</h3><p><strong>How to train Bert network?</strong></p>
<ul>
<li>Approach 1: Masked LM</li>
</ul>
<ol>
<li>input 的 word 会有 15% 被替换为一个特殊的 token，即 mask；</li>
<li>Bert 的 train goal 是把 mask 的 token 补充回来</li>
</ol>
<p><img src="/2020/01/04/NLP/Bert_ELMO_GPT/bert2.png" alt="bert_2"></p>
<p>当使用 Linear Multi-class Classifier做分类任务时，可能需要很多层的 Bert 用来 representation. 并且由此也可以看出当两个 word 填到一个 mask ，没有违和感则说明两个 word 有相似的 semantic</p>
<ul>
<li>Approach 2: Next Sentence Prediction</li>
</ul>
<p><em>Train goal:</em> next sentence prediction.</p>
<p><img src="/2020/01/04/NLP/Bert_ELMO_GPT/bert_3.png" alt="bert_3"></p>
<ul>
<li>SEP: 代表了两个句子的分界点</li>
<li>CLS：代表了 Bert 的分类结果输出点，当 Bert 判断两个句子应当相接，CLS 输出 yes，否则输出 no.</li>
</ul>
<blockquote>
<p>当 Bert 同时使用者两个 tasks 进行 train 的的时候，learn 的效果最好！！</p>
</blockquote>
<h3 id="3-2-How-to-use-Bert"><a href="#3-2-How-to-use-Bert" class="headerlink" title="3.2 How to use Bert"></a>3.2 How to use Bert</h3><p>最直接的想法是用 Bert 当作抽 feature 的工具，利用 Bert 输出的 word embedding进行 down stream tasks 的 训练。一下所有 tasks 的训练不同于上述中 Bert 的训练，下面的 task 属于 down streeam tasks of Bert，需要 labelled data.</p>
<ul>
<li>把 bert 的训练和下游的任务放在一起进行 train</li>
</ul>
<h4 id="case1-Sequence-gt-class-分类任务"><a href="#case1-Sequence-gt-class-分类任务" class="headerlink" title="case1: Sequence -&gt; class 分类任务"></a>case1: Sequence -&gt; class 分类任务</h4><p>在开头的地方给一个分类的符号，再通过 接一个 linear classifier 进行分类，</p>
<p>Model:</p>
<ul>
<li>Bert + Linear Classifier for CLS position</li>
<li>Input: single sentence</li>
<li>Output: class</li>
<li>Example: Sentiment Analysis …</li>
</ul>
<p>Train：</p>
<ul>
<li>Linear Classifier: Trained from scratch</li>
<li>Bert: fine-tune</li>
<li>model 需要学习到的参数的数量还是比较少的</li>
</ul>
<p><img src="/2020/01/04/NLP/Bert_ELMO_GPT/bert_4.png" alt="bert4"></p>
<h4 id="case2-sentences’-word-slot"><a href="#case2-sentences’-word-slot" class="headerlink" title="case2: sentences’ word slot"></a>case2: sentences’ word slot</h4><p>句子的词分类问题，将句子中的每个词填入一个class slot</p>
<p>Model:</p>
<ul>
<li>Bert + Linear Classifier for each embedding position</li>
<li>Input: single sentence</li>
<li>Output: class of each word</li>
<li>Example: Slot filling</li>
</ul>
<p>Train:</p>
<ul>
<li>同上</li>
</ul>
<p><img src="/2020/01/04/NLP/Bert_ELMO_GPT/bert_5.png" alt="bert_case_2"></p>
<h4 id="case3-premise-gt-判断-hypothesis"><a href="#case3-premise-gt-判断-hypothesis" class="headerlink" title="case3: premise -&gt; 判断 hypothesis"></a>case3: premise -&gt; 判断 hypothesis</h4><p>输入两个句子，一个作为 premise，一个作为 hypothesis，判断是否正确：T/F/unknown</p>
<p>Model:</p>
<ul>
<li>Bert + Linear Classifier for CLS position</li>
<li>Input: two sentences</li>
<li>Output: class</li>
<li>Example: Natural Language Inference</li>
</ul>
<p>Train:</p>
<ul>
<li>同上</li>
</ul>
<p><img src="/2020/01/04/NLP/Bert_ELMO_GPT/bert_6.png" alt="bert_case_3"></p>
<h4 id="case4-Extraction-based-QA"><a href="#case4-Extraction-based-QA" class="headerlink" title="case4: Extraction-based QA"></a>case4: Extraction-based QA</h4><p>主要的任务是给 model 一篇文章和几个问题，model 能够正确地回答问题（Extraction-based Question Answering(QA) E.g. SQuAD）</p>
<p>Model:</p>
<ul>
<li>Bert + s-vector + e-vector，通过 s-vector, e-vector 与 word embedding做 dot product — softmax 得到分数；</li>
<li>Input: questions + documents</li>
<li>Output: integers: s, e</li>
<li>Example: Extraction-based Question Answering(QA) E.g. SQuAD</li>
</ul>
<p>Train:</p>
<ul>
<li>同上</li>
</ul>
<p>对这种任务进行解释：这种是 Extraction-style，只能在原文中找答案</p>
<ul>
<li>输入：Document D = {d1, d2, … dn}，Query Q = {q1, q2, q3 …}</li>
<li>输出：two integers（s, e), 两个 position 的标记， Answer: A = {ds,…,de}</li>
</ul>
<p><img src="/2020/01/04/NLP/Bert_ELMO_GPT/bert_7.png" alt="bert_case_4"></p>
<p><img src="/2020/01/04/NLP/Bert_ELMO_GPT/bert_8.png" alt="bert_case_4"></p>
<h3 id="3-3-中文版本的-bert-–-Erine"><a href="#3-3-中文版本的-bert-–-Erine" class="headerlink" title="3.3 中文版本的 bert – Erine"></a>3.3 中文版本的 bert – Erine</h3><p>这里在对 Bert 进行训练的时候不同于 以上 Bert mask LM 方法中对 character 进行 mask，这里是对 word 进行 mask。</p>
<p><img src="/2020/01/04/NLP/Bert_ELMO_GPT/erine.png" alt="erine"></p>
<h3 id="3-4-What-bert-learns"><a href="#3-4-What-bert-learns" class="headerlink" title="3.4 What bert learns?"></a>3.4 What bert learns?</h3><p>研究者通过将 bert 24层的 embedding 输出对比（这个过程是类似于 ELMO 的 weigt sum 方式，抽出 Bert 的 24 层的 hidden layer， 进行 weight sum 并与 down stream task 一起 train 发现， bert 的24层从低到高学习到了 NLP 的大部分过程：<code>one Bert = 文法-&gt;句法-&gt;语义</code></p>
<p><img src="/2020/01/04/NLP/Bert_ELMO_GPT/bert_9.png" alt="bert_9"></p>
<blockquote>
<p>图中横坐标代表 Bert 的24层的 representations，颜色越深代表该 task 利用该部分的 representation 越大。</p>
</blockquote>
<h3 id="3-5-Multilingual-Bert"><a href="#3-5-Multilingual-Bert" class="headerlink" title="3.5 Multilingual Bert"></a>3.5 Multilingual Bert</h3><p>多语言的 bert，google 的研究者爬取104种语言的 wiki进行训练 多语言版本的 bert</p>
<p><img src="/2020/01/04/NLP/Bert_ELMO_GPT/bert_10.png" alt="bert_10"></p>
<h2 id="4-GPT"><a href="#4-GPT" class="headerlink" title="4. GPT"></a>4. GPT</h2><p><strong>Generative Pre-Training</strong><br>特别大特别大的一个预训练模型</p>
<p><em>GPT 是 transformer 的 decoder</em>，由 openAI 制作</p>
<p><img src="/2020/01/04/NLP/Bert_ELMO_GPT/gpt_1.png" alt="GPT"></p>
<p>GPT-2 model 特别巨大，能够在<strong>没有训练资料</strong>的情况下，做：</p>
<ul>
<li>Reading Comprehension</li>
<li>Summarization</li>
<li>Translation</li>
</ul>
<p><img src="/2020/01/04/NLP/Bert_ELMO_GPT/gtp_2.png" alt="gpt_2"></p>
<p>GPT-2 OpenAI 最大的model 拥有的参数有 1542M，但考虑到到多种问题并没有被 release，release 的 model 的版本与 bert 差不多.</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ul>
<li><a href="https://talktotransformer.com/" target="_blank" rel="noopener">https://talktotransformer.com/</a></li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Gensim</title>
    <url>/2019/11/21/NLP/Gensim/</url>
    <content><![CDATA[<h2 id="学习参考"><a href="#学习参考" class="headerlink" title="学习参考"></a>学习参考</h2><ul>
<li>英语wiki LDA、LSA：<a href="http://www.alwa.info/2017/03/20/Gensim%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" target="_blank" rel="noopener">http://www.alwa.info/2017/03/20/Gensim%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</a></li>
<li><a href="https://radimrehurek.com/gensim/auto_examples/core/run_topics_and_transformations.html#sphx-glr-auto-examples-core-run-topics-and-transformations-py" target="_blank" rel="noopener">https://radimrehurek.com/gensim/auto_examples/core/run_topics_and_transformations.html#sphx-glr-auto-examples-core-run-topics-and-transformations-py</a></li>
<li><a href="http://www.alwa.info/2017/03/20/Gensim%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" target="_blank" rel="noopener">http://www.alwa.info/2017/03/20/Gensim%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/37175253" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/37175253</a></li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>GCN</title>
    <url>/2019/11/19/NLP/GCN/</url>
    <content><![CDATA[<h1 id="Graph-Convolution-Network"><a href="#Graph-Convolution-Network" class="headerlink" title="Graph Convolution Network"></a>Graph Convolution Network</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>github: <a href="https://github.com/KaihuaTang/GGNN-for-bAbI-dataset.pytorch.1.0" target="_blank" rel="noopener">https://github.com/KaihuaTang/GGNN-for-bAbI-dataset.pytorch.1.0</a></li>
<li>website: <a href="https://tkipf.github.io/graph-convolutional-networks/" target="_blank" rel="noopener">https://tkipf.github.io/graph-convolutional-networks/</a></li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Information_Retrieval</title>
    <url>/2019/11/10/NLP/Information_Retrieval/</url>
    <content><![CDATA[<h3 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h3><ul>
<li>Introduction to Information Retrieval 《信息检索导论》 <a href="https://nlp.stanford.edu/IR-book/" target="_blank" rel="noopener">https://nlp.stanford.edu/IR-book/</a></li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>LDA</title>
    <url>/2019/11/07/NLP/LDA/</url>
    <content><![CDATA[<p>LDA </p>
<h2 id="输入与训练"><a href="#输入与训练" class="headerlink" title="输入与训练"></a>输入与训练</h2><p><code>The interface follows conventions found in scikit-learn</code> LDA的接口遵循 <code>scikit-learn</code> 的规范，因此可使用 <code>scikit-learn</code> 提供的数据预处理方法如 <code>CountVectorizer</code> 或 <code>TfidfVectorizer</code> 将文本数据转化为向量，并作为 LDA 的输入进行训练。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>model = lda.LDA(n_topics=<span class="number">20</span>, n_iter=<span class="number">1000</span>, random_state=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>model.fit(vectorizer.fit_transform(corpus).toarray())   <span class="comment"># Input the weight</span></span><br></pre></td></tr></table></figure>

<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><ul>
<li>Topic-Word Distribution</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>topic_word = model.topic_word_  <span class="comment"># model.components_ also works</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>n_top_words = <span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, topic_dist <span class="keyword">in</span> enumerate(topic_word):</span><br><span class="line"><span class="meta">... </span>    topic_words = np.array(vocab)[np.argsort(topic_dist)][:-(n_top_words+<span class="number">1</span>):<span class="number">-1</span>]</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'Topic &#123;&#125;: &#123;&#125;'</span>.format(i, <span class="string">' '</span>.join(topic_words)))</span><br></pre></td></tr></table></figure>

<ul>
<li>Document-Topic Distribution</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>doc_topic = model.doc_topic_</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"&#123;&#125; (top topic: &#123;&#125;)"</span>.format(titles[i], doc_topic[i].argmax()))</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">"&#123;&#125; (top topic: &#123;&#125;)"</span>.format(titles[i], np.argsort(doc_topic[i])[:<span class="number">-4</span>:<span class="number">-1</span>]))</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由此，我们观察到 <code>lda</code> 全程对 TF-Matrix 进行计算，并没有考虑词语的上下文关系，是 Bow 模型。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://pypi.org/project/lda/" target="_blank" rel="noopener">https://pypi.org/project/lda/</a></li>
<li><a href="https://juejin.im/post/5ab365f25188252c32199636" target="_blank" rel="noopener">https://juejin.im/post/5ab365f25188252c32199636</a></li>
<li><a href="https://github.com/scarlettgin/novel_analysis" target="_blank" rel="noopener">https://github.com/scarlettgin/novel_analysis</a></li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Bert Tutorial</title>
    <url>/2020/01/11/NLP/Bert_tutorial/</url>
    <content><![CDATA[<h1 id="1-Bert-Tutorial"><a href="#1-Bert-Tutorial" class="headerlink" title="1. Bert Tutorial"></a>1. Bert Tutorial</h1><h2 id="1-1-Bert-的输入格式"><a href="#1-1-Bert-的输入格式" class="headerlink" title="1.1 Bert 的输入格式"></a>1.1 Bert 的输入格式</h2><p>BERT requires specifically formatted inputs. For each tokenized input sentence, we need to create:</p>
<ul>
<li>input ids: a sequence of integers identifying each input token to its index number in the BERT tokenizer vocabulary</li>
<li>segment mask: (optional) a sequence of 1s and 0s used to identify whether the input is one sentence or two sentences long. For one sentence inputs, this is simply a sequence of 0s. For two sentence inputs, there is a 0 for each token of the first sentence, followed by a 1 for each token of the second sentence</li>
<li>attention mask: (optional) a sequence of 1s and 0s, with 1s for all input tokens and 0s for all padding tokens (we’ll detail this in the next paragraph)</li>
<li>labels: a single value of 1 or 0. In our task 1 means “grammatical” and 0 means “ungrammatical”</li>
</ul>
<h2 id="1-2-Bert-的参数设置"><a href="#1-2-Bert-的参数设置" class="headerlink" title="1.2 Bert 的参数设置"></a>1.2 Bert 的参数设置</h2><blockquote>
<p>For the purposes of fine-tuning, the authors recommend the following hyperparameter ranges:</p>
</blockquote>
<ul>
<li>Batch size: 16, 32</li>
<li>Learning rate (Adam): 5e-5, 3e-5, 2e-5</li>
<li>Number of epochs: 2, 3, 4</li>
</ul>
<h1 id="2-BertTokenizer-之-WordPiece-Model"><a href="#2-BertTokenizer-之-WordPiece-Model" class="headerlink" title="2. BertTokenizer 之 WordPiece Model"></a>2. BertTokenizer 之 <code>WordPiece</code> Model</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Load pre-trained model tokenizer (vocabulary)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokenizer = BertTokenizer.from_pretrained(<span class="string">'bert-base-uncased'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = <span class="string">"Here is the sentence I want embeddings for."</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>marked_text = <span class="string">"[CLS] "</span> + text + <span class="string">" [SEP]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tokenize our sentence with the BERT tokenizer</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokenized_text = tokenizer.tokenize(marked_text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print out the tokens.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> (tokenized_text</span><br><span class="line">[<span class="string">'[CLS]'</span>, <span class="string">'here'</span>, <span class="string">'is'</span>, <span class="string">'the'</span>, <span class="string">'sentence'</span>, <span class="string">'i'</span>, <span class="string">'want'</span>, <span class="string">'em'</span>, <span class="string">'##bed'</span>, <span class="string">'##ding'</span>, <span class="string">'##s'</span>, <span class="string">'for'</span>, <span class="string">'.'</span>, <span class="string">'[SEP]'</span>]</span><br></pre></td></tr></table></figure>

<p>使用 <code>BertTokenizer</code> 进行分词后的序列包含 <code>##</code>，这主要的原因是 bert 使用 vocabulary 词典的大小为 3000，为了在训练时能够将所有的英文文章中的单词都能得到编码，就是用了 <code>WordPiece</code>。具体：</p>
<blockquote>
<p>Why does it look this way? This is because the BERT tokenizer was created with a WordPiece model. This model greedily creates a fixed-size vocabulary of individual characters, subwords, and words that best fits our language data. Since the vocabulary limit size of our BERT tokenizer model is 30,000, the WordPiece model generated a vocabulary that contains all English characters plus the ~30,000 most common words and subwords found in the English language corpus the model is trained on. This vocabulary contains four things:</p>
<ul>
<li>Whole words</li>
<li>Subwords occuring at the front of a word or in isolation (“em” as in “embeddings” is assigned the same vector as the standalone sequence of characters “em” as in “go get em” )</li>
<li>Subwords not at the front of a word, which are preceded by ‘##’ to denote this case</li>
<li>Individual characters</li>
</ul>
<p>To tokenize a word under this model, the tokenizer first checks if the whole word is in the vocabulary. If not, it tries to break the word into the largest possible subwords contained in the vocabulary, and as a last resort will decompose the word into individual characters. Note that because of this, we can always represent a word as, at the very least, the collection of its individual characters.</p>
<p>As a result, rather than assigning out of vocabulary words to a catch-all token like ‘OOV’ or ‘UNK,’ words that are not in the vocabulary are decomposed into subword and character tokens that we can then generate embeddings for.</p>
<p>So, rather than assigning “embeddings” and every other out of vocabulary word to an overloaded unknown vocabulary token, we split it into subword tokens [‘em’, ‘##bed’, ‘##ding’, ‘##s’] that will retain some of the contextual meaning of the original word. We can even average these subword embedding vectors to generate an approximate vector for the original word. <a href="https://mccormickml.com/2019/05/14/BERT-word-embeddings-tutorial/" target="_blank" rel="noopener">详见</a></p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/google-research/bert" target="_blank" rel="noopener">google-bert-github</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/56103665" target="_blank" rel="noopener">一起读bert文本分类代码</a></li>
<li><a href="https://towardsdatascience.com/bert-for-dummies-step-by-step-tutorial-fb90890ffe03" target="_blank" rel="noopener">BERT for dummies — Step by Step Tutorial</a>，对应的 <a href="https://colab.research.google.com/drive/1ywsvwO6thOVOrfagjjfuxEf6xVRxbUNO" target="_blank" rel="noopener">Jupyter notebook</a></li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>NLTK</title>
    <url>/2019/11/21/NLP/NLTK/</url>
    <content><![CDATA[<h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>NLTK 是最为知名的Python自然语言处理工具之一，全程：Natural Language ToolKit， 诞生于宾夕法尼亚大学，主要面向英文。但其很多模型或者模块都与语种无关，因此当实现了Tokenization 和分词之后，NLTK的很多工具包是可以复用的。</p>
<p>在NLTK中使用Stanford文本分析工具包也是一个常用的手段，如何在NLTK中调用Stanford中文工具包：</p>
<ul>
<li><a href="http://www.zmonster.me/2016/06/08/use-stanford-nlp-package-in-nltk.html" target="_blank" rel="noopener">http://www.zmonster.me/2016/06/08/use-stanford-nlp-package-in-nltk.html</a></li>
<li><a href="http://www.cnblogs.com/baiboy/p/nltk1.html" target="_blank" rel="noopener">http://www.cnblogs.com/baiboy/p/nltk1.html</a></li>
</ul>
<h2 id="官方资料学习-https-www-nltk-org-book"><a href="#官方资料学习-https-www-nltk-org-book" class="headerlink" title="官方资料学习 https://www.nltk.org/book/"></a>官方资料学习 <a href="https://www.nltk.org/book/" target="_blank" rel="noopener">https://www.nltk.org/book/</a></h2><h3 id="5-Categorizing-and-Tagging-words"><a href="#5-Categorizing-and-Tagging-words" class="headerlink" title="5. Categorizing and Tagging words"></a>5. Categorizing and Tagging words</h3><h4 id="5-1-tag-sets-词性标注集"><a href="#5-1-tag-sets-词性标注集" class="headerlink" title="5.1 tag sets 词性标注集"></a>5.1 tag sets 词性标注集</h4><ul>
<li><code>nltk.help.upenn(&#39;NN&#39;)</code> 可查询词性标注集的具体含义，如：</li>
</ul>
<ol>
<li><code>NN</code> noun, common, singular or mass</li>
<li><code>VB</code> verb, base form</li>
<li><code>JJ</code> adjective or numeral, ordinal</li>
<li><code>IN</code> preposition or conjunction, subordinating</li>
<li><code>DT</code> determiner</li>
<li><code>PRP</code> pronoun, personal</li>
</ol>
<h3 id="7-Extracting-Information-from-Text"><a href="#7-Extracting-Information-from-Text" class="headerlink" title="7. Extracting Information from Text"></a>7. Extracting Information from Text</h3><p>参考：<a href="https://www.nltk.org/book/ch07.html" target="_blank" rel="noopener">https://www.nltk.org/book/ch07.html</a></p>
<h4 id="7-2-Chunking-分块-—-命名实体识别技术之一"><a href="#7-2-Chunking-分块-—-命名实体识别技术之一" class="headerlink" title="7.2 Chunking 分块 — 命名实体识别技术之一"></a>7.2 Chunking 分块 — 命名实体识别技术之一</h4><p>NLTK主要采用 chunk 技术来识别命名实体，这是一种基于规则的方法，如：</p>
<ul>
<li>Tag Patterns 标记模式</li>
<li>Regular Expressions 正则表达式</li>
<li>Classifier-Based Chunkers 基于分类器的分块器，主要加入不仅仅考虑 POS，还考虑 words 的内容</li>
</ul>
<p>人工标记的 tag patterns 用来对 POS 进行匹配和识别，因此 Part-of-Speech 词性标注是其前提；</p>
<p>识别出的 chunk 的表示方法：  </p>
<ul>
<li>IOB标记（如 B-NP、I-NP等）</li>
<li>树状图标记 （将 词性标注后的 token 表示成树的叶子节点</li>
</ul>
<h4 id="7-5-Named-Entity-Recognition"><a href="#7-5-Named-Entity-Recognition" class="headerlink" title="7.5 Named Entity Recognition"></a>7.5 Named Entity Recognition</h4><p>对命名实体识别中的一些词语进行解释：</p>
<ul>
<li><code>Facility</code> : human-made artifacts in the domains of architecture and civil engineering</li>
<li><code>GPE</code> : geo-political entities such as city, state/province, and country</li>
</ul>
<h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><ul>
<li>NLTK 官方在线书籍：<a href="https://www.nltk.org/book/" target="_blank" rel="noopener">https://www.nltk.org/book/</a></li>
<li>基于 NLTK 官方书籍的翻译版：《Python自然语言处理》 陈涛译</li>
<li>52nlp: <a href="http://textminingonline.com/dive-into-nltk-part-i-getting-started-with-nltk" target="_blank" rel="noopener">http://textminingonline.com/dive-into-nltk-part-i-getting-started-with-nltk</a></li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>StanfordNLP</title>
    <url>/2019/12/11/NLP/StanfordNLP/</url>
    <content><![CDATA[<h1 id="Stanford-CoreNLP"><a href="#Stanford-CoreNLP" class="headerlink" title="Stanford CoreNLP"></a>Stanford CoreNLP</h1><p><strong>Not stanfordnlp!!</strong></p>
<ol>
<li><code>stanford-corenlp</code>的gitpage主页：<a href="https://stanfordnlp.github.io/CoreNLP/" target="_blank" rel="noopener">https://stanfordnlp.github.io/CoreNLP/</a></li>
<li><code>stanford-corenlp</code>的github仓库地址：<a href="https://github.com/stanfordnlp/CoreNLP" target="_blank" rel="noopener">https://github.com/stanfordnlp/CoreNLP</a></li>
<li><code>stanford-corenlp</code>的软件组件介绍：<a href="https://nlp.stanford.edu/software/" target="_blank" rel="noopener">https://nlp.stanford.edu/software/</a></li>
</ol>
<p>我们从上述链接可以发现stanfordnlp的主要组成部分：<code>Core</code>、<code>Projects</code>、<code>Archive</code><br>这些软件基本组合进<code>stanford-corenlp</code>，成为其组成部分，使用方法也比较多，大的区分为：</p>
<ol>
<li>直接使用对应组件的package，写java代码进行调用</li>
<li>以<code>stanford-corenlp</code>服务的方式进行调用</li>
</ol>
<ul>
<li><code>Command line usage</code> 通过命令行使用</li>
</ul>
<p><em><a href="https://stanfordnlp.github.io/CoreNLP/cmdline.html" target="_blank" rel="noopener">source</a></em></p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">java -mx1g -cp "*" edu.stanford.nlp.naturalli.OpenIE    # 从标准输入获取输入，输出到标准输出</span><br><span class="line">java -mx1g -cp "*" edu.stanford.nlp.naturalli.OpenIE  /<span class="built_in">path</span>/to/file1  /<span class="built_in">path</span>/to/file2    # 指定输入与输出路径</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Stanford CoreNLP API</code> 通过<code>java programmatic API</code></li>
</ul>
<p><em><a href="https://stanfordnlp.github.io/CoreNLP/api.html" target="_blank" rel="noopener">source</a></em></p>
<blockquote>
<p>The backbone of the CoreNLP package is formed by two classes: Annotation and Annotator. Annotations are the data structure which hold the results of annotators. Annotations are basically maps, from keys to bits of the annotation, such as the parse, the part-of-speech tags, or named entity tags. Annotators are a lot like functions, except that they operate over Annotations instead of Objects. They do things like tokenize, parse, or NER tag sentences. Annotators and Annotations are integrated by AnnotationPipelines, which create sequences of generic Annotators. Stanford CoreNLP inherits from the AnnotationPipeline class, and is customized with NLP Annotators.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> edu.stanford.nlp.pipeline.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicPipelineExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// creates a StanfordCoreNLP object, with POS tagging, lemmatization, NER, parsing, and coreference resolution</span></span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.setProperty(<span class="string">"annotators"</span>, <span class="string">"tokenize, ssplit, pos, lemma, ner, parse, dcoref"</span>);</span><br><span class="line">        StanfordCoreNLP pipeline = <span class="keyword">new</span> StanfordCoreNLP(props);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read some text in the text variable</span></span><br><span class="line">        String text = <span class="string">"..."</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create an empty Annotation just with the given text</span></span><br><span class="line">        Annotation document = <span class="keyword">new</span> Annotation(text);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// run all Annotators on this text</span></span><br><span class="line">        pipeline.annotate(document);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>CoreNLP server</code> 通过web service运行<code>stanford-corenlp</code>（<code>python</code> or other）</li>
</ul>
<p><em>这种一般以服务的方式运行，通过其他语言的wrapper调用<a href="https://stanfordnlp.github.io/CoreNLP/other-languages.html" target="_blank" rel="noopener">source</a></em></p>
<p>启动<br><em><a href="https://stanfordnlp.github.io/CoreNLP/corenlp-server.html" target="_blank" rel="noopener">source</a></em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Run the server using all jars <span class="keyword">in</span> the current directory (e.g., the CoreNLP home directory)</span></span><br><span class="line">java -mx4g -cp "*" edu.stanford.nlp.pipeline.StanfordCoreNLPServer -port 9000 -timeout 15000</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python wrapper：https://github.com/Lynten/stanford-corenlp/blob/master/stanfordcorenlp/corenlp.py</span></span><br><span class="line"><span class="comment"># Simple usage</span></span><br><span class="line"><span class="keyword">from</span> stanfordcorenlp <span class="keyword">import</span> StanfordCoreNLP</span><br><span class="line"></span><br><span class="line">nlp = StanfordCoreNLP(<span class="string">r'G:\JavaLibraries\stanford-corenlp-full-2018-02-27'</span>)</span><br><span class="line"></span><br><span class="line">sentence = <span class="string">'Guangdong University of Foreign Studies is located in Guangzhou.'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Tokenize:'</span>, nlp.word_tokenize(sentence)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Part of Speech:'</span>, nlp.pos_tag(sentence)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Named Entities:'</span>, nlp.ner(sentence)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Constituency Parsing:'</span>, nlp.parse(sentence)</span><br><span class="line"><span class="keyword">print</span> <span class="string">'Dependency Parsing:'</span>, nlp.dependency_parse(sentence)</span><br><span class="line"></span><br><span class="line">nlp.close() <span class="comment"># Do not forget to close! The backend server will consume a lot memery.</span></span><br></pre></td></tr></table></figure>

<h2 id="1-Stanford-Named-Entity-Recognizer-NER"><a href="#1-Stanford-Named-Entity-Recognizer-NER" class="headerlink" title="1. Stanford Named Entity Recognizer (NER)"></a>1. Stanford Named Entity Recognizer (NER)</h2><p>参考：<a href="https://nlp.stanford.edu/software/CRF-NER.html" target="_blank" rel="noopener">https://nlp.stanford.edu/software/CRF-NER.html</a></p>
<blockquote>
<p>Stanford NER is also known as CRFClassifier. The software provides a general implementation of (arbitrary order) linear chain Conditional Random Field (CRF) sequence models. That is, by training your own models on labeled data, you can actually use this code to build sequence models for NER or any other task. (CRF models were pioneered by <a href="http://www.cis.upenn.edu/~pereira/papers/crf.pdf" target="_blank" rel="noopener">Lafferty, McCallum, and Pereira (2001)</a>; see <a href="http://people.cs.umass.edu/~mccallum/papers/crf-tutorial.pdf" target="_blank" rel="noopener">Sutton and McCallum (2006)</a> or <a href="http://arxiv.org/pdf/1011.4088v1" target="_blank" rel="noopener">Sutton and McCallum (2010)</a> for more comprehensible introductions.)</p>
</blockquote>
<h2 id="2-Stanford-OpenIE"><a href="#2-Stanford-OpenIE" class="headerlink" title="2. Stanford OpenIE"></a>2. Stanford OpenIE</h2><p>参考：<a href="https://nlp.stanford.edu/software/openie.html" target="_blank" rel="noopener">https://nlp.stanford.edu/software/openie.html</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//https://github.com/stanfordnlp/CoreNLP/blob/master/src/edu/stanford/nlp/naturalli/OpenIEDemo.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// Create the Stanford CoreNLP pipeline</span></span><br><span class="line">    Properties props = PropertiesUtils.asProperties(</span><br><span class="line">            <span class="string">"annotators"</span>, <span class="string">"tokenize,ssplit,pos,lemma,depparse,natlog,openie"</span></span><br><span class="line">    );</span><br><span class="line">    StanfordCoreNLP pipeline = <span class="keyword">new</span> StanfordCoreNLP(props);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Annotate an example document.</span></span><br><span class="line">    String text;</span><br><span class="line">    <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      text = IOUtils.slurpFile(args[<span class="number">0</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      text = <span class="string">"Obama was born in Hawaii. He is our president."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Annotation doc = <span class="keyword">new</span> Annotation(text);</span><br><span class="line">    pipeline.annotate(doc);</span><br></pre></td></tr></table></figure>


<h2 id="学习参考"><a href="#学习参考" class="headerlink" title="学习参考"></a>学习参考</h2><ul>
<li>Python中使用Stanford CoreNLP：<a href="https://blog.csdn.net/qq_35203425/article/details/80451243" target="_blank" rel="noopener">https://blog.csdn.net/qq_35203425/article/details/80451243</a></li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Transformer</title>
    <url>/2020/01/04/NLP/Transformer/</url>
    <content><![CDATA[<h1 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h1><p>reference: <a href="https://www.youtube.com/watch?v=ugWDIIOHtPA" target="_blank" rel="noopener">https://www.youtube.com/watch?v=ugWDIIOHtPA</a></p>
<p>Seq2Seq model with self-attention</p>
<h2 id="Backgroud"><a href="#Backgroud" class="headerlink" title="Backgroud"></a>Backgroud</h2><p>RNN: Hard to parallel,  </p>
<h3 id="1-Use-CNN-to-replace-RNN"><a href="#1-Use-CNN-to-replace-RNN" class="headerlink" title="1. Use CNN to replace RNN"></a>1. Use CNN to replace RNN</h3><p><img src="/2020/01/04/NLP/Transformer/transformer1.png" alt="RNN&amp;CNN"></p>
<p><img src="/2020/01/04/NLP/Transformer/transformer2.png" alt="RNN&amp;CNN"></p>
<h3 id="2-Self-attention"><a href="#2-Self-attention" class="headerlink" title="2. Self-attention"></a>2. Self-attention</h3><p><img src="/2020/01/04/NLP/Transformer/transformer3.png" alt="self-attention"></p>
<p><strong>Attention is all you need!</strong></p>
<p>不需要 RNN/CNN，所需的仅为 attention，输入为 seq 输出为 seq</p>
<p><img src="/2020/01/04/NLP/Transformer/transformer4.png" alt="attention"></p>
<p><img src="/2020/01/04/NLP/Transformer/transformer5.png" alt="attention"></p>
<p><img src="/2020/01/04/NLP/Transformer/transformer6.png" alt="atttention"></p>
<p>q 代表的是查询的 weight；k 代表的是被匹配的 weight</p>
<h3 id="3-multi-head-self-attention"><a href="#3-multi-head-self-attention" class="headerlink" title="3. multi-head self-attention"></a>3. multi-head self-attention</h3><p>多抽头的 self-attention：</p>
<p><img src="/2020/01/04/NLP/Transformer/transformer7.png" alt="atttention"></p>
<p>考虑进位置信息的 self-attention</p>
<p><img src="/2020/01/04/NLP/Transformer/transformer8.png" alt="attention"></p>
<p>将 RNN 替换为 self-attention之后的 seq2seq model:</p>
<p><img src="/2020/01/04/NLP/Transformer/transformer9.png" alt="attention"></p>
<h3 id="4-transformer-–-Google-AI-Blog"><a href="#4-transformer-–-Google-AI-Blog" class="headerlink" title="4. transformer – Google AI Blog"></a>4. transformer – Google AI Blog</h3><ul>
<li><a href="https://ai.googleblog.com/2017/08/transformer-novel-neural-network.html" target="_blank" rel="noopener">https://ai.googleblog.com/2017/08/transformer-novel-neural-network.html</a></li>
</ul>
<h3 id="5-常见的-translation-seq2seq-model"><a href="#5-常见的-translation-seq2seq-model" class="headerlink" title="5. 常见的 translation seq2seq model"></a>5. 常见的 translation seq2seq model</h3><p><img src="/2020/01/04/NLP/Transformer/transformer10.png" alt="seq2seq"></p>
<p>self-attention transformer encoder会将 input data 的信息看完，在 decoder 中，会看 input data 的 layer及前一个产生的 token .</p>
<p><img src="/2020/01/04/NLP/Transformer/tranformer11.png" alt="seq2seq"></p>
<h3 id="6-transformer-的常见应用"><a href="#6-transformer-的常见应用" class="headerlink" title="6. transformer 的常见应用"></a>6. transformer 的常见应用</h3><p>将传统 RNN 不能处理长的 sequence，应用到 transeformer，使其输入文章生成 wikepedia 型的sequence。</p>
<p>-reference: <a href="https://arxiv.org/pdf/1801.10198.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1801.10198.pdf</a></p>
<p><img src="/2020/01/04/NLP/Transformer/transformer12.png" alt="app"></p>
<h3 id="7-Universal-Transformer"><a href="#7-Universal-Transformer" class="headerlink" title="7. Universal Transformer"></a>7. Universal Transformer</h3><p>将 original tansformer 在时间上做 RNN，重复利用</p>
<p><img src="/2020/01/04/NLP/Transformer/transformer13.png" alt="universal"></p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>Google Bert</title>
    <url>/2020/01/15/NLP/google-bert/</url>
    <content><![CDATA[<h1 id="Google-Bert"><a href="#Google-Bert" class="headerlink" title="Google Bert"></a>Google Bert</h1><p><a href="https://github.com/google-research/bert" target="_blank" rel="noopener">google-bert-github</a> 部分代码解读</p>
<h2 id="run-classifier-py-分类-demo"><a href="#run-classifier-py-分类-demo" class="headerlink" title="run_classifier.py 分类 demo"></a><code>run_classifier.py</code> 分类 demo</h2><p>其中包含的主要的类有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class InputExample(object):</span><br><span class="line"></span><br><span class="line">class PaddingInputExample(object):</span><br><span class="line"></span><br><span class="line">class InputFeatures(object):</span><br><span class="line"></span><br><span class="line">class DataProcessor(object):</span><br><span class="line"></span><br><span class="line">class XnliProcessor(DataProcessor):</span><br><span class="line"></span><br><span class="line">class MnliProcessor(DataProcessor):</span><br><span class="line"></span><br><span class="line">class MrpcProcessor(DataProcessor):</span><br><span class="line"></span><br><span class="line">class ColaProcessor(DataProcessor):</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create_model function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_model</span><span class="params">(bert_config, is_training, input_ids, input_mask, segment_ids,</span></span></span><br><span class="line"><span class="function"><span class="params">                 labels, num_labels, use_one_hot_embeddings)</span>:</span></span><br><span class="line">  <span class="string">"""Creates a classification model."""</span></span><br><span class="line">  <span class="comment"># 首先调用 modeling.BertModel 得到 bert 模型</span></span><br><span class="line">  <span class="comment"># Bert Model 需要的输入为：1. input_ids, 2. input_mask 3. segment_ids</span></span><br><span class="line">  <span class="comment"># bert_config 直接加载下载得到的配置文件</span></span><br><span class="line">  model = modeling.BertModel(</span><br><span class="line">      config=bert_config,</span><br><span class="line">      is_training=is_training,</span><br><span class="line">      input_ids=input_ids,</span><br><span class="line">      input_mask=input_mask,</span><br><span class="line">      token_type_ids=segment_ids,</span><br><span class="line">      use_one_hot_embeddings=use_one_hot_embeddings)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># In the demo, we are doing a simple classification task on the entire</span></span><br><span class="line">  <span class="comment"># segment.</span></span><br><span class="line">  <span class="comment">#</span></span><br><span class="line">  <span class="comment"># If you want to use the token-level output, use model.get_sequence_output()</span></span><br><span class="line">  <span class="comment"># instead.</span></span><br><span class="line">  <span class="comment"># bert 的输出有两种：</span></span><br><span class="line">  <span class="comment"># toekns level: model.get_sequence_output(): [batch_size, seq_len, embeddings_size]</span></span><br><span class="line">  <span class="comment"># sentences level: model.get_pooled_output(): [batch_size, embeddings_size]</span></span><br><span class="line">  output_layer = model.get_pooled_output()</span><br><span class="line"></span><br><span class="line">  hidden_size = output_layer.shape[<span class="number">-1</span>].value</span><br><span class="line"></span><br><span class="line">  output_weights = tf.get_variable(</span><br><span class="line">      <span class="string">"output_weights"</span>, [num_labels, hidden_size],</span><br><span class="line">      initializer=tf.truncated_normal_initializer(stddev=<span class="number">0.02</span>))</span><br><span class="line"></span><br><span class="line">  output_bias = tf.get_variable(</span><br><span class="line">      <span class="string">"output_bias"</span>, [num_labels], initializer=tf.zeros_initializer())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">with</span> tf.variable_scope(<span class="string">"loss"</span>):</span><br><span class="line">    <span class="keyword">if</span> is_training:</span><br><span class="line">      <span class="comment"># I.e., 0.1 dropout</span></span><br><span class="line">      output_layer = tf.nn.dropout(output_layer, keep_prob=<span class="number">0.9</span>)</span><br><span class="line"></span><br><span class="line">    logits = tf.matmul(output_layer, output_weights, transpose_b=<span class="literal">True</span>)</span><br><span class="line">    logits = tf.nn.bias_add(logits, output_bias)</span><br><span class="line">    probabilities = tf.nn.softmax(logits, axis=<span class="number">-1</span>)</span><br><span class="line">    log_probs = tf.nn.log_softmax(logits, axis=<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    one_hot_labels = tf.one_hot(labels, depth=num_labels, dtype=tf.float32)</span><br><span class="line"></span><br><span class="line">    per_example_loss = -tf.reduce_sum(one_hot_labels * log_probs, axis=<span class="number">-1</span>)</span><br><span class="line">    loss = tf.reduce_mean(per_example_loss)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (loss, per_example_loss, logits, probabilities)</span><br></pre></td></tr></table></figure>

<p><code>main</code> 部分</p>
<pre><code class="python"></code></pre>
<h2 id="run-squad-py-SQuAD（The-Stanford-Question-and-Answer-Datasets）-demo"><a href="#run-squad-py-SQuAD（The-Stanford-Question-and-Answer-Datasets）-demo" class="headerlink" title="run_squad.py SQuAD（The Stanford Question and Answer Datasets） demo"></a><code>run_squad.py</code> SQuAD（The Stanford Question and Answer Datasets） demo</h2><h2 id="modelling-py-bert-上游模型"><a href="#modelling-py-bert-上游模型" class="headerlink" title="modelling.py bert 上游模型"></a><code>modelling.py</code> bert 上游模型</h2><h2 id="optimization-py-优化器部分"><a href="#optimization-py-优化器部分" class="headerlink" title="optimization.py 优化器部分"></a><code>optimization.py</code> 优化器部分</h2><h2 id="run-pretraining-py-预训练部分"><a href="#run-pretraining-py-预训练部分" class="headerlink" title="run_pretraining.py 预训练部分"></a><code>run_pretraining.py</code> 预训练部分</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/yuanxiaosc/Entity-Relation-Extraction" target="_blank" rel="noopener">实体关系抽取-github:yuanxiaosc</a></li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>jieba</title>
    <url>/2019/11/21/NLP/jieba/</url>
    <content><![CDATA[<h2 id="Jieba简介"><a href="#Jieba简介" class="headerlink" title="Jieba简介"></a>Jieba简介</h2><p>jieba是一款中文分词工具</p>
<h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><p><code>jieba.cut(self, sentence, cut_all=False, HMM=True)</code></p>
<ul>
<li>sentence：输入文本</li>
<li>cut_all：是否全模式分词</li>
<li>HMM：是否开启 HMM，默认模式开启HMM，对中文歧义有较好的分词效果</li>
</ul>
<p><code>jieba.cut_for_search(self, sentence, cut_all=False, HMM=True)</code></p>
<ul>
<li>搜索引擎模式？？</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import jieba.posseg as pseg</span><br><span class="line"></span><br><span class="line">result = pseg.cut(test_sent)</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 <code>pseg.cut</code> 分词，并显示词性</li>
</ul>
<h2 id="中文歧义与去除停用词"><a href="#中文歧义与去除停用词" class="headerlink" title="中文歧义与去除停用词"></a>中文歧义与去除停用词</h2><p>中文歧义，中文由于对词语缺乏明显的区分标识，因此在分词方面往往存在一定的歧义，Jieba 使用 HMM（隐马尔科夫模型）仍取得了不错的效果；</p>
<p>去除停用词，即通过中文停用词表，来对分词后的词语比对，去除常用的停用词。</p>
<h2 id="分词更准确的-trick"><a href="#分词更准确的-trick" class="headerlink" title="分词更准确的 trick"></a>分词更准确的 trick</h2><ul>
<li>在 jieba 中加入一些不常见的中文词语： <code>jieba.add_word(&#39;xxx&#39;)</code></li>
<li>添加自定义词库： <code>jieba.loca_userdict(&quot;xxx.txt&quot;)</code></li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>NLP From 0 To 1</title>
    <url>/2020/01/10/NLP/nlp-from-0-to-1/</url>
    <content><![CDATA[<h1 id="NLP-从零到一（实战入门）"><a href="#NLP-从零到一（实战入门）" class="headerlink" title="NLP 从零到一（实战入门）"></a>NLP 从零到一（实战入门）</h1><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><h2 id="3-Bert-Model"><a href="#3-Bert-Model" class="headerlink" title="3. Bert Model"></a>3. Bert Model</h2><ol>
<li>Tutorial </li>
</ol>
<ul>
<li><a href="https://towardsdatascience.com/bert-for-dummies-step-by-step-tutorial-fb90890ffe03" target="_blank" rel="noopener">BERT for dummies — Step by Step Tutorial</a>，对应的 <a href="https://colab.research.google.com/drive/1ywsvwO6thOVOrfagjjfuxEf6xVRxbUNO" target="_blank" rel="noopener">Jupyter notebook</a></li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>word_embedding</title>
    <url>/2020/01/04/NLP/word_embedding/</url>
    <content><![CDATA[<h1 id="Word-Embedding"><a href="#Word-Embedding" class="headerlink" title="Word Embedding"></a>Word Embedding</h1><h2 id="1-of-N-Encoding"><a href="#1-of-N-Encoding" class="headerlink" title="1-of-N Encoding"></a>1-of-N Encoding</h2><h2 id="2-Word-Embeddding"><a href="#2-Word-Embeddding" class="headerlink" title="2. Word Embeddding"></a>2. Word Embeddding</h2><ul>
<li><code>unsupervised learning</code></li>
<li><code>dimension reduction</code> wword embedding 的维度要比 1-of-N encoding 低很多</li>
</ul>
<h2 id="3-Training-的两种方法"><a href="#3-Training-的两种方法" class="headerlink" title="3. Training 的两种方法"></a>3. Training 的两种方法</h2><h3 id="3-1-Count-based"><a href="#3-1-Count-based" class="headerlink" title="3.1 Count-based"></a>3.1 Count-based</h3><p>通过计算 co-occurence frequency，并计算两个 vector 的 dot product，使其与 frequency 相似</p>
<p><img src="/2020/01/04/NLP/word_embedding/word_emb_1.png" alt="word_embedding"></p>
<h3 id="3-2-Count-based-的代表"><a href="#3-2-Count-based-的代表" class="headerlink" title="3.2 Count-based 的代表"></a>3.2 Count-based 的代表</h3><h4 id="3-2-1-LSA-Latent-Semantic-Analysis"><a href="#3-2-1-LSA-Latent-Semantic-Analysis" class="headerlink" title="3.2.1 LSA(Latent Semantic Analysis)"></a>3.2.1 LSA(Latent Semantic Analysis)</h4><h4 id="3-2-2-word2vec"><a href="#3-2-2-word2vec" class="headerlink" title="3.2.2 word2vec"></a>3.2.2 word2vec</h4><h4 id="3-2-3-GloVe-Global-Vectors-for-word-representation"><a href="#3-2-3-GloVe-Global-Vectors-for-word-representation" class="headerlink" title="3.2.3 GloVe(Global Vectors for word representation)"></a>3.2.3 GloVe(Global Vectors for word representation)</h4><p><em>参考：<a href="http://www.fanyeong.com/2018/02/19/glove-in-detail/" target="_blank" rel="noopener">http://www.fanyeong.com/2018/02/19/glove-in-detail/</a></em></p>
<blockquote>
<p>它是一个基于 <code>全局词频统计</code> 的词表征（word representation）工具，它可以把一个单词表达成一个由实数组成的向量，这些向量捕捉到了单词之间的语义特性，比如：相似性（similarity）、类比性（analogy）等。我们通过对向量的运算，比如欧式距离或cosine相似度，可以计算出两个单词之间的语义相似性。</p>
</blockquote>
<h3 id="3-2-Prediction-based"><a href="#3-2-Prediction-based" class="headerlink" title="3.2 Prediction-based"></a>3.2 Prediction-based</h3><p>基于 prediction 的方法，通过学习上下文的信息来预测下一个输出，来保证下一个输出相同的输入具有相似的 input vector</p>
<p><img src="/2020/01/04/NLP/word_embedding/word_emb_2.png" alt="word_embedding"></p>
<p><img src="/2020/01/04/NLP/word_embedding/word_emb_3.png" alt="word_embedding"></p>
<p>上述只是考虑到了前一个词汇的 vector 输入，当输入扩展到 n 的时候，采取的方法是将 weight metrix 强制相等</p>
<p><img src="/2020/01/04/NLP/word_embedding/word_emb_4.png" alt="word_embedding"></p>
<ul>
<li>如何保证 weight metrix 是相等的呢？</li>
</ul>
<p>保证每次 weight update 的时候减去相同的分量</p>
<p><img src="/2020/01/04/NLP/word_embedding/word_emb_5.png" alt="word_embedding"></p>
<h3 id="3-3-Prediction-based-–-Various-Architecture"><a href="#3-3-Prediction-based-–-Various-Architecture" class="headerlink" title="3.3 Prediction-based – Various Architecture"></a>3.3 Prediction-based – Various Architecture</h3><ul>
<li>CBOW(Continuous bag of word)</li>
<li>Skip-gram</li>
</ul>
<p><img src="/2020/01/04/NLP/word_embedding/word_emb_6.png" alt="word_embedding"></p>
<h3 id="3-4-Word-Embedding-的-hidden-layer-为什么不是-deep-的"><a href="#3-4-Word-Embedding-的-hidden-layer-为什么不是-deep-的" class="headerlink" title="3.4 Word Embedding 的 hidden layer 为什么不是 deep 的"></a>3.4 Word Embedding 的 hidden layer 为什么不是 deep 的</h3><p>Tomas Mikolov</p>
<blockquote>
<p>word embeeding是个很早的概念，以前也是 deep 的做法，但是效果并不太好，Tomas 使用很多 trick ，并采用单个 hidden layer 的做法将效果训练的很好</p>
</blockquote>
<h3 id="3-5-word-vector的一些有趣的东西"><a href="#3-5-word-vector的一些有趣的东西" class="headerlink" title="3.5 word vector的一些有趣的东西"></a>3.5 word vector的一些有趣的东西</h3><p><img src="/2020/01/04/NLP/word_embedding/word_emb_7.png" alt="word_embedding"></p>
<p><img src="/2020/01/04/NLP/word_embedding/word_emb_8.png" alt="word_embedding"></p>
<p><img src="/2020/01/04/NLP/word_embedding/word_emb_9.png" alt="word_embedding"></p>
<h3 id="3-Document-embedding"><a href="#3-Document-embedding" class="headerlink" title="3. Document embedding"></a>3. Document embedding</h3><p><img src="/2020/01/04/NLP/word_embedding/word_emb_11.png" alt="document-embedding"></p>
<p>一种直观的想法是使用 Bag-of-word 的思路，将 word ebedding 组成 document 的 semantic，word 的位置信息也很重要</p>
<p><img src="/2020/01/04/NLP/word_embedding/word_emb_12.png" alt="word_embedding"></p>
<p><img src="/2020/01/04/NLP/word_embedding/word_emb_13.png" alt="word_embedding"></p>
<p><img src="/2020/01/04/NLP/word_embedding/word_emb_14.png" alt="word_embedding"></p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>常用自然语言处理工具包</title>
    <url>/2019/12/10/NLP/%E5%B8%B8%E7%94%A8%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%E5%8C%85/</url>
    <content><![CDATA[<h1 id="常用自然语言处理工具包"><a href="#常用自然语言处理工具包" class="headerlink" title="常用自然语言处理工具包"></a>常用自然语言处理工具包</h1><h2 id="stanford-corenlp"><a href="#stanford-corenlp" class="headerlink" title="stanford corenlp"></a>stanford corenlp</h2><p>由 stanford nlp 小组开发，包括多种工具集：</p>
<h3 id="function"><a href="#function" class="headerlink" title="function"></a>function</h3><ul>
<li>the part-of-speech tagger(POS)</li>
<li>the named entity recognizer(NER)</li>
<li>the parser</li>
<li>the coreference resolution system</li>
<li>sentiment analysis</li>
<li>bootstrapped pattern learning</li>
<li>open information extraction</li>
</ul>
<h3 id="language"><a href="#language" class="headerlink" title="language"></a>language</h3><ul>
<li>English</li>
<li>Arabic</li>
<li>Chinese</li>
</ul>
<h3 id="code-language"><a href="#code-language" class="headerlink" title="code language"></a>code language</h3><ul>
<li>dev language: <code>java</code></li>
<li>available language: <code>java</code> <code>python</code></li>
</ul>
<h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><ol>
<li>主页：<a href="https://stanfordnlp.github.io/CoreNLP/" target="_blank" rel="noopener">https://stanfordnlp.github.io/CoreNLP/</a></li>
<li>demo online: <a href="http://corenlp.run/" target="_blank" rel="noopener">http://corenlp.run/</a></li>
<li>详细模块：<a href="https://nlp.stanford.edu/software/" target="_blank" rel="noopener">https://nlp.stanford.edu/software/</a></li>
</ol>
<h2 id="Jieba-分词"><a href="#Jieba-分词" class="headerlink" title="Jieba 分词"></a>Jieba 分词</h2><h2 id="NLTK"><a href="#NLTK" class="headerlink" title="NLTK"></a>NLTK</h2><h2 id="Hanlp"><a href="#Hanlp" class="headerlink" title="Hanlp"></a>Hanlp</h2><h3 id="function-1"><a href="#function-1" class="headerlink" title="function"></a>function</h3><ul>
<li>中文分词</li>
<li>词性标注</li>
<li>命名实体识别</li>
<li>关键词提取</li>
<li>依存句法分析</li>
<li>自动摘要</li>
<li>文本聚类</li>
<li>情感分析</li>
</ul>
<h3 id="language-1"><a href="#language-1" class="headerlink" title="language"></a>language</h3><p>中文</p>
<h3 id="code-language-1"><a href="#code-language-1" class="headerlink" title="code language"></a>code language</h3><ul>
<li>dev language: <code>java</code></li>
<li>available language: <code>java</code> <code>python</code></li>
</ul>
<h3 id="reference-1"><a href="#reference-1" class="headerlink" title="reference"></a>reference</h3><ol>
<li>git repo: <a href="https://github.com/hankcs/HanLP" target="_blank" rel="noopener">https://github.com/hankcs/HanLP</a></li>
<li>配套书籍：《自然语言处理入门》</li>
</ol>
<h2 id="LTP-Language-Technology-Platform-哈工大"><a href="#LTP-Language-Technology-Platform-哈工大" class="headerlink" title="LTP(Language Technology Platform)哈工大"></a>LTP(Language Technology Platform)哈工大</h2><h3 id="funtion"><a href="#funtion" class="headerlink" title="funtion"></a>funtion</h3><ul>
<li>中文分词</li>
<li>词性标注</li>
<li>命名实体识别</li>
<li>依存句法分析</li>
<li>语义角色标注</li>
</ul>
<h3 id="language-2"><a href="#language-2" class="headerlink" title="language"></a>language</h3><p>中文</p>
<h3 id="code-language-2"><a href="#code-language-2" class="headerlink" title="code language"></a>code language</h3><ul>
<li>dev language: <code>C++</code></li>
<li>available language: <code>C++</code> <code>java</code> <code>python</code></li>
</ul>
<h3 id="reference-2"><a href="#reference-2" class="headerlink" title="reference"></a>reference</h3><ol>
<li>git repo: <a href="https://github.com/HIT-SCIR/ltp" target="_blank" rel="noopener">https://github.com/HIT-SCIR/ltp</a></li>
<li>主页：<a href="http://ltp.ai/" target="_blank" rel="noopener">http://ltp.ai/</a></li>
</ol>
<h2 id="复旦NLP-FNLP-–-gt-fastNLP"><a href="#复旦NLP-FNLP-–-gt-fastNLP" class="headerlink" title="复旦NLP(FNLP) –&gt; fastNLP"></a>复旦NLP(FNLP) –&gt; fastNLP</h2><h3 id="function-2"><a href="#function-2" class="headerlink" title="function"></a>function</h3><ul>
<li>中文分词</li>
<li>词性标注</li>
<li>命名实体识别</li>
<li>依存句法分析</li>
<li>文本聚类</li>
</ul>
<h3 id="language-3"><a href="#language-3" class="headerlink" title="language"></a>language</h3><p>中文</p>
<h3 id="code-language-3"><a href="#code-language-3" class="headerlink" title="code language"></a>code language</h3><ul>
<li>dev language: <code>java</code></li>
<li>available language: <code>java</code> </li>
</ul>
<h3 id="reference-3"><a href="#reference-3" class="headerlink" title="reference"></a>reference</h3><ol>
<li>git repo: <a href="https://github.com/FudanNLP/fnlp" target="_blank" rel="noopener">https://github.com/FudanNLP/fnlp</a></li>
<li>fastnlp: <a href="https://github.com/fastnlp/fastNLP" target="_blank" rel="noopener">https://github.com/fastnlp/fastNLP</a></li>
</ol>
<h2 id="清华（ThuLAC）"><a href="#清华（ThuLAC）" class="headerlink" title="清华（ThuLAC）"></a>清华（ThuLAC）</h2><h3 id="function-3"><a href="#function-3" class="headerlink" title="function"></a>function</h3><ul>
<li>中文分词</li>
<li>词性标注</li>
</ul>
<h3 id="language-4"><a href="#language-4" class="headerlink" title="language"></a>language</h3><p>中文</p>
<h3 id="code-language-4"><a href="#code-language-4" class="headerlink" title="code language"></a>code language</h3><ul>
<li>dev language: <code>C++</code></li>
<li>available language: <code>C++</code> <code>java</code> <code>python</code></li>
</ul>
<h3 id="reference-4"><a href="#reference-4" class="headerlink" title="reference"></a>reference</h3><ol>
<li>git repo: <a href="https://github.com/thunlp/THULAC" target="_blank" rel="noopener">https://github.com/thunlp/THULAC</a></li>
</ol>
<h2 id="中科院（NLPIR）原ICTCLAS"><a href="#中科院（NLPIR）原ICTCLAS" class="headerlink" title="中科院（NLPIR）原ICTCLAS"></a>中科院（NLPIR）原ICTCLAS</h2><h3 id="function-4"><a href="#function-4" class="headerlink" title="function"></a>function</h3><h3 id="language-5"><a href="#language-5" class="headerlink" title="language"></a>language</h3><h3 id="code-language-5"><a href="#code-language-5" class="headerlink" title="code language"></a>code language</h3><h3 id="reference-5"><a href="#reference-5" class="headerlink" title="reference"></a>reference</h3><ol>
<li>git repo: <a href="https://github.com/NLPIR-team/NLPIR" target="_blank" rel="noopener">https://github.com/NLPIR-team/NLPIR</a></li>
<li>主页：<a href="http://ictclas.nlpir.org/" target="_blank" rel="noopener">http://ictclas.nlpir.org/</a></li>
</ol>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>文本相似度检测</title>
    <url>/2019/12/31/NLP/%E6%96%87%E6%9C%AC%E7%9B%B8%E4%BC%BC%E5%BA%A6%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>文本数据预处理</title>
    <url>/2019/11/21/NLP/%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>文本数据的预处理根据语种而有些不同，如：</p>
<ul>
<li>中文数据的文本预处理过程：分词、去停用词 …</li>
<li>英文数据的文本预处理过程：分词、去停用词、<strong>提取词干</strong> …</li>
</ul>
<h2 id="1-中文数据的预处理"><a href="#1-中文数据的预处理" class="headerlink" title="1. 中文数据的预处理"></a>1. 中文数据的预处理</h2><p>1.1 统计词频的几种方法：</p>
<h2 id="sklearn-feature-extraction-text"><a href="#sklearn-feature-extraction-text" class="headerlink" title="sklearn.feature_extraction.text"></a>sklearn.feature_extraction.text</h2><p>使用 <code>sklearn</code> 的包有两种统计词频的方法，第一种方法使用 wordcount，第二种方法则使用 TF-IDF方法</p>
<ul>
<li><code>CountVectorizer</code></li>
</ul>
<p><code>CountVectorizer</code> 统计词频后会将其表示成二维矩阵的形式，（i, j）代表 j 列所代表的的词在 i 文档中的词频，使用方式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">vectorizer = CountVectorizer()</span><br><span class="line">X = vectorizer.fit_transform(corpus)            <span class="comment"># 输出形式：（i，j） count</span></span><br><span class="line">feature_name = vectorizer.get_feature_name()    <span class="comment"># 输出形式为 词列表</span></span><br><span class="line">X.toarray()                                     <span class="comment"># 输出形式为 矩阵</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>TfidfTransformer</code></li>
</ul>
<p><code>TfidfTransformer</code> 可对 <code>CountVectorizer</code> 向量化后的数据进行 TF-IDF 的计算，给出 TF-IDF 值，使用方式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">transformer = TfidfTransformer()</span><br><span class="line">tfidf = transformer.fit_transform(vectorizer.fit_transform(corpus))</span><br></pre></td></tr></table></figure>

<ul>
<li><code>TfidfVectorizer</code></li>
</ul>
<p><code>TfidfVectorizer</code> = <code>CountVectorizer</code> + <code>TfidfTransformer</code>， 使用方式为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tfidf2 = TfidfVectorizer()</span><br><span class="line">re = tfidf2.fit_transform(corpus)</span><br></pre></td></tr></table></figure>

<h2 id="2-英文数据的预处理"><a href="#2-英文数据的预处理" class="headerlink" title="2. 英文数据的预处理"></a>2. 英文数据的预处理</h2><h3 id="2-1-Sentence-Tokenization"><a href="#2-1-Sentence-Tokenization" class="headerlink" title="2.1 Sentence Tokenization"></a>2.1 Sentence Tokenization</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = <span class="string">"Backgammon is one of the oldest known board games. Its history can be traced back nearly 5,000 years to archeological discoveries in the Middle East. It is a two player game where each player has fifteen checkers which move between twenty-four points according to the roll of two dice."</span></span><br><span class="line">sentences = nltk.sent_tokenize(text)</span><br><span class="line"><span class="keyword">for</span> sentence <span class="keyword">in</span> sentences:</span><br><span class="line">    print(sentence)</span><br><span class="line">    print()</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<p>Backgammon is one of the oldest known board games.</p>
<p>Its history can be traced back nearly 5,000 years to archeological discoveries in the Middle East.</p>
<p>It is a two player game where each player has fifteen checkers which move between twenty-four points according to the roll of two dice.</p>
<h3 id="2-2-Word-Tokenization"><a href="#2-2-Word-Tokenization" class="headerlink" title="2.2 Word Tokenization"></a>2.2 Word Tokenization</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> sentence <span class="keyword">in</span> sentences:</span><br><span class="line">    words = nltk.word_tokenize(sentence)</span><br><span class="line">    print(words)</span><br><span class="line">    print()</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<p>[‘Backgammon’, ‘is’, ‘one’, ‘of’, ‘the’, ‘oldest’, ‘known’, ‘board’, ‘games’, ‘.’]</p>
<p>[‘Its’, ‘history’, ‘can’, ‘be’, ‘traced’, ‘back’, ‘nearly’, ‘5,000’, ‘years’, ‘to’, ‘archeological’, ‘discoveries’, ‘in’, ‘the’, ‘Middle’, ‘East’, ‘.’]</p>
<p>[‘It’, ‘is’, ‘a’, ‘two’, ‘player’, ‘game’, ‘where’, ‘each’, ‘player’, ‘has’, ‘fifteen’, ‘checkers’, ‘which’, ‘move’, ‘between’, ‘twenty-four’, ‘points’, ‘according’, ‘to’, ‘the’, ‘roll’, ‘of’, ‘two’, ‘dice’, ‘.’]</p>
<h3 id="2-3-Text-Lemmatization-and-Stemming"><a href="#2-3-Text-Lemmatization-and-Stemming" class="headerlink" title="2.3 Text Lemmatization and Stemming"></a>2.3 Text Lemmatization and Stemming</h3><p>For grammatical reasons, documents can contain different forms of a word such as drive, drives, driving. Also, sometimes we have related words with a similar meaning, such as nation, national, nationality.</p>
<p><strong>The goal of both stemming and lemmatization is to reduce inflectional forms and sometimes derivationally related forms of a word to a common base form.</strong></p>
<p>Source: <a href="https://nlp.stanford.edu/IR-book/html/htmledition/stemming-and-lemmatization-1.html" target="_blank" rel="noopener">https://nlp.stanford.edu/IR-book/html/htmledition/stemming-and-lemmatization-1.html</a></p>
<p>Examples:</p>
<ul>
<li>am, are, is =&gt; be</li>
<li>dog, dogs, dog’s, dogs’ =&gt; dog</li>
</ul>
<p>The result of this mapping applied on a text will be something like that:<br><em>the boy’s dogs are different sizes =&gt; the boy dog be differ size</em><br>Stemming and lemmatization are special cases of normalization. However, they are different from each other.</p>
<blockquote>
<p>Stemming usually refers to a crude heuristic process that chops off the ends of words in the hope of achieving this goal correctly most of the time, and often includes the removal of derivational affixes.<br>Lemmatization usually refers to doing things properly with the use of a vocabulary and morphological analysis of words, normally aiming to remove inflectional endings only and to return the base or dictionary form of a word, which is known as the lemma.</p>
</blockquote>
<p>Source: <a href="https://nlp.stanford.edu/IR-book/html/htmledition/stemming-and-lemmatization-1.html" target="_blank" rel="noopener">https://nlp.stanford.edu/IR-book/html/htmledition/stemming-and-lemmatization-1.html</a></p>
<p>The difference is that a stemmer operates <strong>without knowledge of the context</strong>, and therefore cannot understand the difference between words which have different meaning depending on part of speech. But the stemmers also have some advantages, they are easier to implement and usually run faster. Also, the reduced “accuracy” may not matter for some applications.</p>
<p>Examples:</p>
<ol>
<li>The word “better” has “good” as its lemma. This link is missed by stemming, as it requires a dictionary look-up.</li>
<li>The word “play” is the base form for the word “playing”, and hence this is matched in both stemming and lemmatization.</li>
<li>The word “meeting” can be either the base form of a noun or a form of a verb (“to meet”) depending on the context; e.g., “in our last meeting” or “We are meeting again tomorrow”. Unlike stemming, lemmatization attempts to select the correct lemma depending on the context.</li>
</ol>
<p>After we know what’s the difference, let’s see some examples using the NLTK tool.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> nltk.stem <span class="keyword">import</span> PorterStemmer, WordNetLemmatizer</span><br><span class="line"><span class="keyword">from</span> nltk.corpus <span class="keyword">import</span> wordnet</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare_stemmer_and_lemmatizer</span><span class="params">(stemmer, lemmatizer, word, pos)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Print the results of stemmind and lemmitization using the passed stemmer, lemmatizer, word and pos (part of speech)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">"Stemmer:"</span>, stemmer.stem(word))</span><br><span class="line">    print(<span class="string">"Lemmatizer:"</span>, lemmatizer.lemmatize(word, pos))</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line">lemmatizer = WordNetLemmatizer()</span><br><span class="line">stemmer = PorterStemmer()</span><br><span class="line">compare_stemmer_and_lemmatizer(stemmer, lemmatizer, word = <span class="string">"seen"</span>, pos = wordnet.VERB)</span><br><span class="line">compare_stemmer_and_lemmatizer(stemmer, lemmatizer, word = <span class="string">"drove"</span>, pos = wordnet.VERB)</span><br></pre></td></tr></table></figure>
<p>Output:  </p>
<p>Stemmer: seen<br>Lemmatizer: see</p>
<p>Stemmer: drove<br>Lemmatizer: drive  </p>
<h3 id="2-4-Stop-words"><a href="#2-4-Stop-words" class="headerlink" title="2.4 Stop words"></a>2.4 Stop words</h3><p>The NLTK tool has a predefined list of stopwords that refers to the most common words. If you use it for your first time, you need to download the stop words using this code: <code>nltk.download(“stopwords”)</code>. Once we complete the downloading, we can load the stopwords package from the nltk.corpus and use it to load the stop words.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> nltk.corpus <span class="keyword">import</span> stopwords</span><br><span class="line">print(stopwords.words(<span class="string">"english"</span>))</span><br></pre></td></tr></table></figure>

<p>outputs:<br>…</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stop_words = set(stopwords.words(<span class="string">"english"</span>))</span><br><span class="line">sentence = <span class="string">"Backgammon is one of the oldest known board games."</span></span><br><span class="line"></span><br><span class="line">words = nltk.word_tokenize(sentence)</span><br><span class="line">without_stop_words = [word <span class="keyword">for</span> word <span class="keyword">in</span> words <span class="keyword">if</span> <span class="keyword">not</span> word <span class="keyword">in</span> stop_words]</span><br><span class="line">print(without_stop_words)</span><br></pre></td></tr></table></figure>

<p>outputs:</p>
<p>[‘Backgammon’, ‘one’, ‘oldest’, ‘known’, ‘board’, ‘games’, ‘.’]</p>
<h3 id="2-5-Bag-of-words"><a href="#2-5-Bag-of-words" class="headerlink" title="2.5 Bag-of-words"></a>2.5 Bag-of-words</h3><h3 id="2-6-Tools"><a href="#2-6-Tools" class="headerlink" title="2.6 Tools"></a>2.6 Tools</h3><ul>
<li><p><code>nltk</code> for pre-processing texts</p>
</li>
<li><p><code>sklearn</code> for bag-of-words models</p>
</li>
</ul>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><ul>
<li>无论采用何种对非结构化文档向量化的 BoW 方法，均是通过 <code>dictionary</code> 与 <code>Sparse Matrix</code>两者结合的方式来展示，<code>Sparse Matrix</code> = <code>Sparse dictionary index matrix</code></li>
</ul>
<h2 id="4-学习参考"><a href="#4-学习参考" class="headerlink" title="4. 学习参考"></a>4. 学习参考</h2><ul>
<li><a href="https://machinelearningmastery.com/clean-text-machine-learning-python/" target="_blank" rel="noopener">https://machinelearningmastery.com/clean-text-machine-learning-python/</a></li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title>README</title>
    <url>/2019/11/08/OperatingSystem/README/</url>
    <content><![CDATA[<h1 id="Operating-System"><a href="#Operating-System" class="headerlink" title="Operating System"></a>Operating System</h1><p>10/2017</p>
<p>最近在学习操作系统，这里主要写一下自己在看书看视频时的一些思考；  </p>
<p>参考教材：《操作系统概念》《UNIX环境高级编程》<br>参考视频： 浙江大学 李善平 《操作系统原理》</p>
]]></content>
      <categories>
        <category>OperatingSystem</category>
      </categories>
      <tags>
        <tag>OperatingSystem</tag>
      </tags>
  </entry>
  <entry>
    <title>SystemCall</title>
    <url>/2020/01/05/OperatingSystem/SystemCall/</url>
    <content><![CDATA[<h1 id="system-call（系统调用）"><a href="#system-call（系统调用）" class="headerlink" title="system call（系统调用）"></a>system call（系统调用）</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>系统调用往往是对一些内核函数的封装，函数实现在内核态，往往由C/C++编写，当涉及到对硬件进行操作时由汇编语言编写；<br>系统调用在内核实现，在C/C++函数库里进行封装成API，当然用户程序也可以直接调用系统调用。  </p>
<p>关于系统调用，API，内核函数，库函数的关系:<br><img src="/2020/01/05/OperatingSystem/SystemCall/systemcall1.png" alt="关系图"></p>
<h2 id="系统调用类别："><a href="#系统调用类别：" class="headerlink" title="系统调用类别："></a>系统调用类别：</h2><ul>
<li>进程控制：对进程的一些操作；</li>
<li>文件管理：对文件的一些操作；</li>
<li>设备管理：对设备的一些操作；</li>
<li>信息维护：读取一些系统数据，进程信息，时间等信息；</li>
<li>通信：进程间通信的实现，如Soket。</li>
</ul>
<h2 id="系统调用的实现机制"><a href="#系统调用的实现机制" class="headerlink" title="系统调用的实现机制"></a>系统调用的实现机制</h2><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>1.中断/异常机制：支持系统调用服务的实现<br>2.选择一条特殊指令：陷入指令（访管指令）：引发异常，用户态–&gt;内核态切换<br>3.系统调用号和参数：每个系统调用都事先给定一个编号（功能号）<br>4.系统调用表：存放系统调用服务例程的入口地址   </p>
<h3 id="参数传递问题"><a href="#参数传递问题" class="headerlink" title="参数传递问题"></a>参数传递问题</h3><p><strong>用户态如何实现传递参数到内核态？</strong>   </p>
<ul>
<li>由陷入指令自带参数  </li>
<li>通过通用寄存器传递参数  </li>
<li>在内存中开辟专用堆栈区（带有共享内存的意味）<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><img src="/2020/01/05/OperatingSystem/SystemCall/systemcall2.png" alt=""></li>
</ul>
<h2 id="系统调用的执行过程"><a href="#系统调用的执行过程" class="headerlink" title="系统调用的执行过程"></a>系统调用的执行过程</h2><p><img src="/2020/01/05/OperatingSystem/SystemCall/systemcall3.png" alt=""></p>
<p><img src="/2020/01/05/OperatingSystem/SystemCall/systemcall4.png" alt=""></p>
<p>（图片为看mooc时截屏照片，仅供学习，侵即删）</p>
]]></content>
      <categories>
        <category>OperatingSystem</category>
      </categories>
      <tags>
        <tag>OperatingSystem</tag>
      </tags>
  </entry>
  <entry>
    <title>classic_problems</title>
    <url>/2019/11/08/OperatingSystem/classic_problems/</url>
    <content><![CDATA[<h1 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h1><p>抄一下代码，想一下idea</p>
<h2 id="Producer-Consumer-problem（生产者-消费者问题）"><a href="#Producer-Consumer-problem（生产者-消费者问题）" class="headerlink" title="Producer-Consumer problem（生产者-消费者问题）"></a>Producer-Consumer problem（生产者-消费者问题）</h2><p>又名有界缓冲区问题  </p>
<p>原则：  </p>
<ul>
<li>缓冲区有界  </li>
<li>同步，互斥读写  </li>
</ul>
<p>解决方式：  </p>
<ul>
<li>semaphore mutex 初值为1，互斥信号量  </li>
<li>semaphore full,empty full初值为0，empty初值为n，计数信号量  </li>
</ul>
<p><strong>备注：</strong>解决互斥问题并不是Dijkstra大神的初心，毕竟这用“关中”也可以实现，这带来的还有避免了空操作；  </p>
<p>实现：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Producer:</span><br><span class="line">do &#123;</span><br><span class="line"></span><br><span class="line">  //produce product</span><br><span class="line">  </span><br><span class="line">  wait(empty);</span><br><span class="line">  wait(mutex);</span><br><span class="line">  </span><br><span class="line">  //add product into buffer</span><br><span class="line">  </span><br><span class="line">  signal(mutex);</span><br><span class="line">  signal(full);</span><br><span class="line">  </span><br><span class="line">&#125;while(TRUE);</span><br><span class="line"></span><br><span class="line">Consumer:</span><br><span class="line">do &#123;</span><br><span class="line">  wait(full);</span><br><span class="line">  wait(mutex);</span><br><span class="line">  </span><br><span class="line">  //remove product from buffer</span><br><span class="line">  </span><br><span class="line">  signal(mutex);</span><br><span class="line">  signal(empty);</span><br><span class="line">  </span><br><span class="line">  //consume product</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Readers-Writers-Problem（读者-写者问题）"><a href="#Readers-Writers-Problem（读者-写者问题）" class="headerlink" title="Readers-Writers Problem（读者-写者问题）"></a>Readers-Writers Problem（读者-写者问题）</h2><p>原则：  </p>
<ul>
<li>多进程可同时读，单进程可写  </li>
<li>读写进程互斥  </li>
<li>避免出现读/写进程饥饿  </li>
</ul>
<p>解决方式：  </p>
<ul>
<li>semaphore mutex,wrt 初值为1，mutex保护readercount，wrt保护共享数据  </li>
<li>int readercount 初值为0，表示读进程个数  </li>
</ul>
<p>实现：   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Writer:</span><br><span class="line">do &#123; </span><br><span class="line">  wait(wrt);</span><br><span class="line">  </span><br><span class="line">  //writing is performed  </span><br><span class="line">  </span><br><span class="line">  signal(wrt);</span><br><span class="line">&#125;while(TRUE);</span><br><span class="line"></span><br><span class="line">Reader:</span><br><span class="line">do &#123;</span><br><span class="line">  wait(mutex);</span><br><span class="line">  readercount ++;</span><br><span class="line">  if(readercount == 1)          //当是第一个要读的进程时申请wrt；若非第一个读的，直接进入</span><br><span class="line">    wait(wrt);</span><br><span class="line">  signal(mutex);</span><br><span class="line">  </span><br><span class="line">  //reading is performed</span><br><span class="line">  </span><br><span class="line">  wait(mutex);</span><br><span class="line">  readercount --;</span><br><span class="line">  if(readercount == 0)          //当是最后一个要离开的进程时释放wrt；若非最后一个，直接离开</span><br><span class="line">    signal(wrt);</span><br><span class="line">  signal(mutex);</span><br><span class="line">&#125;while(TRUE);</span><br></pre></td></tr></table></figure>
<p><strong>当然了，这并没有解决饥饿问题(starvation)，很明显会造成Writer进程饥饿</strong>  </p>
]]></content>
      <categories>
        <category>OperatingSystem</category>
      </categories>
      <tags>
        <tag>OperatingSystem</tag>
      </tags>
  </entry>
  <entry>
    <title>processSynchronization</title>
    <url>/2019/11/08/OperatingSystem/processSynchronization/</url>
    <content><![CDATA[<h1 id="进程同步的一些算法"><a href="#进程同步的一些算法" class="headerlink" title="进程同步的一些算法"></a>进程同步的一些算法</h1><p>这些算法主要用于解决<strong>临界区问题</strong><br>所谓临界区，即对共享数据访问与操作的代码，主要要求是最多只有一个进程在临界区内  </p>
<p>临界区问题的解答需要满足以下三点需求：  </p>
<blockquote>
<ul>
<li>互斥(mutual exclusion)</li>
<li>前进“空闲可进”(progress)  </li>
<li>有限等待(bounded waiting)</li>
</ul>
</blockquote>
<p>下面是软件实现的几种算法： </p>
<h2 id="Peterson算法（仅限于2个进程）"><a href="#Peterson算法（仅限于2个进程）" class="headerlink" title="Peterson算法（仅限于2个进程）"></a>Peterson算法（仅限于2个进程）</h2><p><strong>采用共享数据 turn,flag 来实现 预约与轮转 的算法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    flag[i] = TRUE;           //flag[i]=TRUE 表示i想进入临界区</span><br><span class="line">    turn = j;                 //turn 表示哪一个 可以进入临界区</span><br><span class="line">    while(flag[j]&amp;&amp;turn == j);</span><br><span class="line">    </span><br><span class="line">    临界区  </span><br><span class="line">    </span><br><span class="line">    flag[i] = FALSE;</span><br><span class="line">     </span><br><span class="line">    剩余区  </span><br><span class="line">    </span><br><span class="line">    &#125;while(TRUE);</span><br></pre></td></tr></table></figure>
<p>注解：</p>
<blockquote>
<ul>
<li>当若只包含turn则只能满足条件1，互斥进入，存在问题2，有空闲不让进情况  </li>
<li>flag 主要用于解决条件2，让想进入临界区的有限次等待可以进入</li>
</ul>
</blockquote>
<h2 id="面包店算法-（可用于n个进程）"><a href="#面包店算法-（可用于n个进程）" class="headerlink" title="面包店算法 （可用于n个进程）"></a>面包店算法 （可用于n个进程）</h2><p><strong>类似面包店取号</strong></p>
<blockquote>
<ul>
<li>choosing = TRUE 表示开始取号</li>
<li>number[i]  表示取得的号码  </li>
<li>number最小的进入临界区</li>
<li>(number[j],j)&lt;(number[i],i) 若number[j]&lt;number[i]则返回1；若number[j]==number[i]&amp;&amp;j&lt;i则返回1</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    choosing[i] = TRUE;                                           //开始取号码</span><br><span class="line">    number[i] = MAX&#123;number[0],number[1]...number[i-1]&#125; + 1；      //取号码</span><br><span class="line">    choosing[i] = FALSE;                                          //取号结束</span><br><span class="line">     </span><br><span class="line">    for(j=0;j&lt;i;j++) &#123;</span><br><span class="line">      while(choosing[j]);                                         //碰到有正在取号的则等待，若无choosing，还是会出现一些问题</span><br><span class="line">      while((number[j] != 0)&amp;&amp;((number[j],j)&lt;(number[i],i)));     //碰到比自己号码小的想要进入的则等待</span><br><span class="line">      &#125;</span><br><span class="line">     </span><br><span class="line">     临界区  </span><br><span class="line">     </span><br><span class="line">     number[i] = 0;                                               //重新置号</span><br><span class="line">     </span><br><span class="line">     剩余区  </span><br><span class="line">     </span><br><span class="line">&#125;while(TRUE);</span><br></pre></td></tr></table></figure>

<p>下面是一些总结： <strong>预约+互斥</strong><br>两者相同点：</p>
<blockquote>
<ul>
<li>存在一个预约机制(flag &amp; number)，即保证条件3能够满足</li>
<li>在对共享数据进行操作时都特别小心(flag,number[n])因为临界区问题的源头在这里 </li>
<li>在进入临界区检查时，都用while()检查其它进程有没有满足条件，若有，空操作；若无，进入；（进程之间应该谦让）</li>
<li>出了临界区之后，立即对自己的预约进行消除(flag[i] = FALSE,number[i] = 0)</li>
</ul>
</blockquote>
<p>两者不同点：</p>
<blockquote>
<ul>
<li>互斥的实现：前者通过turn，后者通过number的大小比较来实现</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>OperatingSystem</category>
      </categories>
      <tags>
        <tag>OperatingSystem</tag>
      </tags>
  </entry>
  <entry>
    <title>virtualization</title>
    <url>/2019/12/02/OperatingSystem/virtualization/</url>
    <content><![CDATA[<h1 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>OperatingSystem</category>
      </categories>
      <tags>
        <tag>OperatingSystem</tag>
      </tags>
  </entry>
  <entry>
    <title>BeautifulSoup 教程</title>
    <url>/2020/04/28/Python/BeautifulSoup/</url>
    <content><![CDATA[<h1 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bs4</span><br></pre></td></tr></table></figure>

<h2 id="对象种类"><a href="#对象种类" class="headerlink" title="对象种类"></a>对象种类</h2><ul>
<li><code>bs4.element.Tag</code></li>
<li><code>bs4.element.NavigableString</code> 可遍历的字符串</li>
<li><code>bs4.element.BeautifulSoup</code> 一个文档的全部内容</li>
<li><code>bs4.element.Comment</code> 注释及特殊字符串，是一种特殊类型的 <code>bs4.element.NavigableString</code> 字符串</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>README</title>
    <url>/2019/11/08/Python/README/</url>
    <content><![CDATA[<h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><p>学习python呢，是因为学习爬虫时，用python的库很爽，结果就学了一点皮毛   </p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>enumerate</title>
    <url>/2019/11/14/Python/enumerate/</url>
    <content><![CDATA[<h1 id="enumerate-函数"><a href="#enumerate-函数" class="headerlink" title="enumerate() 函数"></a>enumerate() 函数</h1><p><code>enumerate()</code> 函数将一个可遍历的数据对象（如列表、元组、字符串等）组合成一个索引序列，同时列出数据和数据下标</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;seasons = [<span class="string">'Spring'</span>, <span class="string">'Summer'</span>, <span class="string">'Fall'</span>, <span class="string">'Winter'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(enumerate(seasons))</span><br><span class="line">[(<span class="number">0</span>, <span class="string">'Spring'</span>), (<span class="number">1</span>, <span class="string">'Summer'</span>), (<span class="number">2</span>, <span class="string">'Fall'</span>), (<span class="number">3</span>, <span class="string">'Winter'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(enumerate(seasons, start=<span class="number">1</span>))       <span class="comment"># 下标从 1 开始</span></span><br><span class="line">[(<span class="number">1</span>, <span class="string">'Spring'</span>), (<span class="number">2</span>, <span class="string">'Summer'</span>), (<span class="number">3</span>, <span class="string">'Fall'</span>), (<span class="number">4</span>, <span class="string">'Winter'</span>)]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>semaphore</title>
    <url>/2019/11/08/OperatingSystem/semaphore/</url>
    <content><![CDATA[<h1 id="进程同步之信号量实现-semaphore"><a href="#进程同步之信号量实现-semaphore" class="headerlink" title="进程同步之信号量实现  semaphore"></a>进程同步之信号量实现  semaphore</h1><p>信号量的提出—Dijkstra大神<br>信号量分为  二进制信号量 与 计数信号量<br>操作分为  P操作(waiting) 与 V操作(signal)</p>
<h2 id="二进制信号量-mutex"><a href="#二进制信号量-mutex" class="headerlink" title="二进制信号量 mutex"></a>二进制信号量 mutex</h2><p>二进制信号量主要用于解决 互斥问题  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    waiting(mutex);</span><br><span class="line">    </span><br><span class="line">    //critical section</span><br><span class="line">    </span><br><span class="line">    signal(mutex);</span><br><span class="line">    </span><br><span class="line">    //remainder section</span><br><span class="line">    </span><br><span class="line">&#125;while(TRUE);</span><br></pre></td></tr></table></figure>

<h2 id="计数信号量"><a href="#计数信号量" class="headerlink" title="计数信号量"></a>计数信号量</h2><p>结构  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">  int value;</span><br><span class="line">  struct process *list;</span><br><span class="line">&#125; semaphore;</span><br></pre></td></tr></table></figure>
<p>P,V操作的定义:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wait(semaphore *S) &#123;</span><br><span class="line">  S-&gt;value--;</span><br><span class="line">  if(S-&gt;value &lt; 0) &#123;</span><br><span class="line">  </span><br><span class="line">    //add this process to S-&gt;list</span><br><span class="line">    </span><br><span class="line">    block();   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signal(semaphore *S) &#123;</span><br><span class="line">  S-&gt;value ++ ;</span><br><span class="line">  if(S-&gt;value &lt;= 0) &#123;</span><br><span class="line">    </span><br><span class="line">    //remove a P process from S-&gt;list</span><br><span class="line">    </span><br><span class="line">    wakeup(P);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>信号量的初值</p>
<blockquote>
<ul>
<li>对于一般计数信号量初值一般设置为1</li>
<li>对于同步问题处置一般设置为0 </li>
</ul>
</blockquote>
<p>说一下我的理解：<br>wait(S)操作是用在访问与操作临界区之前，用于申请，或者说测试释放可用，执行-操作；<br>signal(S)操作用于访问与操作临界区之后，对临界区访问权限的释放，或者说发送一个可用信号，执行+操作；</p>
<h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><p><strong>1.wait()signal()位置</strong>   </p>
<p>为了防止出现死锁，一般将wait()与signal()放置在<strong>紧贴</strong>临界区的位置上  </p>
<p><strong>2.S-&gt;list的访问</strong>  </p>
<p><strong>一般使用FIFO</strong>以保证条件3即有限等待次数的实现，当使用其它的访问算法时，可能会违背条件3，<strong>出现饥饿</strong> </p>
<p><strong>3.wait()signal()都属于原子操作</strong></p>
<p>当单cpu情况下可以用“关中”即<strong>关闭中断</strong>的方式来实现<br>当多cpu情况下可以…emmm…反正记住PV都属于Atomic Operations :-) !!!</p>
]]></content>
      <categories>
        <category>OperatingSystem</category>
      </categories>
      <tags>
        <tag>OperatingSystem</tag>
      </tags>
  </entry>
  <entry>
    <title>IO</title>
    <url>/2019/12/13/Python/IO/</url>
    <content><![CDATA[<h1 id="python中的IO"><a href="#python中的IO" class="headerlink" title="python中的IO"></a>python中的IO</h1><h2 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'file.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    content = f.read()  <span class="comment"># 一次性读取所有内容</span></span><br><span class="line">    f.readline()        <span class="comment"># 逐行读取内容</span></span><br><span class="line">    f.readlines()       <span class="comment"># 一次进行逐行读取,返回 list</span></span><br></pre></td></tr></table></figure>

<h2 id="文件操作-os-path"><a href="#文件操作-os-path" class="headerlink" title="文件操作 os.path"></a>文件操作 <code>os.path</code></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_files</span><span class="params">()</span>:</span></span><br><span class="line">    news_file_list = []</span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> os.listdir(data_dir_path):</span><br><span class="line">        <span class="keyword">if</span> os.path.isdir(os.path.join(data_dir_path, d)):</span><br><span class="line">            news_file_list.append(os.path.join(data_dir_path, d, <span class="string">'news.txt'</span>))</span><br><span class="line">    <span class="keyword">return</span> news_file_list</span><br><span class="line"></span><br><span class="line">os.path.dirname()   <span class="comment"># 返回所在的文件夹名称</span></span><br><span class="line">os.path.exists()    <span class="comment"># 判断路径是否存在</span></span><br><span class="line">os.path.abspath()   <span class="comment"># 返回绝对路径</span></span><br><span class="line">os.path.isdir()     <span class="comment"># 判断是否为目录，注：要输入绝对路径</span></span><br><span class="line">os.path.isfile()    <span class="comment"># 判断是否为文件</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化</title>
    <url>/2019/12/13/Python/%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="序列化-Serialize"><a href="#序列化-Serialize" class="headerlink" title="序列化 Serialize"></a>序列化 Serialize</h1><h2 id="json操作"><a href="#json操作" class="headerlink" title="json操作"></a><code>json</code>操作</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">json.loads()        <span class="comment"># 加载json数据</span></span><br><span class="line">json.dumps(nlp_res, sort_keys=<span class="literal">True</span>, indent=<span class="number">4</span>, separators=(<span class="string">', '</span>, <span class="string">': '</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(os.path.join(output_file_dir, <span class="string">'openie.json'</span>), <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json.dump(openie_data, f, indent=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>print_function</title>
    <url>/2019/11/14/Python/print_function/</url>
    <content><![CDATA[<h1 id="Print-Function"><a href="#Print-Function" class="headerlink" title="Print Function"></a>Print Function</h1><p><em>前言：由 Python function 引起的一系列知识点</em></p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>在写 python 代码时，经常需要用到 <code>print</code> 函数进行打印输出，但这种方法带来便利的同时，也会常在调试结束后增加删去相关代码的负担。一个常用的方法是对 <code>print()</code> 包装一层，加入一些 <code>Debug</code> 的关键字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug_print</span><span class="params">(*values, sep=<span class="string">' '</span>, end=<span class="string">'\n'</span>, file=sys.stdout, flush=False)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Print Function for debug</span></span><br><span class="line"><span class="string">    :param values:</span></span><br><span class="line"><span class="string">    :param sep:</span></span><br><span class="line"><span class="string">    :param end:</span></span><br><span class="line"><span class="string">    :param file:</span></span><br><span class="line"><span class="string">    :param flush:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> DEBUG:</span><br><span class="line">        print(*values, sep=sep, end=end, file=file, flush=flush)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>这需要用到的是 <code>print()</code> 的形参列表：<code>print(*values, sep=sep, end=end, file=file, flush=flush)</code>，这里的 <code>*values</code> 前面的 star 代表的意思是什么呢？</p>
<h2 id="2-函数形参"><a href="#2-函数形参" class="headerlink" title="2. 函数形参"></a>2. 函数形参</h2><h3 id="2-1-函数形参中带有1个star"><a href="#2-1-函数形参中带有1个star" class="headerlink" title="2.1 函数形参中带有1个star"></a>2.1 函数形参中带有1个star</h3><p>具体详见：<a href="https://blog.csdn.net/qinyilang/article/details/5484415" target="_blank" rel="noopener">https://blog.csdn.net/qinyilang/article/details/5484415</a></p>
<ol>
<li>函数形参加一个 star：表示可以接受多个参数，这适用于变参数传参的场景：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">sum_</span><span class="params">(*values)</span>:</span>      <span class="comment">#   被包装成 tuple</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    print(values)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    print(sum(*values)) <span class="comment">#   tuple 的解压操作</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># print(sum(*a))</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(sum_(a))</span><br></pre></td></tr></table></figure>
Output:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2]</span><br><span class="line">([1, 2],)</span><br><span class="line">3</span><br><span class="line">None</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>对于这种变参数（即：函数形参中带有 * ），参数被传进函数的时候会被包装成 tuple 的一个参数</strong></p>
<h3 id="2-2-函数形参中带有-2-个-star"><a href="#2-2-函数形参中带有-2-个-star" class="headerlink" title="2.2 函数形参中带有 2 个 star"></a>2.2 函数形参中带有 2 个 star</h3><p>这是一种多关键字参数的场景，传进的参数被包装成 <code>dict</code> 类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">print_</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    print(kwargs)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_(a=<span class="number">3</span>, b=<span class="number">5</span>, c=<span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&apos;a&apos;: 3, &apos;b&apos;: 5, &apos;c&apos;: 6&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>type 与 isinstance</title>
    <url>/2020/04/28/Python/type-isinstance/</url>
    <content><![CDATA[<h1 id="type-与-isinstance-的区别"><a href="#type-与-isinstance-的区别" class="headerlink" title="type 与 isinstance 的区别"></a>type 与 isinstance 的区别</h1><p>我们在判断一个 object 是不是某个类型的时候，常用到 <code>type</code> 与 <code>isinstance</code>；</p>
<p>除已知的：</p>
<ul>
<li><code>type</code> 可以判断未知类型；</li>
<li><code>isinstance</code> 可以用来判断已知类型；</li>
</ul>
<p>另外，<code>isinitance</code> 可以判断是否子类实例对象是否是父类的；</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = A()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = B()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(a) == A</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(b) == B</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(a, A)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(b, A)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>因此要准确判断是否是某种类型，采用 <code>type(a) == A</code> 这种形式较好</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>requests</title>
    <url>/2019/11/08/Python/requests/</url>
    <content><![CDATA[<h1 id="Requests"><a href="#Requests" class="headerlink" title="Requests"></a>Requests</h1><p>python requests模块使用：</p>
<p>官方文档：<a href="http://docs.python-requests.org/zh_CN/latest/user/quickstart.html" target="_blank" rel="noopener">http://docs.python-requests.org/zh_CN/latest/user/quickstart.html</a></p>
<p><code>import requests</code></p>
<h2 id="01-发送请求"><a href="#01-发送请求" class="headerlink" title="01 发送请求"></a>01 发送请求</h2><h3 id="1-1-GET"><a href="#1-1-GET" class="headerlink" title="1.1 GET"></a>1.1 GET</h3><ul>
<li><p>当URL参数不多的时候，可以这样<br><code>requests.get(&#39;http://baidu.com&#39;)</code></p>
</li>
<li><p>当参数多的时候，可以通过一个dic来传递参数，使其自动构造URL</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">paydict = &#123;<span class="string">'key1'</span>:<span class="string">'value1'</span>,<span class="string">'key2'</span>:<span class="string">'value2'</span>&#125;</span><br><span class="line">r = requests.get(<span class="string">'http://baidu.com'</span>,params=paydict<span class="string">')</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-POST"><a href="#1-2-POST" class="headerlink" title="1.2 POST"></a>1.2 POST</h3><h2 id="02-响应内容"><a href="#02-响应内容" class="headerlink" title="02 响应内容"></a>02 响应内容</h2><p><strong>返回值r是Response对象</strong></p>
<ul>
<li><p>r.encoding 编码，这个可以自己设置</p>
</li>
<li><p>r.text 返回文本形式内容</p>
</li>
<li><p>r.content 返回二进制形式内容</p>
</li>
<li><p>r.raw 返回原始内容</p>
</li>
</ul>
<h2 id="03-Misc"><a href="#03-Misc" class="headerlink" title="03 Misc"></a>03 Misc</h2><h3 id="3-1-requests-请求资源的高效利用"><a href="#3-1-requests-请求资源的高效利用" class="headerlink" title="3.1 requests 请求资源的高效利用"></a>3.1 requests 请求资源的高效利用</h3><p>requests 底层是 http，http 底层是 tcp。</p>
<p>遇到一个问题： 当使用爬虫爬取数据，如何在爬取多个 url 时，充分利用资源：</p>
<p>参考：</p>
<ol>
<li><a href="https://stackoverflow.com/questions/10115126/python-requests-close-http-connection" target="_blank" rel="noopener">stackoverflow</a></li>
<li><a href="https://requests.readthedocs.io/zh_CN/latest/user/advanced.html#session-objects" target="_blank" rel="noopener">requests docs</a></li>
<li><a href="https://www.cnblogs.com/gl1573/p/10129382.html" target="_blank" rel="noopener">Python: requests 详解超时和重试</a></li>
</ol>
<p>当在爬虫过程中使用多线程爬取内容时，往往会出现 <code>too many open files</code> 的 error,</p>
<ul>
<li>TCP 在建立连接后，默认会保持一段时间的连接，当我们使用以下代码把网页内容 pull 下来后，我们需要及时关闭连接。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response = requests.get(url, proxies=proxies, headers=headers, timeout=timeout)</span><br><span class="line">response_content = response.content</span><br><span class="line"><span class="comment"># 无论 get/post 方法，均可以使用 close() 关闭连接</span></span><br><span class="line">response.close()</span><br><span class="line"><span class="comment"># 或者使用 with-statement 管理 context</span></span><br><span class="line"><span class="keyword">with</span> requests.get(url, proxies=proxies, headers=headers, timeout=timeout) <span class="keyword">as</span> r:</span><br><span class="line">    response_content = response.content</span><br></pre></td></tr></table></figure>

<ul>
<li>requests 中的 <code>session</code> 对象，可以在一个会话中保持一些请求的参数，借用官方文档：</li>
</ul>
<blockquote>
<p>会话对象让你能够跨请求保持某些参数。它也会在同一个 Session 实例发出的所有请求之间保持 cookie， 期间使用 urllib3 的 connection pooling 功能。所以如果你向同一主机发送多个请求，底层的 TCP 连接将会被重用，从而带来显著的性能提升。 (参见 HTTP persistent connection).</p>
</blockquote>
<p>使用 <code>session</code> 的目的还是利用 <code>session</code> 的 <code>connection pool</code> 功能，可以高效地复用链接。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 with-statement</span></span><br><span class="line"><span class="keyword">with</span> requests.Session() <span class="keyword">as</span> s:</span><br><span class="line">    s.get(<span class="string">'http://example.com/aaa'</span>)</span><br><span class="line">    s.get(<span class="string">'http://example.com/bbb'</span>)</span><br><span class="line">    s.get(<span class="string">'http://example.com/ccc'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或使用 close() 方法</span></span><br><span class="line">s = requests.Session()</span><br><span class="line">s.get(<span class="string">'http://example.com/aaa'</span>)</span><br><span class="line">s.get(<span class="string">'http://example.com/bbb'</span>)</span><br><span class="line">s.get(<span class="string">'http://example.com/ccc'</span>)</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>同时还应该及时清理建立连接较慢和返回较慢的连接，以提高爬虫的效率，主要使用的手段是 <code>timeout</code> 与 <code>max_retries</code></p>
<p>  <code>timeout</code> 应注意其可以为（连接超时，读取超时）：连接超时指建立连接的最大时间，读取超时指收到服务器回复的最大时间，也可单独设置。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_response</span><span class="params">(url, proxies, headers, timeout=<span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span>, max_retries=<span class="number">3</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    存在连接时间较长阻塞的情况，这里设置 timeout, max_retries</span></span><br><span class="line"><span class="string">    :param url: 请求的 url</span></span><br><span class="line"><span class="string">    :param proxies:</span></span><br><span class="line"><span class="string">    :param header:</span></span><br><span class="line"><span class="string">    :param time_out: (connect_time_out, read_time_out)</span></span><br><span class="line"><span class="string">    :param max_retries: 重试次数</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; max_retries:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response = requests.get(url, proxies=proxies, headers=headers, timeout=timeout)</span><br><span class="line">            response_content = response.content</span><br><span class="line">            response.close()</span><br><span class="line">            <span class="keyword">return</span> response_content</span><br><span class="line">        <span class="keyword">except</span> requests.exceptions.RequestException <span class="keyword">as</span> e:</span><br><span class="line">            log.error(<span class="string">'&#123;&#125; times request'</span>.format(i+<span class="number">1</span>) + str(e) + url)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>layout</title>
    <url>/2019/11/08/QT/layout/</url>
    <content><![CDATA[<h1 id="layout（布局管理器）"><a href="#layout（布局管理器）" class="headerlink" title="layout（布局管理器）"></a>layout（布局管理器）</h1><h2 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h2><p>布局管理器，作为Box控件，很明显是保持其他控件，如Button的变化一致性</p>
<h2 id="QSplitter"><a href="#QSplitter" class="headerlink" title="QSplitter"></a>QSplitter</h2><p>分裂器的作用与上述类似，不过两者很大的区别在于</p>
<p>当使用 QSplitter与vertical layout时</p>
<ul>
<li>QSplitter 会改变Button纵向大小</li>
<li>vertical layout 不会改变纵向大小</li>
</ul>
]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>README</title>
    <url>/2019/11/08/QT/README/</url>
    <content><![CDATA[<h1 id="QT开发笔记"><a href="#QT开发笔记" class="headerlink" title="QT开发笔记"></a>QT开发笔记</h1><p>软件课设</p>
]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>make</title>
    <url>/2019/11/08/QT/make/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>生成器与迭代器</title>
    <url>/2019/11/12/Python/%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h1 id="生成器与迭代器"><a href="#生成器与迭代器" class="headerlink" title="生成器与迭代器"></a>生成器与迭代器</h1><p><em>前言：这是一篇比较散漫的文章，标题只是说明了中心的一部分，往往写这篇文章的理由是由一个具体的事件牵扯进来一串知识点，而这些知识点是我所不熟悉的</em></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>使用 <code>concurrent.futures.ThreadPoolExecuter</code> 来提交并发任务是一种很常用的方法，往往如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">max_workers = thread_max_workers <span class="keyword">if</span> <span class="keyword">not</span> max_workers <span class="keyword">else</span> max_workers</span><br><span class="line">exe = cf.ThreadPoolExecutor(max_workers=max_workers) <span class="keyword">if</span> mode == <span class="string">'thread'</span> <span class="keyword">else</span> cf.ProcessPoolExecutor(max_workers=max_workers)</span><br><span class="line"><span class="keyword">with</span> exe <span class="keyword">as</span> executor:</span><br><span class="line">    <span class="keyword">if</span> args_list <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> range(max_workers):</span><br><span class="line">            executor.submit(func)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        executor.map(func, args_list)</span><br></pre></td></tr></table></figure>

<p>但今天使用的时候是通过一个生成器传入参数，查看<a href="https://docs.python.org/zh-cn/3/library/concurrent.futures.html" target="_blank" rel="noopener">说明文档</a> <code>map(func, *iterables, timeout=None, chunksize=1)</code> 参数列表是迭代器对象，但执行不正确，异常退出</p>
<h2 id="溯源"><a href="#溯源" class="headerlink" title="溯源"></a>溯源</h2><h3 id="生成器与迭代器-1"><a href="#生成器与迭代器-1" class="headerlink" title="生成器与迭代器"></a>生成器与迭代器</h3><p>详细见：<a href="https://www.zhihu.com/question/20829330" target="_blank" rel="noopener">https://www.zhihu.com/question/20829330</a></p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>其实常见的 <code>list</code> 类型都是迭代器，一般来说实现了 <code>__next__</code> 方法（又称迭代器协议）就可使用 <code>for</code> 循环来访问</p>
<p>关于迭代器：</p>
<ul>
<li><p><code>itertools</code> 工具可以更快速高效地创建迭代对象，例如：<code>repeat()</code> 函数 <a href="https://docs.python.org/zh-cn/3/library/itertools.html" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/itertools.html</a></p>
</li>
<li><p><code>zip()</code> zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存。我们可以使用 list() 转换来输出列表。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zipped = zip(a,b)     <span class="comment"># 返回一个对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zipped</span><br><span class="line">&lt;zip object at <span class="number">0x103abc288</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zipped)  <span class="comment"># list() 转换为列表</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(a,c))              <span class="comment"># 元素个数与最短的列表一致</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1, a2 = zip(*zip(a,b))          <span class="comment"># 与 zip 相反，zip(*) 可理解为解压，返回二维矩阵式</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(a1)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(a2)</span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>生成器其实本质上是一种迭代器，提供了对包含对象的延迟操作，正如访问 <code>list</code> 的时候需要把其中的所有内容提前加载进内存，生成器则不需要这样，吃多少取多少</p>
<p>Python的两种方式提供生成器：</p>
<ul>
<li>生成器函数：即在函数中使用 <code>yield</code> 返回值的函数，会每次在 <code>yield</code> 返回后挂起，等待下次执行，举个例子吧</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">'Max number is &#123;&#125;'</span>.format(n))</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">f = count(<span class="number">3</span>)        <span class="comment">#   count()为生成器函数, f 为生成器</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> f:</span><br><span class="line">    print(i)        <span class="comment">#   仅输出一次 Max number is 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>生成器表达式：类似于列表推导</li>
</ul>
<p>列表推导</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br></pre></td></tr></table></figure>
<p>生成器表达式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>squares = (x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(squares)</span><br></pre></td></tr></table></figure>
<p>但正如前文中的问题，我们的生成器函数为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_sentences</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">            news_documents = db_topic_summary.find(&#123;<span class="string">'$or'</span>: [&#123;<span class="string">'news_summary_ne_with_nltk'</span>: &#123;<span class="string">'$in'</span>: [<span class="literal">None</span>]&#125;&#125;,</span><br><span class="line">                                                        &#123;<span class="string">'news_summary_ne_with_sn'</span>:  &#123;<span class="string">'$in'</span>: [<span class="literal">None</span>]&#125;&#125;]&#125;,</span><br><span class="line">                                                   &#123;<span class="string">'_id'</span>: <span class="number">1</span>, <span class="string">'news_summary_count'</span>: <span class="number">1</span>&#125;)</span><br><span class="line">        <span class="keyword">if</span> news_documents.count() &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> doc <span class="keyword">in</span> news_documents:</span><br><span class="line">            sentences = <span class="string">''</span></span><br><span class="line">            <span class="keyword">for</span> t <span class="keyword">in</span> doc[<span class="string">'news_summary_count'</span>][<span class="number">0</span>:<span class="number">3</span>]:</span><br><span class="line">                sentences += t[<span class="number">0</span>] + <span class="string">' '</span></span><br><span class="line">            <span class="keyword">yield</span> doc[<span class="string">'_id'</span>], sentences</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br></pre></td></tr></table></figure>
<p>但为什么这样调用 <code>executer.map(func, get_sentences())</code> 不能成功运行呢，只是多了个参数而已，原来发现该生成器返回的是 <code>tuple</code>，func 并不是以一个 <code>tuple</code> 为形参的，解决方法：</p>
<p>详细见：<a href="https://stackoverflow.com/questions/6785226/pass-multiple-parameters-to-concurrent-futures-executor-map" target="_blank" rel="noopener">https://stackoverflow.com/questions/6785226/pass-multiple-parameters-to-concurrent-futures-executor-map</a></p>
<ol>
<li>第一种方法： 并发的函数的形参设置为 <code>tuple</code>，在该函数内进行参数的解析</li>
<li>第二种方法：使用 <code>lambda</code> 函数：<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(str1, str2)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(str1 + str2)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ab</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">'a'</span>,<span class="string">'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    parallel_do(<span class="keyword">lambda</span> args: run(*args), get_ab())</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>QCustomPlot</title>
    <url>/2019/11/08/QT/QCustomPlot/</url>
    <content><![CDATA[<h1 id="QCustomPlot"><a href="#QCustomPlot" class="headerlink" title="QCustomPlot"></a>QCustomPlot</h1><p>QCustomPlot是一个绘图的第三方库，可用来绘制一些频谱图等</p>
<h2 id="1-控件基本操作"><a href="#1-控件基本操作" class="headerlink" title="1.控件基本操作"></a>1.控件基本操作</h2><p>添加控件后，提升为一个类，即可进行画图</p>
<h3 id="1-1begin"><a href="#1-1begin" class="headerlink" title="1.1begin"></a>1.1begin</h3><ul>
<li><strong>customPlot-&gt;addGraph();</strong>    </li>
<li><strong>customPlot-&gt;addGraph(customPlot-&gt;yAxis,customPlot-&gt;xAxis2);</strong> 第一个参数是key Axis,第二个参数是value Axis<br>添加一幅图形，这里指的是在一幅图里可以绘制多种，添加后会自动为每个Graph排序 Graph(0),Graph(1)…  </li>
<li><strong>customPlot-&gt;graph(0)-&gt;set…;</strong><br>对绘制的每个图层，进行设置   </li>
<li><strong>customPlot-&gt;replot();</strong><br>这个会自动发生，不添加此函数也可以 </li>
</ul>
<h3 id="1-2坐标轴-axes"><a href="#1-2坐标轴-axes" class="headerlink" title="1.2坐标轴 axes"></a>1.2坐标轴 axes</h3><p>可以操作上下左右四个axes: xAxis,xAxis2,yAxis,yAxis2<br>1.range</p>
<ul>
<li><strong>customPlot-&gt;xAxis-&gt;setRange(min,max);</strong></li>
</ul>
<p>2.Label</p>
<ul>
<li><strong>customPlot-&gt;xAxis-&gt;setLabel(“string”);</strong></li>
</ul>
<h3 id="1-3图例-legend"><a href="#1-3图例-legend" class="headerlink" title="1.3图例 legend"></a>1.3图例 legend</h3><p>1.先设置可视化!!!</p>
<ul>
<li><strong>customPlot-&gt;legend-&gt;setVisible(true);</strong>   </li>
</ul>
<p>2.名字交给图层</p>
<h3 id="1-4-Ticker"><a href="#1-4-Ticker" class="headerlink" title="1.4 Ticker"></a>1.4 Ticker</h3><ul>
<li><strong>customPlot-&gt;setTickLength(inside,outside);</strong><br>inside,outside分别为内外高的像素，即坐标轴上的标注高低  </li>
<li><strong>customPlot-&gt;setSubTickLength(inside,outside);</strong>  </li>
</ul>
<h2 id="2-图层-graph"><a href="#2-图层-graph" class="headerlink" title="2.图层 graph"></a>2.图层 graph</h2><p>graph(0),graph(1),graph(2)…</p>
<h3 id="2-1数据-data"><a href="#2-1数据-data" class="headerlink" title="2.1数据 data"></a>2.1数据 data</h3><ul>
<li><strong>customPlot-&gt;graph(0)-&gt;setData(x0,y0);</strong><br>x0,y0是取样点数据，注意两者维度要保持一致</li>
</ul>
<h3 id="2-2图例-legend"><a href="#2-2图例-legend" class="headerlink" title="2.2图例 legend"></a>2.2图例 legend</h3><ul>
<li><strong>customPlot-&gt;graph(0)-&gt;setName(“string”);</strong></li>
</ul>
<h3 id="2-3-样式"><a href="#2-3-样式" class="headerlink" title="2.3 样式"></a>2.3 样式</h3><ul>
<li><strong>customPlot-&gt;graph(0)-&gt;setScatterStyle(QCPScatterStyle(QCPScatterStyle::ssDisc, 5));</strong><br>可以设置成画出各个取样点的样式   </li>
</ul>
]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>DataQuery</title>
    <url>/2019/11/08/SQL/DataQuery/</url>
    <content><![CDATA[<h1 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h1><p><code>SELECT * FROM (tables);</code></p>
<p><code>SELECT first_name FROM student_info WHERE id = 1;</code></p>
<p><code>SELECT * FROM student_info WHERE id = &#39;&#39; and name = &#39;&#39;;</code></p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>QMessageBox</title>
    <url>/2019/11/08/QT/QMessageBox/</url>
    <content><![CDATA[<h1 id="QMessageBox"><a href="#QMessageBox" class="headerlink" title="QMessageBox"></a>QMessageBox</h1><p>弹窗</p>
<h2 id="modal-dialog"><a href="#modal-dialog" class="headerlink" title="modal dialog"></a>modal dialog</h2><p>对话框的两种模式，default是application modal，两者区别见下：<br><strong>application modal</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">When an application modal dialog is opened, the user must finish interacting with the dialog and close it before they can access any other window in the application.</span><br></pre></td></tr></table></figure>
<p>什么意思呢？就是在application dialog模式下，必须完成与该dialog的交互，才能与其它dialog交互，完全阻塞</p>
<p><strong>window modal</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Window modal dialogs only block access to the window associated with the dialog, allowing the user to continue to use other windows in an application.</span><br></pre></td></tr></table></figure>
<p>window modal模式下，就是非必须完成交互也能与其它不相关窗口交互</p>
<h2 id="QMessageBox-1"><a href="#QMessageBox-1" class="headerlink" title="QMessageBox"></a>QMessageBox</h2><p>继承于QDialog class</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QMessageBox box;</span><br><span class="line">        box.setWindowTitle(&quot;警告&quot;);</span><br><span class="line">        box.setIcon(QMessageBox::Warning);</span><br><span class="line">        box.setText(curFile+&quot;尚未保存，是否保存？&quot;);</span><br><span class="line">        QPushButton *yesBtn = box.addButton(&quot;是(&amp;Y)&quot;,QMessageBox::YesRole);</span><br><span class="line">        box.addButton(&quot;否(&amp;N)&quot;,QMessageBox::NoRole);</span><br><span class="line">        QPushButton *cancelBtn = box.addButton(&quot;取消&quot;,QMessageBox::RejectRole);</span><br><span class="line">        box.exec();                                                 //窗口关闭时获取DialogCode</span><br><span class="line">        if(box.clickedButton()==yesBtn) &#123;</span><br><span class="line">            return save();</span><br><span class="line">        &#125;</span><br><span class="line">        else if(box.clickedButton()==cancelBtn)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>RADME</title>
    <url>/2019/11/08/SQL/RADME/</url>
    <content><![CDATA[<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p>年轻不懂事，搞点事情  </p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>menuIcon</title>
    <url>/2019/11/08/QT/menuIcon/</url>
    <content><![CDATA[<h1 id="menuIcon"><a href="#menuIcon" class="headerlink" title="menuIcon"></a>menuIcon</h1><p>添加菜单图标</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>1.在menuBar输入框中输入自己要输入的一级菜单名称，二级菜单…</p>
<p>2.Qt中的一个菜单被视为一个Action，在下面Action编辑器中更改“文本”等</p>
<ul>
<li>这里可以通过 &amp;Open,&amp;New,设置加速键，<strong>加速键</strong>：即当菜单处于激活状态时的快捷键</li>
<li>这里也可以设置<strong>快捷键shortcut</strong>，在shortcut输入框中输入快捷键</li>
</ul>
<p>3.当要添加菜单图标时，需要用到“图标”后面的“添加文件”，“添加资源”；</p>
<ul>
<li><strong>资源文件</strong>：Qt使用资源文件将各种外部文件添加至最终生成的可执行文件中</li>
<li>文件</li>
</ul>
<p>4.选取图标所在文件夹里的文件即可</p>
<h2 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h2><p>原理与上述同，上代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line">#include &quot;ui_mainwindow.h&quot;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent) :</span><br><span class="line">    QMainWindow(parent),</span><br><span class="line">    ui(new Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(this);</span><br><span class="line">    //创建新的动作</span><br><span class="line">    QAction *openAction = new QAction(&quot;&amp;Open&quot;,this);</span><br><span class="line">    //添加图标,这里的路径参考ui_mainwindow.h文件，里面代码与此相同</span><br><span class="line">    QIcon icon(&quot;:/myImages/img/actions/fileopen.png&quot;);</span><br><span class="line">    openAction-&gt;setIcon(icon);</span><br><span class="line">    //设置快捷键</span><br><span class="line">    openAction-&gt;setShortcut(QKeySequence(&quot;Ctrl+O&quot;));</span><br><span class="line">    //在文件菜单中设置新的打开动作</span><br><span class="line">    ui-&gt;menu-&gt;addAction(openAction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">    delete ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主窗口的构造函数中添加”//“部分代码</p>
]]></content>
      <categories>
        <category>QT</category>
      </categories>
      <tags>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title>README</title>
    <url>/2019/11/08/SQL/README/</url>
    <content><![CDATA[<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><p>And</p>
<blockquote>
<ul>
<li>DataTypeAndEngines MySQL存储引擎与数据类型  2017.4.26  </li>
<li>BasicOperation     MySQL基本操作  2017.4.26  </li>
<li>DataQuery          MySQL数据查询  2017.4.26  </li>
<li></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>BasicOperation</title>
    <url>/2019/11/08/SQL/BasicOperation/</url>
    <content><![CDATA[<h1 id="MySQL的基本操作"><a href="#MySQL的基本操作" class="headerlink" title="MySQL的基本操作"></a>MySQL的基本操作</h1><p>MySQL数据库:<br><strong>系统数据库:</strong>  </p>
<blockquote>
<ul>
<li>information_schema: 数据库对象信息  </li>
<li>performance_schema: 性能参数  </li>
<li>mysql:  用户权限信息  </li>
<li>test：  用作测试的数据库 </li>
</ul>
</blockquote>
<p><strong>用户数据库(可创建多个)</strong></p>
<h2 id="MySQL数据库的操作"><a href="#MySQL数据库的操作" class="headerlink" title="MySQL数据库的操作"></a>MySQL数据库的操作</h2><blockquote>
<ul>
<li>新建数据库:  create database 数据库名;  </li>
<li>查看数据库:  show databases;(查看所有）  </li>
<li>选择数据库:  use 数据库名;  </li>
<li>删除数据库:  drop database 数据库名;</li>
<li>查看支持的引擎:  show variables like ‘have%’;  </li>
<li>查看引擎:    show engines;</li>
</ul>
</blockquote>
<h2 id="MySQL数据表的操作"><a href="#MySQL数据表的操作" class="headerlink" title="MySQL数据表的操作"></a>MySQL数据表的操作</h2><p><strong><em>表中数据库对象:  列，索引，触发器</em></strong>  </p>
<blockquote>
<ul>
<li>新建表:  create table 数据表名 (             );  </li>
<li>查看表:  describe/desc 数据表名; show columns from  </li>
<li>删除表:  drop table 数据表名;  </li>
<li>修改表:  alter </li>
</ul>
</blockquote>
<h2 id="MySQL语句操作"><a href="#MySQL语句操作" class="headerlink" title="MySQL语句操作"></a>MySQL语句操作</h2><h2 id="操作表的约束"><a href="#操作表的约束" class="headerlink" title="操作表的约束"></a>操作表的约束</h2><p>对于字段的完整性约束</p>
<blockquote>
<ul>
<li>NOT NULL 非空  </li>
<li>DEFAULT  默认  </li>
<li>UNIQUE KEY(UK)  唯一  </li>
<li>PRIMARY KEY(PK) 主键  </li>
<li>AUTO_INCREMENT  自动增加  </li>
<li>FOREIGN KEY     外键</li>
</ul>
</blockquote>
<p><strong><em>表名，主键具有唯一性</em></strong><br><strong><em>外键提前需要有父表的主键</em></strong></p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Dcoker</title>
    <url>/2019/11/24/Something/Dcoker/</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看帮助</span></span><br><span class="line">docker xxx --help</span><br><span class="line"><span class="comment"># 拉取镜像</span></span><br><span class="line">sudo docker pull image</span><br><span class="line"><span class="comment"># 创建容器</span></span><br><span class="line">docker run image</span><br><span class="line"><span class="comment"># 列出当前运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="comment"># 列出所有的容器，包括运行的和不运行的</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="comment"># 删除容器</span></span><br><span class="line">docker rm container-id</span><br><span class="line"><span class="comment"># 容器的启动、进入、退出</span></span><br><span class="line">docker start [-i] container-id</span><br><span class="line"><span class="comment"># 容器的停止、重启</span></span><br><span class="line">docker stop container-id</span><br><span class="line">docker restart container-id</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/64493662" target="_blank" rel="noopener">Docker,深度学习的环境配置</a></li>
<li><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">Docker 官方文档</a></li>
</ul>
]]></content>
      <categories>
        <category>Something</category>
      </categories>
      <tags>
        <tag>Something</tag>
      </tags>
  </entry>
  <entry>
    <title>DataTypeAndEngines</title>
    <url>/2019/11/08/SQL/DataTypeAndEngines/</url>
    <content><![CDATA[<h1 id="DataType-and-Engines-数据类型与存储引擎"><a href="#DataType-and-Engines-数据类型与存储引擎" class="headerlink" title="DataType and Engines  数据类型与存储引擎"></a>DataType and Engines  数据类型与存储引擎</h1><h2 id="DataType-数据类型"><a href="#DataType-数据类型" class="headerlink" title="DataType 数据类型"></a>DataType 数据类型</h2><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>1.CHAR:  CHAR(M),VARCHAR(M)</p>
<p>2.TEXT:  TINYTEXT,TEXT,MEDIUMTEXT,LONGTEXT </p>
<p>3.BINARY: BINARY(M),VARBINARY(M)  </p>
<p>4.BLOB:  TINYBLOB,BLOB,MEDIUMBLOB,LONGBLOB </p>
<p>1,3仅能存储字符数据，2,4可用来存储二进制数据，如：图片，音频，视频等</p>
<h3 id="日期与时间类型"><a href="#日期与时间类型" class="headerlink" title="日期与时间类型"></a>日期与时间类型</h3><blockquote>
<ul>
<li>DATE  DATETIME  TIMESTAMP TIME  YEAR</li>
</ul>
</blockquote>
<h3 id="浮点数，定点数与位类型"><a href="#浮点数，定点数与位类型" class="headerlink" title="浮点数，定点数与位类型"></a>浮点数，定点数与位类型</h3><p>1.FLOAT   DOUBLE</p>
<p>2.DEC(M,D)  DECIMAL(M,D)</p>
<p>3.BIT(M)</p>
<h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><blockquote>
<ul>
<li>TINYINT   SMALLINT    MEDIUMINT   INT &amp;&amp; INTEGER    BIGINT</li>
</ul>
</blockquote>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>存储引擎就是存储数据，建立索引，更新与查询数据的方法</p>
<blockquote>
<ul>
<li>查询引擎命令: SHOW ENGINES; </li>
<li>查询支持的存储引擎:  SHOW VARIABLES LIKE ‘have%’</li>
</ul>
</blockquote>
<p><strong><em>补:SHOW ENGINES \G;是一种较为理想的查看方式，而 SHOW ENGINGES;SHOW ENGINES \g;查看起来则不方便</em></strong></p>
<p>MySQL有多个可用的存储引擎，主要有:  InnoDB  MyISAM  MEMORY</p>
<p>InnoDB:  </p>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<p>MyISAM:  </p>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
<p>MEMORY:  </p>
<blockquote>
<ul>
<li></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SqlInjection</title>
    <url>/2020/01/05/SQL/SqlInjection/</url>
    <content><![CDATA[<h2 id="Sql注入的基本类型"><a href="#Sql注入的基本类型" class="headerlink" title="Sql注入的基本类型"></a>Sql注入的基本类型</h2><blockquote>
<ul>
<li>数字型与字符类型  </li>
<li>基于错误，基于响应时间的盲注，基于响应的注入</li>
</ul>
</blockquote>
<h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p>常基于以下SQL:<br><code>SELECT * FROM student_info WHERE id = &#39;$id&#39; and name = &#39;$name&#39;;</code></p>
<h3 id="数字型"><a href="#数字型" class="headerlink" title="数字型"></a>数字型</h3><p>常基于以下SQL:<br><code>SELECT * FROM student_info WHERE id = $id;</code></p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><h3 id="猜解数据库"><a href="#猜解数据库" class="headerlink" title="猜解数据库"></a>猜解数据库</h3><p>1.报错信息</p>
<p>2.联合查询 union</p>
<p><code>1&#39; union select user,password from users#</code> 构造成 </p>
<p><code>SELECT first_name, last_name FROM users WHERE user_id = &#39;1&#39; union select user,password from users#</code>;`</p>
<p><code>select table_name,table_schema from information_schema.tables where table_schema= &#39;dvwa&#39;#</code>;`<br>从 information_schema 数据库里查询 </p>
<p>可查询的数据库信息有：  </p>
<ul>
<li>version()  查询当前数据库版本  </li>
<li>@@version_compile_os 获取当前操作系统</li>
<li>database() 当前数据库</li>
<li>user() 用户</li>
</ul>
<h3 id="绕过验证"><a href="#绕过验证" class="headerlink" title="绕过验证"></a>绕过验证</h3><ul>
<li>常用方式</li>
</ul>
<p>1.注释符与永真判别式 </p>
<p>注释符用于注释掉后续内容；  </p>
<p>如：（字符型）<br><code>SELECT * FROM student_info WHERE id = &#39;$id&#39; and name = &#39;$name&#39;;</code></p>
<p>构造  <code>1&#39; or 1=1 #</code> 成为 <code>SELECT * FROM student_info WHERE id = &#39;1&#39; or 1=1 # and name = &#39;$name&#39;;</code></p>
<p>如：（数字型）<br><code>SELECT * FROM student_info WHERE id = $id;</code></p>
<p>构造 <code>1 or 1=1 #</code> 成为 <code>SELECT * FROM student_info WHERE id = 1 or 1=1 #;</code></p>
<h2 id="识别Sql注入"><a href="#识别Sql注入" class="headerlink" title="识别Sql注入"></a>识别Sql注入</h2><h3 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h3><p>最简单的方式是<br><strong>1’</strong>  单引号判别，出错则说明有注入点</p>
<p>1.永真和永假表达式 or 1=1–<br>2.报错信息<br>3.特定数据库的连接符  SQL SERVER —</p>
<h2 id="常用其它"><a href="#常用其它" class="headerlink" title="常用其它"></a>常用其它</h2><p>sql注入常用技术有段还包括：</p>
<ul>
<li><p>采用非主流通道技术</p>
</li>
<li><p>避开输入过滤技术</p>
</li>
<li><p>使用特殊的字符</p>
</li>
<li><p>强制产生错误</p>
</li>
<li><p>使用条件语句</p>
</li>
<li><p>利用存储过程</p>
</li>
<li><p>推断技术<br>……..</p>
</li>
<li><p>宽字节注入</p>
</li>
<li><p>urldecode二次注入</p>
</li>
<li><p>sql注入防御</p>
</li>
</ul>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Latex 写作语法</title>
    <url>/2020/01/02/Something/Latex/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Something</category>
      </categories>
      <tags>
        <tag>Something</tag>
      </tags>
  </entry>
  <entry>
    <title>GoogleExplore</title>
    <url>/2019/11/08/Something/GoogleExplore/</url>
    <content><![CDATA[<h1 id="Google精确搜索，提高查询效率"><a href="#Google精确搜索，提高查询效率" class="headerlink" title="Google精确搜索，提高查询效率"></a>Google精确搜索，提高查询效率</h1><p><a href="http://www.cnblogs.com/xuanhun/p/3910134.html" target="_blank" rel="noopener">xuanhun</a>  感谢!</p>
<p>这些搜索引擎的搜索技术来源于传统数据库的检索技术  </p>
<h2 id="精确搜索"><a href="#精确搜索" class="headerlink" title="精确搜索"></a>精确搜索</h2><blockquote>
<ul>
<li>Google默认模糊搜索  </li>
<li>“xxxxx”可进行精确搜索    </li>
<li>通配符*可用于代替关键词  </li>
<li>点号 . 可用于匹配任意字符  </li>
</ul>
</blockquote>
<h2 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h2><blockquote>
<ul>
<li>“ + “用于强制搜索，即 + 前后的内容都必须包含;常和精确搜索 “ “ 一起来用  </li>
</ul>
</blockquote>
<h2 id="Bool逻辑"><a href="#Bool逻辑" class="headerlink" title="Bool逻辑"></a>Bool逻辑</h2><blockquote>
<ul>
<li>Google默认多个词间关系为逻辑与  </li>
<li>当使用逻辑算符时，词语逻辑算符用空格分开  </li>
<li>复杂的逻辑关系可以用()来分组 </li>
<li>当运用非逻辑时，”搜索 -内容”格式</li>
</ul>
</blockquote>
<h2 id="数字范围"><a href="#数字范围" class="headerlink" title="数字范围"></a>数字范围</h2><blockquote>
<ul>
<li>“ .. “表示一个数字范围</li>
</ul>
</blockquote>
<h2 id="标题中搜索"><a href="#标题中搜索" class="headerlink" title="标题中搜索"></a>标题中搜索</h2><blockquote>
<ul>
<li>语法: intitle 或 allintitle  </li>
<li>示例: intitle:”WSO 2.4” [ Sec. Info ], [ Files ],<br>[ Console ], [ Sql ], [ Php ], [ Safe mode ], [ String tools ], [ Bruteforce ], [ Network ], [ Self remove ]</li>
</ul>
</blockquote>
<h2 id="正文中搜索"><a href="#正文中搜索" class="headerlink" title="正文中搜索"></a>正文中搜索</h2><blockquote>
<ul>
<li>语法: intext 或 allintext  </li>
<li>示例: intitle:”index” intext:”Login to the Administrative Interface”</li>
</ul>
</blockquote>
<h2 id="网址中搜索"><a href="#网址中搜索" class="headerlink" title="网址中搜索"></a>网址中搜索</h2><blockquote>
<ul>
<li>语法: inurl  </li>
<li>示例: inurl:phpmyadmin/index.php &amp; (intext:username &amp; password &amp; “Welcome to”)  </li>
</ul>
</blockquote>
<h2 id="锚点链接搜索"><a href="#锚点链接搜索" class="headerlink" title="锚点链接搜索"></a>锚点链接搜索</h2><blockquote>
<ul>
<li>语法: inanchor 或 allinanchor  </li>
<li>示例: inanchor:修改密码   </li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Something</category>
      </categories>
      <tags>
        <tag>Something</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode</title>
    <url>/2020/02/08/Something/switchomega/</url>
    <content><![CDATA[<h1 id="SwitchOmega"><a href="#SwitchOmega" class="headerlink" title="SwitchOmega"></a>SwitchOmega</h1><h2 id="tricky"><a href="#tricky" class="headerlink" title="tricky"></a>tricky</h2><p><code>swichOmega</code> 带有自动切换的功能，可以使用　auto switch　中的规则列表应用于代理服务器，其它使用默认的直接连接；</p>
]]></content>
      <categories>
        <category>Something</category>
      </categories>
      <tags>
        <tag>Something</tag>
      </tags>
  </entry>
  <entry>
    <title>README</title>
    <url>/2019/11/08/Something/README/</url>
    <content><![CDATA[<h1 id="Interesting"><a href="#Interesting" class="headerlink" title="Interesting"></a>Interesting</h1><h2 id="Listen-to-the-heart-Do-Something-Interesting"><a href="#Listen-to-the-heart-Do-Something-Interesting" class="headerlink" title="Listen to the heart! Do Something Interesting!"></a>Listen to the heart! Do Something Interesting!</h2><ul>
<li><p>2017.4.22 MarkDown语法学习，<a href="http://www.jianshu.com/p/q81RER" target="_blank" rel="noopener">简书</a> <a href="http://wowubuntu.com/markdown/#p" target="_blank" rel="noopener">Wow!Ubuntu</a> 感谢!</p>
</li>
<li><p>2017.4.23 Google搜索语法学习,<a href="http://www.cnblogs.com/xuanhun/p/3910134.html" target="_blank" rel="noopener">xuanhun</a> 感谢!</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Something</category>
      </categories>
      <tags>
        <tag>Something</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown</title>
    <url>/2020/01/02/Something/MarkDown/</url>
    <content><![CDATA[<h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><h2 id="学习链接"><a href="#学习链接" class="headerlink" title="学习链接"></a>学习链接</h2><p><a href="http://www.jianshu.com/p/q81RER" target="_blank" rel="noopener">简书</a><br><a href="http://wowubuntu.com/markdown/#p" target="_blank" rel="noopener">Wow!Ubuntu</a>  感谢!</p>
<h2 id="Markdown优点"><a href="#Markdown优点" class="headerlink" title="Markdown优点:"></a>Markdown优点:</h2><ul>
<li>纯文本，兼容性强</li>
<li>格式转换方便，可以轻松地转换为html,电子书等</li>
<li>Markdown语法有极好的可读性</li>
</ul>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><blockquote>
<p># 一级标题<br>## 二级标题<br>### 三级标题  </p>
</blockquote>
<p>#可以有六级，表示六级标题</p>
<h2 id="列表与引用"><a href="#列表与引用" class="headerlink" title="列表与引用"></a>列表与引用</h2><blockquote>
<p>- 文本1<br>- 文本2<br>- 文本3</p>
</blockquote>
<p>或者显示1,2,3的情况，使用:</p>
<blockquote>
<p>1.文本1<br>2.文本2<br>3.文本3  </p>
</blockquote>
<p>注意：<strong>这些符号需在与后续文本之间加上一空格字符才能正确地显示</strong></p>
<h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><blockquote>
<ul>
<li>当在一个文本块需要强制换行时，可以使用两个空格+换行符来强制换行，否则仅用一个换行符并不能起到换行的作用；</li>
<li>恰当的使用空白行也能起到换行的作用；</li>
</ul>
</blockquote>
<h2 id="粗体与斜体"><a href="#粗体与斜体" class="headerlink" title="粗体与斜体"></a>粗体与斜体</h2><blockquote>
<ul>
<li>粗体：用2个<em>包含的内容，例如**文本*\</em></li>
<li>斜体：用1个<em>包含的内容，例如*文本\</em></li>
</ul>
</blockquote>
<h2 id="反斜杠"><a href="#反斜杠" class="headerlink" title="反斜杠\"></a>反斜杠\</h2><blockquote>
<p>为什么我上面在引用里使用了一些符号但是却以文本的形式显示出来的呢？这得靠\的帮助，当你在文本中需要#,&gt;,-<br>等这些普通意义的符号时就只用在前面加上\就OK了</p>
</blockquote>
<h2 id="链接与图片"><a href="#链接与图片" class="headerlink" title="链接与图片"></a>链接与图片</h2><blockquote>
<ul>
<li>插入链接：[显示文本](链接地址)  </li>
<li>插入图片：![](图片链接地址)</li>
</ul>
</blockquote>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><blockquote>
<ul>
<li>用|表示竖列对齐  </li>
<li>用---区分名称与数值  </li>
<li>用:表示左，右，中间对齐</li>
</ul>
</blockquote>
<p><em>例如:</em>  </p>
<blockquote>
<p>| Tables                     | Are           | Cool        |<br>| ------------- |:-----: | -----:|<br>| col 3 is                   | right-aligned | $1600       |<br>| col 2 is                   | centered      |   $12       |<br>| zebra stripes              | are neat      |    $1       |  </p>
</blockquote>
<p><em>显示效果：</em>  </p>
<table>
<thead>
<tr>
<th>Tables</th>
<th align="center">Are</th>
<th align="right">Cool</th>
</tr>
</thead>
<tbody><tr>
<td>col 3 is</td>
<td align="center">right-aligned</td>
<td align="right">$1600</td>
</tr>
<tr>
<td>col 2 is</td>
<td align="center">centered</td>
<td align="right">$12</td>
</tr>
<tr>
<td>zebra stripes</td>
<td align="center">are neat</td>
<td align="right">$1</td>
</tr>
</tbody></table>
<h2 id="代码引用"><a href="#代码引用" class="headerlink" title="代码引用"></a>代码引用</h2><blockquote>
<ul>
<li>单段代码引用：用  &#39;  包括整个代码段显示为一个代码段  </li>
<li>多段代码引用：用  &#39;&#39;&#39;  置于代码段的首行与末行</li>
</ul>
</blockquote>
<h2 id="编写数学公式"><a href="#编写数学公式" class="headerlink" title="编写数学公式"></a>编写数学公式</h2><p><em>参考：<a href="https://juejin.im/post/5a6721bd518825733201c4a2#heading-1" target="_blank" rel="noopener">https://juejin.im/post/5a6721bd518825733201c4a2#heading-1</a></em></p>
<p>数学公式的编写类似于 Latex 中的用法，这里介绍一些常用的：</p>
<ul>
<li><code>$$\left(\sum_{k=\frac{1}{2}}^{N^2}\frac{1}{k}\right)$$</code></li>
</ul>
<p>$$\left(\sum_{k=\frac{1}{2}}^{N^2}\frac{1}{k}\right)$$</p>
<ul>
<li><code>$$\left(\int_a^b\sqrt{2x}dx\right)$$</code></li>
</ul>
<p>$$\left[\int_a^b\sqrt{2x}dx\right]$$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$\begin&#123;bmatrix&#125;</span><br><span class="line">    1 &amp; 2 \\\\</span><br><span class="line">    3 &amp; 4</span><br><span class="line">\end&#123;bmatrix&#125;$$</span><br></pre></td></tr></table></figure>

<p>$$\begin{bmatrix}<br>    1 &amp; 2 \\<br>    3 &amp; 4<br>\end{bmatrix}$$</p>
<ul>
<li>数学公式中的空格</li>
</ul>
<p>markdown 中数学公式中的空格</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">没有空格 $ab$</span><br><span class="line">小空格 a\,b</span><br><span class="line">中等空格 a\;b</span><br><span class="line">大空格 a\ b</span><br><span class="line">quad空格 $a\quad b$</span><br><span class="line">qquad空格 $a\qquad b$</span><br></pre></td></tr></table></figure>

<p>没有空格 $ab$<br>小空格 $a,b$<br>中等空格 $a;b$<br>大空格 $a\ b$<br>quad空格 $a\quad b$<br>qquad空格 $a\qquad b$</p>
<ul>
<li>数学公式的换行</li>
</ul>
<p>使用 <code>\\</code> 或 <code>\\</code> 进行数学公式的换行，使用在 <code>\begin \end</code> 块中，见以下示例。</p>
<ul>
<li>数学公式的对齐</li>
</ul>
<p>使用 <code>aligned</code> + <code>&amp;</code></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">r<span class="emphasis">_&#123;t&#125; =&amp; \sigma(W_</span>&#123;ir&#125;x<span class="emphasis">_&#123;t&#125; + b_</span>&#123;ir&#125; + W<span class="emphasis">_&#123;hr&#125;h_</span>&#123;(t-1)&#125; + b_&#123;hr&#125;) \\</span><br><span class="line">z<span class="emphasis">_&#123;t&#125; =&amp; \sigma(W_</span>&#123;iz&#125;x<span class="emphasis">_&#123;t&#125; + b_</span>&#123;iz&#125; + W<span class="emphasis">_&#123;hz&#125;h_</span>&#123;(t-1)&#125; + b_&#123;hz&#125;) \\</span><br><span class="line">n<span class="emphasis">_&#123;t&#125; =&amp; tanh(W_</span>&#123;in&#125;x<span class="emphasis">_&#123;t&#125; + b_</span>&#123;in&#125; + r<span class="emphasis">_&#123;t&#125;*(W_</span>&#123;hn&#125;h<span class="emphasis">_&#123;(t-1)&#125; + b_</span>&#123;hn&#125;)) \\</span><br><span class="line">h<span class="emphasis">_&#123;t&#125; =&amp; (1-z_</span>&#123;t&#125;) <span class="emphasis">* n_&#123;t&#125; + z_&#123;t&#125; *</span> h_&#123;(t-1)&#125;        </span><br><span class="line">\end&#123;aligned&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<p>$$<br>\begin{aligned}<br>r_{t} =&amp; \sigma(W_{ir}x_{t} + b_{ir} + W_{hr}h_{(t-1)} + b_{hr}) \<br>z_{t} =&amp; \sigma(W_{iz}x_{t} + b_{iz} + W_{hz}h_{(t-1)} + b_{hz}) \<br>n_{t} =&amp; tanh(W_{in}x_{t} + b_{in} + r_{t}*(W_{hn}h_{(t-1)} + b_{hn})) \<br>h_{t} =&amp; (1-z_{t}) * n_{t} + z_{t} * h_{(t-1)}<br>\end{aligned}<br>$$</p>
]]></content>
      <categories>
        <category>Something</category>
      </categories>
      <tags>
        <tag>Something</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode</title>
    <url>/2019/12/10/Something/VSCode/</url>
    <content><![CDATA[<h1 id="VSCode"><a href="#VSCode" class="headerlink" title="VSCode"></a>VSCode</h1><p>神器驾驭指南</p>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><h2 id="2-插件安装"><a href="#2-插件安装" class="headerlink" title="2. 插件安装"></a>2. 插件安装</h2><h2 id="3-快捷键"><a href="#3-快捷键" class="headerlink" title="3. 快捷键"></a>3. 快捷键</h2><ul>
<li><code>F1</code> / <code>Ctrl+shift+P</code> 打开命令面板，可以执行VSCode的任何命令</li>
</ul>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="3-1-在Java中不能导入第三方的库，出现-xxx-unresolve-的问题"><a href="#3-1-在Java中不能导入第三方的库，出现-xxx-unresolve-的问题" class="headerlink" title="3.1 在Java中不能导入第三方的库，出现　xxx unresolve　的问题"></a>3.1 在<code>Java</code>中不能导入第三方的库，出现　<code>xxx unresolve</code>　的问题</h3><p><em>ref: <a href="https://stackoverflow.com/a/57249227" target="_blank" rel="noopener">https://stackoverflow.com/a/57249227</a></em></p>
<p>这种情况下有两种解决方法：</p>
<ul>
<li>使用　<code>maven</code>　或　<code>gradle</code>　引入 <code>Jar</code></li>
<li>按照以下步骤进行： a. 在工程目录下创建　<code>lib</code>　文件夹，放入<code>.jar</code> 文件 　b. 新建 <code>.classpath</code> 在其中　<code>&lt;classpathentry kind=&quot;lib&quot; path=&quot;lib/xxxx.jar&quot;/&gt;</code></li>
<li>以上均不能解决问题，则　<code>F1</code> - input <code>Clean</code> - <code>clean workspace</code></li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://nshen.net/article/2015-11-20/vscode/" target="_blank" rel="noopener">https://nshen.net/article/2015-11-20/vscode/</a></li>
</ul>
]]></content>
      <categories>
        <category>Something</category>
      </categories>
      <tags>
        <tag>Something</tag>
      </tags>
  </entry>
  <entry>
    <title>tmux tutorial</title>
    <url>/2019/01/13/Something/tmux/</url>
    <content><![CDATA[<h1 id="tmux-Tutorial"><a href="#tmux-Tutorial" class="headerlink" title="tmux Tutorial"></a>tmux Tutorial</h1><p>项目地址 <a href="https://github.co/2019/01/13/Something/tmux/tmux" target="_blank" rel="noopener">tmux</a>，终端复用工具.<br>命令参考：<a href="https://www.cnblogs.com/kaiye/p/6275207.html" target="_blank" rel="noopener">https://www.cnblogs.com/kaiye/p/6275207.html</a></p>
<p>tmux 中有几个比较重要的概念：</p>
<ul>
<li>session: 建立一个工作区会话</li>
<li>window: 容纳多个窗格</li>
<li>pane: 可以在窗格中分成多个窗格</li>
<li><code>ctrl + B</code> 基本指令，使用该指令之后，输入的下一个指令解释为 <code>tmux</code> 命令</li>
</ul>
<ol>
<li><p>session 的操作</p>
<ul>
<li>新建 session：<code>tmux new -s name_xxx</code> name_xxx 为 session name</li>
<li>断开当前 session：<code>tmux detach</code> 或者快捷键：<code>ctrl+b</code> + <code>d</code></li>
<li>进入之前的 session：<code>tmux attach-session -t session_name_xxx</code> = <code>tmux a -t session_name_xxx</code>； <code>tmux a</code> 默认进入第一个 session</li>
<li>session 的删除： <code>tmux kill-session -t session_name_xxx</code>：关闭对应的 session；<code>tmux kill-server</code>：关闭服务器，所有会话都将关闭</li>
<li><code>tmux list-session</code> 查看所有 session = <code>tmux l</code></li>
</ul>
</li>
<li><p>一个 session 中新建 window</p>
<p> <code>ctrl+B</code> -&gt; <code>c</code></p>
<p> sesssion 中 window 之间的切换：<br>  <code>ctrl+B</code> -&gt; <code>n</code> 切换 next wiindow；<br>  <code>ctrl+B</code> -&gt; <code>p</code> 切换 previous window</p>
</li>
<li><p>一个 window 里新建 pane</p>
<p> 左右切分 pane: <code>ctrl+B</code> -&gt; <code>%</code>；<br> 上下切分 pane: <code>ctrl+B</code> -&gt; <code>&quot;</code>；<br> pane 之间的切换使用 <code>ctrl+B</code> -&gt; 上下左右；<br> 关闭 pane: <code>ctrl+B</code> -&gt; <code>x</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Something</category>
      </categories>
      <tags>
        <tag>Something</tag>
      </tags>
  </entry>
  <entry>
    <title>PCB</title>
    <url>/2019/11/08/Something/PCB/</url>
    <content><![CDATA[<h1 id="PCB绘制的一些快捷键"><a href="#PCB绘制的一些快捷键" class="headerlink" title="PCB绘制的一些快捷键"></a>PCB绘制的一些快捷键</h1><p><strong>1.右击PCB文件–Split Vertical可以对照原理图进行布线了</strong></p>
<p><strong>2.点击焊盘+ctrl可以高亮显示焊盘之间的连接</strong>  </p>
<p><strong>3.G–栅格管理,GG</strong>   </p>
<p><strong>4.Inspector的运用，可以多选多改</strong></p>
<p><strong>5.V—F适应Board的大小展示</strong>   </p>
<h1 id="AltiumDesigner安装包及推荐书籍"><a href="#AltiumDesigner安装包及推荐书籍" class="headerlink" title="AltiumDesigner安装包及推荐书籍"></a>AltiumDesigner安装包及推荐书籍</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装包（压缩包里自带安装和破解步骤）下载链接：http://pan.baidu.com/s/1gdWJyG7 密码：556y</span><br><span class="line">学习书籍推荐：</span><br><span class="line">		1、</span><br><span class="line">		题名	Altium Designer电路设计从入门到精通 / 闫聪聪等编著</span><br><span class="line">		索书号	TN410.2 282</span><br><span class="line">		主要責任者	闫聪聪 编著</span><br><span class="line">		出版发行	北京 : 机械工业出版社, 2015</span><br><span class="line">		载体形态	X, 452页 : 图 ; 26cm 光盘1片</span><br><span class="line">		ISBN	978-7-111-48794-4 CNY79.00 (含光盘)</span><br><span class="line">			978-7-89405-665-8 光盘</span><br><span class="line"></span><br><span class="line">		2、</span><br><span class="line">		题名	完全掌握Altium Designer 14超级手册 / 杨晓琦等编著</span><br><span class="line">		索书号	TN410.2 279</span><br><span class="line">		主要責任者	杨晓琦 编著</span><br><span class="line">		出版发行	北京 : 机械工业出版社, 2015</span><br><span class="line">		载体形态	XII, 456页 : 图 ; 26cm 光盘1片</span><br><span class="line">		ISBN	978-7-111-48150-8 CNY69.00 (含光盘)</span><br><span class="line">			978-7-89405-553-8 光盘</span><br><span class="line"></span><br><span class="line">		3、</span><br><span class="line">		题名	Altium Designer 14电路设计基础与实例教程 / 李瑞, 闫聪聪等编著</span><br><span class="line">		索书号	TN410.2 289</span><br><span class="line">		主要責任者	李瑞 编著</span><br><span class="line">				闫聪聪 编著</span><br><span class="line">		出版发行	北京 : 机械工业出版社, 2015</span><br><span class="line">		载体形态	316页 : 图 ; 26cm 光盘1片</span><br><span class="line">		ISBN	978-7-111-49699-1 CNY49.90 (含光盘)</span><br><span class="line">			978-7-89405-753-2 光盘</span><br><span class="line"></span><br><span class="line">		4、</span><br><span class="line">		题名	Altium Designer 13电路设计从入门到精通 / 罗瑞, 张自红, 李德俭编著</span><br><span class="line">		索书号	TN410.2 290</span><br><span class="line">		主要責任者	罗瑞 编著</span><br><span class="line">				张自红 编著</span><br><span class="line">				李德俭 编著	</span><br><span class="line">		出版发行	北京 : 中国电力出版社, 2015</span><br><span class="line">		载体形态	348页 : 图 ; 26cm</span><br><span class="line">		ISBN	978-7-5123-7130-9 CNY59.00</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Something</category>
      </categories>
      <tags>
        <tag>Something</tag>
      </tags>
  </entry>
  <entry>
    <title>use-hexo</title>
    <url>/2020/01/05/Something/use-hexo/</url>
    <content><![CDATA[<h1 id="USE-HEXO"><a href="#USE-HEXO" class="headerlink" title="USE-HEXO"></a>USE-HEXO</h1><p>本篇记录将 Blogs 使用 hexo + Next 主题的过程。</p>
<h2 id="1-HEXO"><a href="#1-HEXO" class="headerlink" title="1. HEXO"></a>1. HEXO</h2><blockquote>
<p>Hexo 是高效的静态站点生成框架，基于 Node.js.</p>
</blockquote>
<h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h3><p><code>npm i hexo-cli -g</code></p>
<p>配置 github，文件：<code>_config.yml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/godweiyang/godweiyang.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<h3 id="1-2-常用命令"><a href="#1-2-常用命令" class="headerlink" title="1.2 常用命令"></a>1.2 常用命令</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化文件夹</span></span><br><span class="line">hexo init</span><br><span class="line"><span class="comment"># 生成静态网页</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="comment"># 打开本地服务器</span></span><br><span class="line">hexo s</span><br><span class="line">hexo s --debug</span><br><span class="line"><span class="comment"># 新建文章</span></span><br><span class="line">hexo new post <span class="string">"article title"</span></span><br><span class="line"><span class="comment"># 新建页面</span></span><br><span class="line">hexo new page <span class="string">"page title"</span></span><br><span class="line"><span class="comment"># 新建草稿</span></span><br><span class="line">hexo new draft <span class="string">"draft title"</span></span><br><span class="line"><span class="comment"># 部署到github</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<h3 id="1-3-集成主题-next"><a href="#1-3-集成主题-next" class="headerlink" title="1.3 集成主题 next"></a>1.3 集成主题 <code>next</code></h3><h3 id="1-4-文章模板"><a href="#1-4-文章模板" class="headerlink" title="1.4 文章模板"></a>1.4 文章模板</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"># 文章标题中的空格替换为-</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line"># hexo 支持多个并列 tag</span><br><span class="line">tags:</span><br><span class="line">- A</span><br><span class="line">- B</span><br><span class="line"># hexo 不支持多个并列 category，以下为顺序父子关系</span><br><span class="line">categories:</span><br><span class="line">- A</span><br><span class="line">- B</span><br><span class="line">description:</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="1-5-写文章注意事项"><a href="#1-5-写文章注意事项" class="headerlink" title="1.5 写文章注意事项"></a>1.5 写文章注意事项</h3><p><code>next</code> 能自动识别不同级别的标题</p>
]]></content>
      <categories>
        <category>Something</category>
      </categories>
      <tags>
        <tag>Something</tag>
      </tags>
  </entry>
  <entry>
    <title>缓冲区</title>
    <url>/2019/11/08/C/%E7%BC%93%E5%86%B2%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="缓冲区问题"><a href="#缓冲区问题" class="headerlink" title="缓冲区问题"></a>缓冲区问题</h1><p>这篇文章关于缓冲区讲的比较清楚 <a href="http://blog.csdn.net/sole_cc/article/details/40383033" target="_blank" rel="noopener">http://blog.csdn.net/sole_cc/article/details/40383033</a> 感谢！</p>
<p>今天在Socket编程时，遇到了一些输入与输出缓冲区问题：<br>思考了一下有以下几点：  </p>
<p>stdin,stdout,stderror 标准输入输出应该对应的是键盘输入，显示器输出，显示器输出错误<br><em>缺省情况下是这样的，不过可以进行输入输出重定向到文件:)</em><br>当我们进行标准输入时会输入到缓冲区，并且平时输入的回车键\n也是作为一个字符保留在缓冲区的<strong>回车符一般用来表示输入完成</strong><br><em>\n作为标准输入流输入结束,getchar() scanf()即可从缓冲区取出数据</em><br>在socket编程里send,recv函数应该是将缓冲区数据发送与接收完成后自动清空缓冲区数据，当没有清空缓冲区时，通过键盘输入的数据有时虽不会<strong>立即回显</strong>，  也不太<br>但会保留在缓冲区中，当缓冲区数据需要回显的时候便显示出来  </p>
<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><blockquote>
<ul>
<li>为什么我们从键盘上输入数据会立即回显？ eg:scanf()  </li>
<li>通过回车键\n来作为Socket send()的结束字符?这和scanf()以空格作为结束字符同理？  </li>
<li>缓冲区的一些操作？  </li>
</ul>
</blockquote>
<h2 id="10-13-2017-补"><a href="#10-13-2017-补" class="headerlink" title="10/13/2017 补"></a>10/13/2017 补</h2><p>经查询后，发现缓冲区确实类似上述的操作，  </p>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p><strong>全缓冲</strong>  </p>
<blockquote>
<ul>
<li></li>
</ul>
<p><strong>行缓冲</strong>   </p>
<ul>
<li>代表为 stdin stdout</li>
</ul>
</blockquote>
<p><strong>不缓冲</strong>  </p>
<blockquote>
<ul>
<li>代表为 stderr <strong>标准错误当然是不能进行缓冲直接进行显示出来的哦</strong></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>week12</title>
    <url>/2019/11/21/TODO/week12/</url>
    <content><![CDATA[<h1 id="第十二周"><a href="#第十二周" class="headerlink" title="第十二周"></a>第十二周</h1><h2 id="Course"><a href="#Course" class="headerlink" title="Course"></a>Course</h2><ol>
<li>《数值分析》 陈研：</li>
</ol>
<ul>
<li>函数逼近 6 讲</li>
<li>数值积分 5 讲</li>
<li>常微分方程 7 讲</li>
<li>偏微分方程 8 讲</li>
</ul>
<ol start="2">
<li><p>《大数据技术》报告</p>
</li>
<li><p>《HadoopMapreduce》</p>
</li>
</ol>
<h3 id="cs224n"><a href="#cs224n" class="headerlink" title="cs224n"></a>cs224n</h3><p>课程主页：<a href="http://web.stanford.edu/class/cs224n/index.html#schedule" target="_blank" rel="noopener">http://web.stanford.edu/class/cs224n/index.html#schedule</a><br>视频地址：<a href="https://www.youtube.com/playlist?list=PLoROMvodv4rOhcuXMZkNm7j3fVwBBY42z" target="_blank" rel="noopener">https://www.youtube.com/playlist?list=PLoROMvodv4rOhcuXMZkNm7j3fVwBBY42z</a></p>
<ol>
<li>Introduction and Word Vectors, Gensim word vectors example:</li>
<li>Word Vectors 2 and Word Senses</li>
<li>Python review session</li>
<li>Word Window Classification, Neural Networks, and Matrix Calculus</li>
<li>Backpropagation and Computation Graphs</li>
<li>Linguistic Structure: Dependency Parsing</li>
<li>The probability of a sentence? Recurrent Neural Networks and Language Models</li>
<li>Vanishing Gradients and Fancy RNNs</li>
<li>Machine Translation, Seq2Seq and Attention</li>
<li>Practical Tips for Final Projects</li>
<li>Question Answering and the Default Final Project</li>
<li>ConvNets for NLP</li>
<li>Information from parts of words: Subword Models</li>
<li>Modeling contexts of use: Contextual Representations and Pretraining</li>
<li>Transformers and Self-Attention For Generative Models</li>
<li>Natural Language Generation</li>
<li>Reference in Language and Coreference Resolution</li>
<li>Multitask Learning: A general model for NLP?</li>
<li>Constituency Parsing and Tree Recursive Neural Networks</li>
<li>Safety, Bias, and Fairness</li>
<li>Future of NLP + Deep Learning</li>
</ol>
<h3 id="Machine-Learning-李宏毅"><a href="#Machine-Learning-李宏毅" class="headerlink" title="Machine Learning 李宏毅"></a>Machine Learning 李宏毅</h3><p>视频地址： <a href="https://www.youtube.com/watch?v=CXgbekl66jc&amp;list=PLJV_el3uVTsPy9oCRY30oBPNLCo89yu49" target="_blank" rel="noopener">https://www.youtube.com/watch?v=CXgbekl66jc&amp;list=PLJV_el3uVTsPy9oCRY30oBPNLCo89yu49</a></p>
<h3 id="Task："><a href="#Task：" class="headerlink" title="Task："></a>Task：</h3><ol>
<li>《数值分析》每天2-3讲</li>
<li>《cs224n》 每天1讲</li>
</ol>
<h2 id="Laborary"><a href="#Laborary" class="headerlink" title="Laborary"></a>Laborary</h2><ol>
<li><p>学习 <code>pytorch</code> 的使用，能基本理解神经网络的搭建步骤，看懂代码的大致流程，并跑一段 RNN 的示例</p>
</li>
<li><p>研读至少3篇事件抽取综述和最新进展的论文，并做好笔记，记录发展历程</p>
</li>
<li><p>尝试阅读事件抽取的 code，并做一些尝试</p>
</li>
</ol>
<h2 id="保持作息，注意运动，劳逸结合"><a href="#保持作息，注意运动，劳逸结合" class="headerlink" title="保持作息，注意运动，劳逸结合"></a>保持作息，注意运动，劳逸结合</h2>]]></content>
      <categories>
        <category>TODO</category>
      </categories>
      <tags>
        <tag>TODO</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包 与 装饰器</title>
    <url>/2020/04/24/Python/closure-decorator/</url>
    <content><![CDATA[<h1 id="闭包（Closure）"><a href="#闭包（Closure）" class="headerlink" title="闭包（Closure）"></a>闭包（Closure）</h1><h1 id="装饰器-（Decorator）"><a href="#装饰器-（Decorator）" class="headerlink" title="装饰器 （Decorator）"></a>装饰器 （Decorator）</h1><p>装饰器的主要依据是<strong>python中函数是一个对象，函数对象可以赋值给变量，通过变量调用函数</strong></p>
<h2 id="不带参数的装饰器"><a href="#不带参数的装饰器" class="headerlink" title="不带参数的装饰器"></a>不带参数的装饰器</h2><h2 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h2><h2 id="调用序列"><a href="#调用序列" class="headerlink" title="调用序列"></a>调用序列</h2><p>关于接受参数的包装器的调用序列，看到 ptython-cookbook 上的，对于理解 装饰器很有帮助；</p>
<blockquote>
<p>定义一个接受参数的包装器看上去比较复杂主要是因为底层的调用序列。特别的，如果你有下面这个代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@decorator(x, y, z)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>装饰器处理过程跟下面的调用是等效的;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>func = decorator(x, y, z)(func)<br>decorator(x, y, z) 的返回结果必须是一个可调用对象，它接受一个函数作为参数并包装它</p>
</blockquote>
<p>举个栗子：</p>
<p>如何查看函数被调用了多少次？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallingCounter</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span> <span class="params">(self, func)</span>:</span></span><br><span class="line">        self.func = func</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span> <span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_func</span><span class="params">(func)</span>:</span></span><br><span class="line">    num = [<span class="number">0</span>]   <span class="comment"># 闭包中外函数中的变量指向的引用不可变</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call_func</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        num[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">        print(<span class="string">"执行次数"</span>,num[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> call_func</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「宁致乐水」的原创文章，遵循CC <span class="number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/qq_31603575/article/details/<span class="number">80011287</span></span><br></pre></td></tr></table></figure>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/22229197" target="_blank" rel="noopener">深入浅出python闭包</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017451662295584" target="_blank" rel="noopener">廖雪峰的官方网站</a></li>
<li><a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/c09/p04_define_decorator_that_takes_arguments.html" target="_blank" rel="noopener">python3-cookbook</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>InputFormat</title>
    <url>/2019/12/10/BigDataSystem/Batch/InputFormat/</url>
    <content><![CDATA[<h1 id="Hadoop-InputFormat"><a href="#Hadoop-InputFormat" class="headerlink" title="Hadoop InputFormat"></a>Hadoop InputFormat</h1><h2 id="What-is-Hadoop-InputFormat"><a href="#What-is-Hadoop-InputFormat" class="headerlink" title="What is Hadoop InputFormat?"></a>What is Hadoop InputFormat?</h2><blockquote>
<p>Hadoop InputFormat describes the input-specification for execution of the Map-Reduce job.</p>
</blockquote>
<blockquote>
<p>InputFormat describes how to split up and read input files. In MapReduce job execution, InputFormat is the first step. It is also responsible for creating the input splits and dividing them into records.</p>
</blockquote>
<blockquote>
<p>Input files store the data for MapReduce job. Input files reside in HDFS. Although these files format is arbitrary, we can also use line-based log files and binary format. Hence, In MapReduce, InputFormat class is one of the fundamental classes which provides below functionality:</p>
</blockquote>
<ul>
<li>InputFormat selects the files or other objects for input.</li>
<li>It also defines the Data splits. It defines both the size of individual Map tasks and its potential execution server.</li>
<li>Hadoop InputFormat defines the RecordReader. It is also responsible for reading actual records from the input files.</li>
</ul>
<h2 id="Types-of-InputFormat-in-MapReduce"><a href="#Types-of-InputFormat-in-MapReduce" class="headerlink" title="Types of InputFormat in MapReduce"></a>Types of InputFormat in MapReduce</h2><ul>
<li><code>FileInputFormat</code></li>
<li><code>TextInputFormat</code></li>
<li><code>KeyValueTextInputFormat</code></li>
<li><code>SequenceFileAsTextInputFormat</code></li>
<li><code>SequenceFileAsBinaryInputFormat</code></li>
<li><code>NlineInputFormat</code></li>
<li><code>DBInputFormat</code></li>
</ul>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><blockquote>
<p>Hence, InputFormat defines how to read data from a file into the Mapper instances. In this tutorial, we have learned many types of InputFormat like FileInputFormat, TextInputFormat etc. The default input format is TextInputFormat. If you have any query related to MapReduce InputFormat, so feel free to share with us. Hope we will solve them.</p>
</blockquote>
]]></content>
      <categories>
        <category>BigDataSystem</category>
        <category>Batch</category>
      </categories>
      <tags>
        <tag>BigDataSystem</tag>
        <tag>Batch</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop IO 操作</title>
    <url>/2020/01/06/BigDataSystem/Batch/hadoop-IO/</url>
    <content><![CDATA[<h1 id="Hadoop-IO-的常见操作"><a href="#Hadoop-IO-的常见操作" class="headerlink" title="Hadoop IO 的常见操作"></a>Hadoop IO 的常见操作</h1><h2 id="1-一种比较common的文件打开方式"><a href="#1-一种比较common的文件打开方式" class="headerlink" title="1. 一种比较common的文件打开方式"></a>1. 一种比较common的文件打开方式</h2><p>注：这里并不使用 <code>java.io.File</code>　打开文件，因为这种方式只能打开本地文件，对于HDFS文件不支持打开；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FSDataInputStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"></span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">FSDataInputStream fsr = <span class="keyword">null</span>;</span><br><span class="line">BufferedReader bufferedReader = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FileSystem fs = FileSystem.get(URI.create(txtFilePath),conf);</span><br><span class="line">fsr = fs.open(<span class="keyword">new</span> Path(txtFilePath));</span><br><span class="line">bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(fsr));</span><br><span class="line"><span class="keyword">while</span> ((lineTxt = bufferedReader.readLine()) != <span class="keyword">null</span>) ...</span><br></pre></td></tr></table></figure>

<h2 id="2-列出HDFS文件目录下的所有文件"><a href="#2-列出HDFS文件目录下的所有文件" class="headerlink" title="2. 列出HDFS文件目录下的所有文件"></a>2. 列出HDFS文件目录下的所有文件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> FileSystem fs;</span><br><span class="line">fs = FileSystem.get(URI.create(args[<span class="number">0</span>]), conf);</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Path&gt; <span class="title">GetPaths</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException, FileNotFoundException </span>&#123;</span><br><span class="line">	<span class="comment">// 获取path路径下所有子文件夹路径</span></span><br><span class="line">	ArrayList&lt;Path&gt; paths = <span class="keyword">new</span> ArrayList&lt;Path&gt;();</span><br><span class="line"><span class="comment">//	File file = new File(path);</span></span><br><span class="line">	FileStatus file = fs.getFileStatus(<span class="keyword">new</span> Path(path));</span><br><span class="line">	<span class="comment">// 如果这个路径是文件夹</span></span><br><span class="line">	<span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">		<span class="comment">// 获取路径下的所有文件</span></span><br><span class="line"><span class="comment">//		File[] files = file.listFiles();</span></span><br><span class="line">		FileStatus[] files = fs.listStatus(file.getPath());</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;files.length; i++) &#123;</span><br><span class="line">			<span class="comment">// 如果还是文件夹</span></span><br><span class="line">			<span class="keyword">if</span> (files[i].isDirectory()) &#123;</span><br><span class="line">				<span class="comment">// 将其加入路径列表</span></span><br><span class="line">				paths.add(files[i].getPath());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;<span class="keyword">continue</span>;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> paths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>BigDataSystem</category>
        <category>Batch</category>
      </categories>
      <tags>
        <tag>BigDataSystem</tag>
        <tag>Batch</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark</title>
    <url>/2019/12/10/BigDataSystem/Memory/Spark/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>BigDataSystem</category>
        <category>Memory</category>
      </categories>
      <tags>
        <tag>BigDataSystem</tag>
        <tag>Memory</tag>
      </tags>
  </entry>
  <entry>
    <title>README</title>
    <url>/2019/12/28/BigDataSystem/Consistency/README/</url>
    <content><![CDATA[<h1 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h1><p>一致性问题，一致性问题是分布式系统中比较常见的问题。</p>
<p>这里主要分析 <code>Paxo</code> 与 <code>Raft</code> 两种分布式一致性协议。</p>
]]></content>
      <categories>
        <category>BigDataSystem</category>
        <category>Consistency</category>
      </categories>
      <tags>
        <tag>BigDataSystem</tag>
        <tag>Consistency</tag>
      </tags>
  </entry>
  <entry>
    <title>CPP 三大函数</title>
    <url>/2020/05/27/C/CPP/CPP%E4%B8%89%E5%A4%A7%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="C-中的三大函数"><a href="#C-中的三大函数" class="headerlink" title="C++ 中的三大函数"></a>C++ 中的三大函数</h1>]]></content>
      <categories>
        <category>C</category>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ README</title>
    <url>/2019/11/08/C/CPP/README/</url>
    <content><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><h2 id="C-演变"><a href="#C-演变" class="headerlink" title="C++ 演变"></a>C++ 演变</h2><ul>
<li>c++ 98（1.0）</li>
<li>c++ 03</li>
<li>c++ 11（2.0）</li>
<li>c++ 14</li>
</ul>
<h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>class 可以分为：</p>
<ul>
<li>base: without pointer（成员变量中不带指针）</li>
<li>oriented：with pointer（成员变量中带有指针）</li>
</ul>
]]></content>
      <categories>
        <category>C</category>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>Storm</title>
    <url>/2019/12/10/BigDataSystem/Stream/Storm/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>BigDataSystem</category>
        <category>Stream</category>
      </categories>
      <tags>
        <tag>BigDataSystem</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>MultiDefinition</title>
    <url>/2019/11/08/C/CPP/MultiDefinition/</url>
    <content><![CDATA[<h1 id="multiple-definition"><a href="#multiple-definition" class="headerlink" title="multiple definition"></a>multiple definition</h1><p>重复定义问题，以前没有注意到这个问题，觉得会有这种影响吗？不还是有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndefine</span><br><span class="line">#define</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>这就大错特错了，为什么呢？因为这涉及到<strong>重复定义</strong>与<strong>重复包含</strong>问题</p>
<h2 id="重复包含-multiple-include"><a href="#重复包含-multiple-include" class="headerlink" title="重复包含(multiple include)"></a>重复包含(multiple include)</h2><p>这里指的是在编译阶段进行宏展开时，为了避免重复包含某个头文件，而采取的 define方法</p>
<p><strong>场景</strong></p>
<p><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong>test1.h<strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">...</span><br><span class="line">int a = 1;</span><br><span class="line">char a[]=&quot;Hello world&quot;;</span><br></pre></td></tr></table></figure>
<p><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong>test2.h<strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;test1.h&quot;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">int b = 1;</span><br><span class="line">int c = 2;</span><br></pre></td></tr></table></figure>
<p><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong>test.cpp<strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;test1.h&quot;</span><br><span class="line">#include &quot;test2.h&quot;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>编译阶段进行宏展开时会报错，重复包含了！！！</p>
<h2 id="重复定义-multiple-definition"><a href="#重复定义-multiple-definition" class="headerlink" title="重复定义(multiple definition)"></a>重复定义(multiple definition)</h2><p><strong>场景</strong><br><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong>test1.h<strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifnfine ...</span><br><span class="line">#define ...</span><br><span class="line">int a = 1;</span><br><span class="line">char a[]=&quot;Hello world&quot;;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong>test2.h<strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndefine ...</span><br><span class="line">#define ...</span><br><span class="line"></span><br><span class="line">#include &quot;test1.h&quot;</span><br><span class="line"></span><br><span class="line">int b = 1;</span><br><span class="line">int c = 2;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p><strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong>test.cpp<strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;test1.h&quot;</span><br><span class="line">#include &quot;test2.h&quot;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>会报出重复定义错误<br>原因：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">工程中的.cpp文件都是独立解释的，每份.cpp文件解释后会生成一份符号表（编译之后），但在链接时因为每份符号表都有定义就出现了</span><br><span class="line">重复定义的情况</span><br></pre></td></tr></table></figure>

<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>1.当我们需要一份常量头文件时，如   </p>
<p><strong><strong><strong><strong>****</strong></strong></strong></strong>global.h<strong><strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndefine GLOBAL_H_</span><br><span class="line">#define GLOBAL_H_</span><br><span class="line"></span><br><span class="line">Pi = 3.1415926;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>可以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在.c文件中声明变量，然后建一个头文件(.h文件)在所有的变量声明前加上extern，注意这里不要对变量进行的初始化。</span><br><span class="line">然后在其他需要使用全局变量的.c文件中包含.h文件。编译器会为.c生成目标文件，然后链接时，如果该.c文件使用了全局变量，链接器就会链接到此.c文件</span><br></pre></td></tr></table></figure>

<p>2.当函数设置成内嵌 inline 时，也不会出现重复定义，不过一般不建议这样做</p>
]]></content>
      <categories>
        <category>C</category>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>Template</title>
    <url>/2019/11/08/C/CPP/Template/</url>
    <content><![CDATA[<h1 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h1><p>关于函数模板与函数重载</p>
<h2 id="Function-Template"><a href="#Function-Template" class="headerlink" title="Function Template"></a>Function Template</h2><p>函数模板：<br>建立一个通用函数，其类型名与参数类型都不确定，用虚拟类型来代替<br>定义（声明）：  </p>
<ul>
<li>template <typename T>  或</li>
<li>template <class T><br>当有多个不同类型的参数时  </li>
<li>template &lt;class T1,typename T2&gt; </li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    template &lt;typename Type&gt;              //这里是类模板的声明</span><br><span class="line"></span><br><span class="line">class stackTest &#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    stackTest();</span><br><span class="line">    bool isempty();</span><br><span class="line">    bool isfull();</span><br><span class="line">    bool push(const Type &amp; item);</span><br><span class="line">    bool pop(Type &amp; item);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    enum &#123;MAX = 10&#125;;                //声明constant variables</span><br><span class="line">    Type items[MAX];</span><br><span class="line">    int top;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">    template &lt;typename Type&gt;            //这里是函数模板的声明，每一函数前都要声明</span><br><span class="line">    stackTest&lt;Type&gt;::stackTest() &#123;</span><br><span class="line">    top = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Type&gt;</span><br><span class="line">bool stackTest&lt;Type&gt;::isempty() &#123;</span><br><span class="line">        return top == 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Type&gt;</span><br><span class="line">bool stackTest&lt;Type&gt;::isfull() &#123;</span><br><span class="line">    return top == MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Type&gt;</span><br><span class="line">bool stackTest&lt;Type&gt;::push(const Type &amp;item) &#123;</span><br><span class="line">    if (isfull())   return false;</span><br><span class="line">    else &#123;</span><br><span class="line">        items[top] = item;</span><br><span class="line">        top ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Type&gt;</span><br><span class="line">bool stackTest&lt;Type&gt;::pop(Type &amp;item) &#123;</span><br><span class="line">    if(isempty()) return false;</span><br><span class="line">    else &#123;</span><br><span class="line">        item = items[--top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Function-overloading"><a href="#Function-overloading" class="headerlink" title="Function overloading"></a>Function overloading</h2><p>函数重载：<br>一个函数名重新赋予它新的含义，使一个函数名可以多用</p>
]]></content>
      <categories>
        <category>C</category>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop 监控</title>
    <url>/2020/01/06/BigDataSystem/Batch/hadoop-monitor/</url>
    <content><![CDATA[<h1 id="Hadoop-监控"><a href="#Hadoop-监控" class="headerlink" title="Hadoop 监控"></a>Hadoop 监控</h1><h2 id="1-网页查看集群的状态"><a href="#1-网页查看集群的状态" class="headerlink" title="1. 网页查看集群的状态"></a>1. 网页查看集群的状态</h2><h3 id="1-1-hdfs的集群状态"><a href="#1-1-hdfs的集群状态" class="headerlink" title="1.1 hdfs的集群状态"></a>1.1 <code>hdfs</code>的集群状态</h3><ul>
<li>配置： <code>hdfs-site.xml--dfs.namenode.http-address</code></li>
<li>访问地址： <code>http://namenode-ip:50070</code></li>
</ul>
<h3 id="1-2-secondary-namenode-的集群状态"><a href="#1-2-secondary-namenode-的集群状态" class="headerlink" title="1.2 secondary namenode　的集群状态"></a>1.2 <code>secondary namenode</code>　的集群状态</h3><ul>
<li>配置： <code>hdfs-site.xml--dfs.namenode.secondary.http-address</code></li>
<li>访问地址： <code>http://namenode-ip:50090</code></li>
</ul>
<h3 id="1-3-yarn的集群状态"><a href="#1-3-yarn的集群状态" class="headerlink" title="1.3 yarn的集群状态"></a>1.3 <code>yarn</code>的集群状态</h3><ul>
<li>配置： <code>yarn-site.xml--yarn.resourcemanager.webapp.address</code></li>
<li>访问地址： <code>http://resource-manager-ip:8088</code></li>
</ul>
]]></content>
      <categories>
        <category>BigDataSystem</category>
        <category>Batch</category>
      </categories>
      <tags>
        <tag>BigDataSystem</tag>
        <tag>Batch</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 程序设计要点</title>
    <url>/2020/02/11/C/CPP/CPP-by-hou-jie/</url>
    <content><![CDATA[<h1 id="C-程序设计要点"><a href="#C-程序设计要点" class="headerlink" title="C++ 程序设计要点"></a>C++ 程序设计要点</h1><h2 id="几个比较成熟的设计准则"><a href="#几个比较成熟的设计准则" class="headerlink" title="几个比较成熟的设计准则"></a>几个比较成熟的设计准则</h2><ul>
<li>多使用 <code>initialization list</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">complex</span> (<span class="keyword">double</span> r = <span class="number">0</span>, <span class="keyword">double</span> i = <span class="number">0</span>)</span><br><span class="line">    : re(r), im(i)</span><br><span class="line">    &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意成员函数能否加上 <code>const</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">real</span> <span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> re; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>inline</code> 多写无害，编译器会根据函数的复杂程度自动决定是否应该 <code>inline</code>；函数若在 class body 内定义完成，便自动成为 inline 候选人</p>
</li>
<li><p>尽量使用 <code>pass by reference</code>，少使用 <code>pass by value</code>，同时还要注意 <code>const</code> 是否加入</p>
</li>
<li><p>同理，尽量使用 <code>return by reference</code>, 少使用 <code>return by value</code></p>
</li>
<li><p>function 尽量 public, data 尽量 private</p>
</li>
<li><p>当 <code>static</code> 用在成员函数中时，没有 <code>this</code> 指针，因此只能修改 <code>static variable</code>，不能修改 <code>object variable</code></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>类模板（class template）与函数模板（function template）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">complex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">complex</span> (T r= <span class="number">0</span>, T i = <span class="number">0</span>)</span><br><span class="line">            : re (r), im (i)</span><br><span class="line">            &#123;&#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">// <span class="title">template</span>&lt;typename T&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span></span></span><br><span class="line"><span class="class"><span class="title">const</span> <span class="title">T</span>&amp; <span class="title">min</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">a</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">b</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> b &lt; a ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="comment">// 类模板需要声明变量的类型：double</span></span><br><span class="line"><span class="keyword">complex</span>&lt;<span class="keyword">double</span>&gt; c1(<span class="number">2.5</span>, <span class="number">1.5</span>);</span><br><span class="line"><span class="comment">// 函数模板不需要声明变量类型：编译器自动推导</span></span><br><span class="line">stone r1(2,3), r2(3,3), r3;</span><br><span class="line">r3 = <span class="built_in">min</span>(r1, r2);</span><br></pre></td></tr></table></figure>

<ul>
<li>相同 class 的各个 objects 互为 friends（友元）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">String</span>::<span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">String</span>&amp; str)</span><br><span class="line">&#123;</span><br><span class="line">    m_data = <span class="keyword">new</span> <span class="keyword">char</span>[ <span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span> ];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_data, str.m_data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>new</code> 与 <code>delete</code>：<code>array new</code> – <code>array delete</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span></span><br><span class="line"><span class="keyword">String</span>::~<span class="keyword">String</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] m_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>临时对象（temporary object）的声明与定义</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">complex</span>();</span><br><span class="line"><span class="keyword">complex</span>(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 当程序执行到这一行的时候前面两个对象的生命周期结束</span></span><br></pre></td></tr></table></figure>

<p>Class 的两种经典分类：</p>
<ul>
<li>Class without pointer member(s)</li>
<li>Class with pointer member(s)</li>
</ul>
<p>对于 <code>Class with pointer members</code>，要显式定义三大函数<code>Big Three</code>：拷贝构造函数、拷贝赋值函数、析构函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line"><span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">String</span>&amp; str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝赋值函数</span></span><br><span class="line"><span class="keyword">String</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="keyword">String</span>&amp; str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 析构函数</span></span><br><span class="line">~<span class="keyword">String</span>();</span><br></pre></td></tr></table></figure>

<p>显式地定义三大函数的原因是，编译器会自动为 class 添加默认的拷贝构造与拷贝赋值函数，两个函数的行为均为对 object 的逐个字节复制，这样会使 指针 指向同一个地址。析构函数是为了释放指针指向的地址空间，防止内存泄漏。（memory leak）</p>
]]></content>
      <categories>
        <category>C</category>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>inline 关键字的使用</title>
    <url>/2020/02/11/C/CPP/inline/</url>
    <content><![CDATA[<h1 id="inline"><a href="#inline" class="headerlink" title="inline"></a><code>inline</code></h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.runoob.com/w3cnote/cpp-inline-usage.html" target="_blank" rel="noopener">c++中的inline用法</a></li>
</ul>
]]></content>
      <categories>
        <category>C</category>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>README</title>
    <url>/2019/11/08/C/Make/README/</url>
    <content><![CDATA[<h1 id="Make"><a href="#Make" class="headerlink" title="Make"></a>Make</h1><p>一直以来 build 文件的时候知道有个  Makefile  可是具体三要素（背景，实现与功能）都不清楚</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>《阮一峰的网络日志》  <a href="http://www.ruanyifeng.com/blog/2015/02/make.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/02/make.html</a></li>
<li>《GNU Make》  <a href="https://www.gnu.org/software/make/manual/make.html" target="_blank" rel="noopener">https://www.gnu.org/software/make/manual/make.html</a></li>
<li>博客  <a href="http://blog.csdn.net/ruglcc/article/details/7814546/" target="_blank" rel="noopener">http://blog.csdn.net/ruglcc/article/details/7814546/</a></li>
</ul>
]]></content>
      <categories>
        <category>C</category>
        <category>Make</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Make</tag>
      </tags>
  </entry>
  <entry>
    <title>namespace</title>
    <url>/2019/11/08/C/CPP/namespace/</url>
    <content><![CDATA[<h1 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h1><p>关于命名空间的使用</p>
<ul>
<li>概念</li>
</ul>
<p><code>命名空间，所谓命名空间，实际上就是一个由程序设计者命名的内存区域</code></p>
<ul>
<li>背景</li>
</ul>
<p>在不同的头文件中包含有相同的函数名或者类名时，同时包含两个头文件，预编译是会出现编译错误，歧义</p>
<ul>
<li>解决方式</li>
</ul>
<p>1.别名</p>
<p><code>namespace TV = Television</code></p>
<p>2.using 命名空间成员名</p>
<p><code>using std::cout</code></p>
<p>3.using namespace 命名空间名</p>
<p><code>using namespace std</code>  但这种方式在有很多命名空间时会带来麻烦</p>
<p>4.常用方式</p>
<p>命名空间较少或者类名与函数名较少时，常用 using namespace 的方式<br>命名空间较多的时候常用一个头文件把 需要用到的类或函数包含在内  using xx::xx,using xx::yy,using yy::yy</p>
<ul>
<li>备注</li>
</ul>
<p>1.当在mian函数中全局声明的变量，表面上不属于任何命名空间，实则属于隐含的 全局空间<br>2.在命名空间中不能包含预处理<br>3.命名空间可以嵌套</p>
]]></content>
      <categories>
        <category>C</category>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile</title>
    <url>/2019/11/08/C/Make/Makefile/</url>
    <content><![CDATA[<h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><p>Makefile 文件是  make  的规则文件，是一种 build 脚本，里面阐明了编译链接的顺序及所需要的相关文件</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>命令规则：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">target:prerequisites</span><br><span class="line">  command</span><br></pre></td></tr></table></figure>
<p>target 为目标文件，prerequisites为依赖文件，commmand为要执行的shell命令<strong>前面要以TAB键开头</strong><br>并默认第一个目标文件为最终要生成的目标文件，然后后续的过程就是以这个文件为根，进行依赖文件展开，检查时间戳，执行规则  </p>
<p>时间戳：这里指的是 make  可以在编译过程中依据文件的更新程度来决定哪些文件需要重新编译，哪些文件需要重新链接生成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">       insert.o search.o files.o utils.o</span><br><span class="line">        cc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">                   insert.o search.o files.o utils.o</span><br><span class="line"> </span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">        cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">        cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">        cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">        cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">        cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">        cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">        cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">        cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">        rm edit main.o kbd.o command.o display.o \</span><br><span class="line">           insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>
<p>以此makefile文件为例，若command.c发生改变，只需重新编译生成新的中间代码文件command.o，再重新进行链接<br>但如果 defs.h  文件发生改变，则全部.o文件都需要重新编译，重新链接</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>当然了上述.o文件一大堆，可以用一个变量名来代替，引用变量用  $(object) 或者  ${object}</p>
<p>上面可以修改成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">          insert.osearch.o files.o utils.o </span><br><span class="line">edit : $(objects)</span><br><span class="line">        cc -o edit $(objects)</span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">        cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">        cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">        cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">        cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">        cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">        cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">        cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">        cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">        rm edit $(objects)</span><br></pre></td></tr></table></figure>



<h2 id="自动推导"><a href="#自动推导" class="headerlink" title="自动推导"></a>自动推导</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。</span><br><span class="line">并且 cc -c whatever.c 也会被推导出来</span><br></pre></td></tr></table></figure>
<p>画风就变成了酱紫  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">          insert.o search.o files.o utils.o</span><br><span class="line"> </span><br><span class="line">edit : $(objects)</span><br><span class="line">        cc -o edit $(objects)</span><br><span class="line"> </span><br><span class="line">main.o : defs.h</span><br><span class="line">kbd.o : defs.h command.h</span><br><span class="line">command.o : defs.h command.h</span><br><span class="line">display.o : defs.h buffer.h</span><br><span class="line">insert.o : defs.h buffer.h</span><br><span class="line">search.o : defs.h buffer.h</span><br><span class="line">files.o : defs.h buffer.h command.h</span><br><span class="line">utils.o : defs.h</span><br><span class="line"> </span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">        rm edit $(objects)</span><br></pre></td></tr></table></figure>




















]]></content>
      <categories>
        <category>C</category>
        <category>Make</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Make</tag>
      </tags>
  </entry>
  <entry>
    <title>重载 覆盖 与 隐藏</title>
    <url>/2020/05/27/C/CPP/%E9%87%8D%E8%BD%BD_%E8%A6%86%E7%9B%96_%E9%9A%90%E8%97%8F/</url>
    <content><![CDATA[<h1 id="重载、覆盖与隐藏"><a href="#重载、覆盖与隐藏" class="headerlink" title="重载、覆盖与隐藏"></a>重载、覆盖与隐藏</h1><p>这几个是涉及到父类与子类之间同名函数不同含义的问题，这里做一下总结：</p>
<h2 id="overloading（重载）"><a href="#overloading（重载）" class="headerlink" title="overloading（重载）"></a>overloading（重载）</h2><p>函数重载虽然函数名相同，但其实是不同的函数，<code>overloading</code> 的关键区分点在于：<code>函数形参的设置</code>，即在编译器编译时不发生冲突/歧义即可。</p>
<blockquote>
<p>《高质量C++/C编程指南》已经清晰的列出了重载函数的特性：</p>
<p>（1）相同的范围（在同一个类中）；</p>
<p> （2）函数名字相同；</p>
<p> （3）参数不同；</p>
<p> （4）virtual关键字可有可无。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 两个 complex 构造函数有歧义</span></span><br><span class="line"><span class="keyword">complex</span> (<span class="keyword">double</span> r = <span class="number">0</span>, <span class="keyword">double</span> i = <span class="number">0</span>)</span><br><span class="line">    : re (r), im(i)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"><span class="keyword">complex</span> () : re(<span class="number">0</span>), im(<span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b )</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"This is first /n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> a)</span>     <span class="comment">// 同一函数中，函数名相同，参数不同</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"This is second/n"</span>); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	a.<span class="built_in">display</span>(<span class="number">5</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Override-（覆盖，重写）"><a href="#Override-（覆盖，重写）" class="headerlink" title="Override （覆盖，重写）"></a>Override （覆盖，重写）</h2><blockquote>
<p> 派生类函数覆盖基类函数，只作用于派生类；</p>
<p>（1）不同的范围（分别位于派生类与基类）； </p>
<p>（2）函数名字相同；</p>
<p>（3）参数相同；</p>
<p>（4）基类函数必须有virtual关键字。</p>
</blockquote>
<h2 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h2><p>隐藏是指派生类函数将基类函数藏起来了，只作用于派生类函数</p>
<blockquote>
<p> 1）如果派生类的函数与基类的函数名相同，但是参数不同。此时，不论有无virtual关键字。此时，基类函数会被隐藏。</p>
<p> 2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"fn in A\n"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">v_fn</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"virtual fn in A\n"</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fn</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"fn in B\n"</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">v_fn</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"virtual fn in B\n"</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A *a = <span class="keyword">new</span> B();</span><br><span class="line">    a-&gt;fn();</span><br><span class="line">    a-&gt;v_fn();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/My_heart_/article/details/51730980" target="_blank" rel="noopener">https://blog.csdn.net/My_heart_/article/details/51730980</a></li>
</ul>
]]></content>
      <categories>
        <category>C</category>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>GoogleHack</title>
    <url>/2019/11/08/CypherSecurity/2016/GoogleHack/</url>
    <content><![CDATA[<h1 id="GoogleHack"><a href="#GoogleHack" class="headerlink" title="GoogleHack"></a>GoogleHack</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<ul>
<li>寻找持续构建工具Jenkins的管理面板   </li>
<li>搞定xampp  </li>
<li>后门查找  </li>
<li>google hack database  </li>
</ul>
</blockquote>
<h2 id="GoogleHack查询语法"><a href="#GoogleHack查询语法" class="headerlink" title="GoogleHack查询语法"></a>GoogleHack查询语法</h2>]]></content>
      <categories>
        <category>CypherSecurity</category>
        <category>2016</category>
      </categories>
      <tags>
        <tag>CypherSecurity</tag>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title>static_extern_const</title>
    <url>/2019/11/08/C/CPP/static_extern_const/</url>
    <content><![CDATA[<h1 id="static-extern-const"><a href="#static-extern-const" class="headerlink" title="static extern const"></a>static extern const</h1><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>静态，声明后变量的存储区域位于静态存储区</p>
<ul>
<li><strong>静态局部变量</strong>：变量声明后位于静态存储区，但作用域仍限定在函数内部，即<strong>不能被其他函数访问</strong></li>
<li><strong>静态全局变量</strong>：全局变量已经是静态的为什么还有static呢？作用在于限定作用域为本文件内部，即使其他文件 extern 也不能被访问到</li>
</ul>
<h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><p>引用，引用位于其它地方的声明，函数，变量等<br>如多个文件，一个文件中全局 int a;另一个文件中可以 extern int a;告诉编译器到其他文件中查找 a 的定义；</p>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>这家伙用处比较大，容我一一道来<br><strong>用const即意味着此对象不能够被改变</strong></p>
<h3 id="常对象成员"><a href="#常对象成员" class="headerlink" title="常对象成员"></a>常对象成员</h3><p><strong>声明</strong></p>
<ol>
<li>类名 const 对象名: Student const stu1;  </li>
<li>const 类名 对象名: const Student stu1;  </li>
</ol>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul>
<li>常对象的数据成员全部是<strong>常数据成员</strong>     </li>
</ul>
<p><em>如何初始化呢?</em>   构造函数的参数初始化表方式，不二法门!  </p>
<ul>
<li>成员函数可不是常成员函数了，性质不变，但权限变了，<strong>非常成员函数不得访问常对象数据，常成员函数能够访问不得修改!</strong>     </li>
</ul>
<p><em>如何声明常成员函数呢？</em>   void get_time() const; 函数后加一个<strong>const</strong></p>
<ul>
<li>常成员函数不能调用另一个非 const 成员函数，即使此函数不修改数据，编译不通过</li>
</ul>
]]></content>
      <categories>
        <category>C</category>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS</title>
    <url>/2019/11/08/CypherSecurity/2016/DNS/</url>
    <content><![CDATA[<h1 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a>DNS查询</h1><h2 id="DNS域名解析记录"><a href="#DNS域名解析记录" class="headerlink" title="DNS域名解析记录"></a>DNS域名解析记录</h2><p><strong>记录</strong>  </p>
<p>1.A记录：解析IPv4地址记录<br>2.AAAA记录： 解析IPv6地址记录<br>3.CNAME记录： 解析别名记录<br>4.NS记录： 解析子域名指定DNS服务器记录<br>5.MX记录： 解析SMTP服务器记录</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>1.正向解析: 查询A记录</p>
<p>2.反向解析: 查询PTR记录<br>  完成逆向域名解析，系统提供一个特别域，该特别域称为逆向解析域in-addr.arpa。这样欲解析的IP地址就会被表达成一种像域名一样的可显示串形式，后缀以逆向解析域域名”in-addr.arpa”结尾</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>dnsenum 可用于DNS的多项查询  </p>
]]></content>
      <categories>
        <category>CypherSecurity</category>
        <category>2016</category>
      </categories>
      <tags>
        <tag>CypherSecurity</tag>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title>LinuxCommand</title>
    <url>/2019/11/08/CypherSecurity/2016/LinuxCommand/</url>
    <content><![CDATA[<h1 id="Linux-Command-in-use"><a href="#Linux-Command-in-use" class="headerlink" title="Linux Command in use"></a>Linux Command in use</h1><h2 id="Kali更新源"><a href="#Kali更新源" class="headerlink" title="Kali更新源"></a>Kali更新源</h2><p>添加国内更新源:  </p>
<blockquote>
<ul>
<li>命令: vim /etc/apt/sources.list 修改此文件  </li>
<li>以deb http://  形式添加到此文件中  </li>
<li>命令: apt-get update 更新源  </li>
<li>命令: apt-get upgrade 更新安装包</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>CypherSecurity</category>
        <category>2016</category>
      </categories>
      <tags>
        <tag>CypherSecurity</tag>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title>README</title>
    <url>/2019/11/08/CypherSecurity/2016/README/</url>
    <content><![CDATA[<h1 id="WhiteHat"><a href="#WhiteHat" class="headerlink" title="WhiteHat"></a>WhiteHat</h1><p>Learn something interesting</p>
]]></content>
      <categories>
        <category>CypherSecurity</category>
        <category>2016</category>
      </categories>
      <tags>
        <tag>CypherSecurity</tag>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title>请求解析</title>
    <url>/2019/11/08/CypherSecurity/2016/%E8%AF%B7%E6%B1%82%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="浏览器请求解析"><a href="#浏览器请求解析" class="headerlink" title="浏览器请求解析"></a>浏览器请求解析</h1><p><a href="http://2277259257.iteye.com/blog/2026803" target="_blank" rel="noopener">引用</a>  感谢!</p>
<p>在HTTP服务中三个环节  <strong>请求 – 处理 – 响应</strong>  每个环节的编码格式都是很重要的，统一的编码格式才不致出现访问出错或者网页乱码的情况  </p>
<h2 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h2><blockquote>
<ul>
<li>浏览器会对请求进行编码组合成请求的URL;</li>
</ul>
</blockquote>
<h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><blockquote>
<ul>
<li>请求的媒体类型与编码都会写入消息头中;</li>
</ul>
</blockquote>
<h2 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h2><blockquote>
<ul>
<li>响应的内容媒体类型与编码在消息头中;</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>CypherSecurity</category>
        <category>2016</category>
      </categories>
      <tags>
        <tag>CypherSecurity</tag>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title>NetTools</title>
    <url>/2019/11/08/CypherSecurity/2016/NetTools/</url>
    <content><![CDATA[<h1 id="一些网络工具的使用"><a href="#一些网络工具的使用" class="headerlink" title="一些网络工具的使用"></a>一些网络工具的使用</h1><h2 id="dnsenum"><a href="#dnsenum" class="headerlink" title="dnsenum"></a>dnsenum</h2><p>多线程perl脚本枚举域的DNS信息并发现非连续的IP段工具  </p>
<p>主要功能:  </p>
<blockquote>
<ul>
<li>获取主机的地址（A记录）</li>
<li>获取名称服务器（线程）</li>
<li>获取MX记录（线程化）</li>
<li>对名称服务器执行axfr查询并获取BIND VERSION（线程化）</li>
<li>通过Google抓取获取额外的名称和子域(google query = “allinurl: -www site:domain”)</li>
<li>读取文件爆破子域，也可以对具有NS记录的子域执行递归查询（开启所有线程）</li>
<li>计算C类域网络范围并对其执行whois查询（线程化）</li>
<li>对网络（C类或/和whois网络）执行反向查找（线程化）</li>
<li>将ip段写入domain_ips.txt文件</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>CypherSecurity</category>
        <category>2016</category>
      </categories>
      <tags>
        <tag>CypherSecurity</tag>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title>README</title>
    <url>/2019/11/08/CypherSecurity/2017/README/</url>
    <content><![CDATA[<h1 id="学会一些工具的使用"><a href="#学会一些工具的使用" class="headerlink" title="学会一些工具的使用"></a>学会一些工具的使用</h1>]]></content>
      <categories>
        <category>CypherSecurity</category>
        <category>2017</category>
      </categories>
      <tags>
        <tag>CypherSecurity</tag>
        <tag>2017</tag>
      </tags>
  </entry>
  <entry>
    <title>WLAN</title>
    <url>/2019/11/08/CypherSecurity/2016/WLAN/</url>
    <content><![CDATA[<h1 id="无线破解"><a href="#无线破解" class="headerlink" title="无线破解"></a>无线破解</h1><p><a href="http://netsecurity.51cto.com/art/201105/264844_all.htm" target="_blank" rel="noopener">引用</a>      感谢！<br><a href="http://www.jianshu.com/p/fd16236057df" target="_blank" rel="noopener">简书</a>        感谢！</p>
<p>工具:<br><strong>aircrack-ng全家桶: airmon-ng airodump-ng aireplay-ng aircrack-ng</strong><br><a href="https://www.path8.net/tn/archives/40" target="_blank" rel="noopener">工具使用</a>    感谢！</p>
<h2 id="开启网卡监听模式"><a href="#开启网卡监听模式" class="headerlink" title="开启网卡监听模式"></a>开启网卡监听模式</h2><blockquote>
<ul>
<li>airmon-ng start wlan0</li>
</ul>
</blockquote>
<h2 id="改变网卡MAC"><a href="#改变网卡MAC" class="headerlink" title="改变网卡MAC"></a>改变网卡MAC</h2><blockquote>
<p>-macchanger -m 00:11:22:33:44:55 wlan0mon</p>
</blockquote>
<h2 id="扫描与抓包"><a href="#扫描与抓包" class="headerlink" title="扫描与抓包"></a>扫描与抓包</h2><blockquote>
<ul>
<li>airodump-ng wlan0mon  </li>
<li>airodump-ng –ivs -w xxxx -c channel_num device 用于抓取特定频道的数据包以ivs文件保存  </li>
<li>aireplay-ng -3 -b AP’MAC -h Client’MAC device 用于使用ARP注入来产生大量数据包，配合airodump-ng使用  </li>
</ul>
</blockquote>
<h2 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h2><blockquote>
<ul>
<li>aircrack-ng xxxx.ivs  进行解包</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>CypherSecurity</category>
        <category>2016</category>
      </categories>
      <tags>
        <tag>CypherSecurity</tag>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title>WordPress</title>
    <url>/2019/11/08/CypherSecurity/2016/WordPress/</url>
    <content><![CDATA[<h1 id="WordPress漏洞利用"><a href="#WordPress漏洞利用" class="headerlink" title="WordPress漏洞利用"></a>WordPress漏洞利用</h1><h2 id="学习链接"><a href="#学习链接" class="headerlink" title="学习链接"></a>学习链接</h2><blockquote>
<ul>
<li>WordPress插件注入漏洞 <a href="https://www.exploit-db.com/exploits/36613/" target="_blank" rel="noopener">EXPLOIT-DATABASE</a>  </li>
<li><a href="http://www.freebuf.com/articles/web/65894.html" target="_blank" rel="noopener">FREEBUF</a></li>
</ul>
</blockquote>
<h2 id="WPScan的利用"><a href="#WPScan的利用" class="headerlink" title="WPScan的利用"></a>WPScan的利用</h2><blockquote>
<ul>
<li>命令  wpscan -url URL</li>
</ul>
</blockquote>
<h2 id="nikto的利用"><a href="#nikto的利用" class="headerlink" title="nikto的利用"></a>nikto的利用</h2><blockquote>
<ul>
<li>命令  nikto  -h   URL  </li>
<li>可以通过一些cookies查看是否为WordPress站点，用于验证是否为WordPress站点</li>
</ul>
</blockquote>
<h2 id="Backup组件下载漏洞"><a href="#Backup组件下载漏洞" class="headerlink" title="Backup组件下载漏洞"></a>Backup组件下载漏洞</h2><blockquote>
<ul>
<li>路径: wp-content/wpbackitup_backups/</li>
</ul>
</blockquote>
<h2 id="Slider-Revolution-Plugin-任意文件下载漏洞"><a href="#Slider-Revolution-Plugin-任意文件下载漏洞" class="headerlink" title="Slider Revolution Plugin 任意文件下载漏洞"></a>Slider Revolution Plugin 任意文件下载漏洞</h2><blockquote>
<ul>
<li>路径: wp-admin/admin-ajax.php?action=revslider_show_image&amp;img=文件名  </li>
<li>例如: wp-admin/admin-ajax.php?action=revslider_show_image&amp;img=../wp-config.php</li>
<li>可以下载当前目录下的任意文件(路径首先正确),特别地，当拿到wp-config文件后就bam!bam!bam!</li>
</ul>
</blockquote>
<h2 id="Complete-Gallery-Manager-3-3-3任意文件上传漏洞"><a href="#Complete-Gallery-Manager-3-3-3任意文件上传漏洞" class="headerlink" title="Complete Gallery Manager 3.3.3任意文件上传漏洞"></a>Complete Gallery Manager 3.3.3任意文件上传漏洞</h2>]]></content>
      <categories>
        <category>CypherSecurity</category>
        <category>2016</category>
      </categories>
      <tags>
        <tag>CypherSecurity</tag>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title>Nessus</title>
    <url>/2019/11/08/CypherSecurity/2017/Nessus/</url>
    <content><![CDATA[<h1 id="Nessus"><a href="#Nessus" class="headerlink" title="Nessus"></a>Nessus</h1><p>要考试了，紧张地学习了一下，赶紧做做笔记走人</p>
<p>通过浏览器管理，输入    <a href="https://kali:8834" target="_blank" rel="noopener">https://kali:8834</a>   </p>
<p>大致的扫描步骤是这样的</p>
<h2 id="新建policy（或用以前的策略）"><a href="#新建policy（或用以前的策略）" class="headerlink" title="新建policy（或用以前的策略）"></a>新建policy（或用以前的策略）</h2><p>这里主要是选用 Advanced Scan， 里面可以选用 各种扫描所用到的  plugines，自我定制</p>
<h2 id="新建-Scan-任务"><a href="#新建-Scan-任务" class="headerlink" title="新建 Scan 任务"></a>新建 Scan 任务</h2><p>这里需要选用  policy  是作为扫描的策略，及  Scan name 和 Target IP</p>
<h2 id="开始-Scan"><a href="#开始-Scan" class="headerlink" title="开始 Scan"></a>开始 Scan</h2><p>等待几分钟后，会出现详细的 Vulnerability 信息，可以在里面具体的查看 INFO ，并且会给出解决方法与漏洞具体信息</p>
<p>就这样了，考试之后再搞搞！！！</p>
]]></content>
      <categories>
        <category>CypherSecurity</category>
        <category>2017</category>
      </categories>
      <tags>
        <tag>CypherSecurity</tag>
        <tag>2017</tag>
      </tags>
  </entry>
  <entry>
    <title>metasploit</title>
    <url>/2019/11/08/CypherSecurity/2017/metasploit/</url>
    <content><![CDATA[<h1 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h1><p>这个在 Kali中是自带的，无需安装</p>
<p>我的 kali 4.6.0 amd64</p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>metasploit 默认使用 postgresql 数据库，进行一些信息的存储与检索</p>
<ol>
<li>启动  postgresql</li>
</ol>
<ul>
<li>service postgresql start</li>
</ul>
<ol start="2">
<li>初始化 msfdb</li>
</ol>
<ul>
<li>msfdb init<br>初始化  数据库为  msfdb    用户名为  msf   默认密码为  空</li>
</ul>
<ol start="3">
<li>启动</li>
</ol>
<ul>
<li>msfconsole<br>控制台启动 metsploit</li>
</ul>
]]></content>
      <categories>
        <category>CypherSecurity</category>
        <category>2017</category>
      </categories>
      <tags>
        <tag>CypherSecurity</tag>
        <tag>2017</tag>
      </tags>
  </entry>
  <entry>
    <title>21MN</title>
    <url>/2019/11/08/JavaScript/2017_5/21MN/</url>
    <content><![CDATA[<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>这篇主要些什么？看了Javascript DOM 编程艺术 chapter5 有点懵逼。。。</p>
<h2 id="四大点"><a href="#四大点" class="headerlink" title="四大点"></a>四大点</h2><h3 id="平稳退化"><a href="#平稳退化" class="headerlink" title="平稳退化"></a>平稳退化</h3><p>即在浏览器不支持JavaScript时，能够不影响其它界面的展示，用到的主要是错误检查</p>
<h3 id="分离JavaScript"><a href="#分离JavaScript" class="headerlink" title="分离JavaScript"></a>分离JavaScript</h3><p>尽可能地把行为与结构分离开来</p>
<h3 id="向后兼容性"><a href="#向后兼容性" class="headerlink" title="向后兼容性"></a>向后兼容性</h3><h3 id="性能考虑"><a href="#性能考虑" class="headerlink" title="性能考虑"></a>性能考虑</h3><p>这个还是以后再考虑吧，这个毕竟是讲究如何跑得更快更稳，而我目前还刚会走。。。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>20175</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>20175</tag>
      </tags>
  </entry>
  <entry>
    <title>21</title>
    <url>/2019/11/08/JavaScript/2017_5/21/</url>
    <content><![CDATA[<h1 id="Javascript笔记"><a href="#Javascript笔记" class="headerlink" title="Javascript笔记"></a>Javascript笔记</h1><p>今天努力地学习了Javascript一天，作业什么的都没有管，感觉还是这种沉浸式的学习效率比较高！嗯，继续坚持，明天再来一天。  </p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions</a><br>主要是看了这篇文章<a href="http://www.cnblogs.com/wxydigua/p/3314274.html才开始学习的正则表达式的，还是很有用的" target="_blank" rel="noopener">http://www.cnblogs.com/wxydigua/p/3314274.html才开始学习的正则表达式的，还是很有用的</a>  </p>
<p>上两套代码<br>匹配域名主机  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getHost(url) &#123;</span><br><span class="line">        var host = &quot;null&quot;;</span><br><span class="line">        if(typeof url == &quot;undefined&quot;|| null == url) &#123;</span><br><span class="line">            url = window.location.href;</span><br><span class="line">        &#125;</span><br><span class="line">        var regex = /^\w+\:\/\/([^\/]*).*/;</span><br><span class="line">        var match = url.match(regex);</span><br><span class="line">        if(typeof match != &quot;undefined&quot; &amp;&amp; null != match) &#123;</span><br><span class="line">            host = match[1];</span><br><span class="line">        &#125;</span><br><span class="line">        return host;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>清除空格  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String.prototype.trim = function() &#123;   </span><br><span class="line">          var reExtraSpace = /^\s*(.*?)\s+$/;  </span><br><span class="line">          return this.replace(reExtraSpace, &quot;$1&quot;)  </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p> 在这里 (.*?)表示空，用$1代替匹配的空格</p>
<h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><blockquote>
<ul>
<li>* 表示&gt;=0  </li>
<li>+ 表示&gt;=1</li>
</ul>
</blockquote>
<h3 id=""><a href="#" class="headerlink" title="?"></a>?</h3><blockquote>
<ul>
<li>?表示非贪婪模式下匹配，默认为贪婪模式即会匹配多个，加上?会最低匹配</li>
</ul>
</blockquote>
<h3 id="中括号与小括号"><a href="#中括号与小括号" class="headerlink" title="中括号与小括号"></a>中括号与小括号</h3><blockquote>
<ul>
<li>中括号[]表示字符集合   </li>
<li>小括号()表示捕获括号<br>这个通过域名匹配可以看出小括号的作用，match数组<br>match[0]全匹配情况<br>match[1]仅匹配捕获括号，当输出 match[0] 为带有 http://或https:// </li>
</ul>
</blockquote>
<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><blockquote>
<ul>
<li>RegExp — test用来测试，返回布尔型</li>
<li>RegExp — exec用来匹配，返回数组或null</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>String — match用来匹配，返回数组或null</li>
<li>String — search用来查询索引</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>20175</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>20175</tag>
      </tags>
  </entry>
  <entry>
    <title>21N</title>
    <url>/2019/11/08/JavaScript/2017_5/21N/</url>
    <content><![CDATA[<h1 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h1><p>DOM — Document Object Model 文档对象模型  </p>
<h2 id="5个方法"><a href="#5个方法" class="headerlink" title="5个方法"></a>5个方法</h2><p><strong>document</strong></p>
<blockquote>
<ul>
<li>getElementById  –具有唯一性，返回一个元素对象</li>
<li>getElementByTagName  –不具有唯一性，返回一个对象数组</li>
<li>getElementByClassName   –同上</li>
</ul>
</blockquote>
<p><strong>元素</strong>  </p>
<blockquote>
<ul>
<li>getAttribute</li>
<li>setAttribute</li>
</ul>
</blockquote>
<h2 id="事件处理函数"><a href="#事件处理函数" class="headerlink" title="事件处理函数"></a>事件处理函数</h2><blockquote>
<ul>
<li>onclick 绑定一个链接时，js执行后返回true，会触发链接的默认行为，解决方法为 return false;  </li>
<li>onkeypress</li>
</ul>
</blockquote>
<h2 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h2><blockquote>
<ul>
<li>childNodes，元素子节点 </li>
<li>nodeType  –返回值为数字:1–元素节点,2–属性节点,3–文本节点</li>
<li>nodeValue</li>
<li>firstChild,lastChild  </li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">关于节点属性：一个元素的子节点往往比子元素节点多很多，原因在于：换行符，注释等都会被作为一个节点；  </span><br><span class="line">换行符节点： nodeType:  3   nodeValue:  Space  </span><br><span class="line">元素节点：   nodeType:  1   nodeValue:   null  </span><br><span class="line">注释节点:   nodeType: 8 nodeValue:  注释内容</span><br></pre></td></tr></table></figure>

<p><em>注意:空白字符或者换行符都可以是子节点</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p id=&quot;para-01&quot;&gt;</span><br><span class="line">  &lt;span&gt;First span&lt;/span&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  var p01 = document.getElementById(&apos;para-01&apos;);</span><br><span class="line">  alert(p01.firstChild.nodeName)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>返回值为’#text’，换行字符与空白字符为第一子节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p id=&quot;para-01&quot;&gt;&lt;span&gt;First span&lt;/span&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  var p01 = document.getElementById(&apos;para-01&apos;);</span><br><span class="line">  alert(p01.firstChild.nodeName)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>返回值为’SPAN’</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>20175</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>20175</tag>
      </tags>
  </entry>
  <entry>
    <title>LearnCMake</title>
    <url>/2019/07/29/CMake/how-to-use-cmake/LearnCMake/</url>
    <content><![CDATA[<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.14</span>)</span><br><span class="line"><span class="keyword">project</span>(My_project VERSION <span class="number">1.1</span>.<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h1 id="Set-variables"><a href="#Set-variables" class="headerlink" title="Set variables"></a>Set variables</h1><ul>
<li>By default, anything is a string<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_VARIABLE <span class="string">"This is a variable."</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="Print-message"><a href="#Print-message" class="headerlink" title="Print message"></a>Print message</h1><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>(STATUS <span class="variable">$&#123;MY_VARIABLE&#125;</span>)</span><br><span class="line"><span class="keyword">set</span>(My_bool <span class="string">"This is a string"</span>)</span><br></pre></td></tr></table></figure>
<h1 id="Control-flow"><a href="#Control-flow" class="headerlink" title="Control flow"></a>Control flow</h1><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> <span class="variable">$&#123;My_bool&#125;</span>)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">"This is true case"</span>)</span><br><span class="line"><span class="keyword">elseif</span>()</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">"This is false case"</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<h1 id="for-and-while-loop"><a href="#for-and-while-loop" class="headerlink" title="for and while loop"></a>for and while loop</h1><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(idx RANGE <span class="number">100</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endforeach</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(my_value <span class="keyword">LESS</span> <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">endwhile</span>()</span><br></pre></td></tr></table></figure>
<h1 id="STREQUAL"><a href="#STREQUAL" class="headerlink" title="STREQUAL"></a>STREQUAL</h1><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>()</span><br></pre></td></tr></table></figure>

<h1 id="Adding-targets-amp-subdirectories"><a href="#Adding-targets-amp-subdirectories" class="headerlink" title="Adding targets &amp; subdirectories"></a>Adding targets &amp; subdirectories</h1><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>()</span><br><span class="line"><span class="keyword">add_library</span>()</span><br><span class="line"><span class="keyword">add_subdirectory</span>()</span><br></pre></td></tr></table></figure>


<h1 id="Cmake-internal-variables"><a href="#Cmake-internal-variables" class="headerlink" title="Cmake internal variables"></a>Cmake internal variables</h1><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"This is cmake module path: "</span> <span class="variable">$&#123;CMAKE_MODULE_PATH&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"proj is "</span> <span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"proj name is "</span> <span class="variable">$&#123;PROJECT_VERSION&#125;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Adding-include-directories"><a href="#Adding-include-directories" class="headerlink" title="Adding include directories"></a>Adding include directories</h1><blockquote>
<p>To use additional headers located in separate directories<br>include xxx for all targets</p>
</blockquote>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>()</span><br></pre></td></tr></table></figure>

<h1 id="include-xxx-only-for-the-specificed-target"><a href="#include-xxx-only-for-the-specificed-target" class="headerlink" title="include xxx only for the specificed target"></a>include xxx only for the specificed target</h1><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>()</span><br></pre></td></tr></table></figure>

<h1 id="Add-pre-processors"><a href="#Add-pre-processors" class="headerlink" title="Add pre-processors"></a>Add pre-processors</h1><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_definitions</span>()</span><br></pre></td></tr></table></figure>

<h1 id="Set-target-properties"><a href="#Set-target-properties" class="headerlink" title="Set target properties"></a>Set target properties</h1><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set_target_properties</span>()</span><br></pre></td></tr></table></figure>

<h1 id="Linking-libraries"><a href="#Linking-libraries" class="headerlink" title="Linking libraries"></a>Linking libraries</h1><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Option<br><code>option()</code></p>
</li>
<li><p>File simliar to io to operate file</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(WRITE xxx.txt <span class="string">"this is a test to write\n"</span>)</span><br><span class="line"><span class="keyword">file</span>(APPEND xxx/xxx.txt <span class="string">"This is a test to append"</span>)</span><br><span class="line"><span class="keyword">file</span>(READ &lt;filename&gt; &lt;variable&gt;)</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">- <span class="keyword">String</span>: manipulate the <span class="keyword">string</span> </span><br><span class="line">`<span class="keyword">string</span>()`</span><br><span class="line"></span><br><span class="line">- <span class="keyword">math</span> <span class="keyword">command</span> that performs arithmetic</span><br><span class="line">`<span class="keyword">math</span>(EXPR My_sum <span class="string">"1+1"</span>)`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- <span class="keyword">List</span>: manipulate the lists</span><br><span class="line">`<span class="keyword">list</span>()`</span><br><span class="line"></span><br><span class="line"><span class="comment">## Functions </span></span><br><span class="line">&gt; functions run in differ scope with parent <span class="keyword">function</span></span><br><span class="line">```cmake</span><br><span class="line"><span class="keyword">function</span>(doubleIt VALUE)</span><br><span class="line">    <span class="keyword">math</span>(EXPR RESULT <span class="string">"$&#123;VALUE&#125; * 2"</span>)</span><br><span class="line">    <span class="keyword">set</span>(VALUE RESULT PARENT_SCOPE)</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure></li>
<li><p>an arbitary number of arguments</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>(doubleEach)</span><br><span class="line">    <span class="keyword">foreach</span>(ARG <span class="variable">$&#123;ARGN&#125;</span>)</span><br><span class="line">        <span class="keyword">math</span>(EXPR N <span class="string">"$&#123;ARG&#125; * 2"</span>)</span><br><span class="line">        <span class="keyword">message</span>(STATUS <span class="string">"$&#123;N&#125;)</span></span><br><span class="line"><span class="string">    endforeach()</span></span><br><span class="line"><span class="string">endfunction()</span></span><br></pre></td></tr></table></figure>
<h2 id="macro-endmacro"><a href="#macro-endmacro" class="headerlink" title="macro/endmacro"></a>macro/endmacro</h2><blockquote>
<p>macro set all variables in the caller’s scope</p>
</blockquote>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">macro</span>(doubleIt VALUE)</span><br><span class="line">    <span class="keyword">math</span>(EXPR RESULT <span class="string">"$&#123;VALUE&#125; * 2"</span>)</span><br><span class="line"><span class="keyword">endmacro</span>()</span><br></pre></td></tr></table></figure>
<h2 id="Run-options"><a href="#Run-options" class="headerlink" title="Run options"></a>Run options</h2></li>
<li><p>-P option runs the given script, but doesn’t generate a build pipeline<br><code>cmake -P hello.txt</code></p>
</li>
<li><p>-D option defines the variable<br><code>cmake -DNAME=xxxx -P hello.txt</code></p>
</li>
</ul>
<h2 id="Including-Other-Scripts"><a href="#Including-Other-Scripts" class="headerlink" title="Including Other Scripts"></a>Including Other Scripts</h2><blockquote>
<p>cmake variables are defined at file scope.<br><code>include</code>command executes another CMake script. Use the variable <code>CMAKE_MODULE_PATH</code> as a search path.</p>
</blockquote>
<blockquote>
<p><code>add_subdirectory</code>command creates a new scope. Use it to add another CMake-based subproject, such as a library or executable, to the calling project.<br>None of the variables defined in the subproject’s script will pollute the parent’s scope.</p>
</blockquote>
<h2 id="add-custom-command"><a href="#add-custom-command" class="headerlink" title="add_custom_command"></a>add_custom_command</h2><blockquote>
<p>可在目标编译链接之前/编译链接之后执行 command</p>
</blockquote>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(<span class="keyword">TARGET</span> test_elf PRE_LINK</span><br><span class="line"><span class="keyword">COMMAND</span></span><br><span class="line">cp <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/cfg/start.o <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/. &amp;&amp; </span><br><span class="line">cp <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="keyword">target</span>/imx6_gcc/imx6.ld <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/.</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy_if_different xxx_src xxx_dst</span><br></pre></td></tr></table></figure>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips:"></a>Tips:</h2><ul>
<li>The difference of <code>include</code> and <code>include_directories()</code>: include to include </li>
</ul>
<p>ref: <a href="https://preshing.com/20170522/learn-cmakes-scripting-language-in-15-minutes/" target="_blank" rel="noopener">https://preshing.com/20170522/learn-cmakes-scripting-language-in-15-minutes/</a></p>
<p><a href="https://cmake.org/cmake-tutorial/" target="_blank" rel="noopener">https://cmake.org/cmake-tutorial/</a></p>
<p><a href="https://www.jianshu.com/p/aaa19816f7ad" target="_blank" rel="noopener">https://www.jianshu.com/p/aaa19816f7ad</a></p>
]]></content>
      <categories>
        <category>CMake</category>
        <category>how-to-use-cmake</category>
      </categories>
      <tags>
        <tag>CMake</tag>
        <tag>how-to-use-cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>21N_2</title>
    <url>/2019/11/08/JavaScript/2017_5/21N_2/</url>
    <content><![CDATA[<h1 id="chapter8-显示“缩略语列表”"><a href="#chapter8-显示“缩略语列表”" class="headerlink" title="chapter8 显示“缩略语列表”"></a>chapter8 显示“缩略语列表”</h1><p><strong>用JavaScript函数把文档里有用的信息提取出来，然后再一以清晰的方式插入到文档中去</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">	&lt;title&gt;Explaining the Document Object Model&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;h1&gt;What is the Document Object Model?&lt;/h1&gt;</span><br><span class="line">	&lt;p&gt;</span><br><span class="line">		The &lt;abbr title=&quot;World Wide Web Consortium&quot;&gt;W3C&lt;/abbr&gt; defines the &lt;abbr title=&quot;Document Object Model&quot;&gt;DOM&lt;/abbr&gt;as:</span><br><span class="line">	&lt;/p&gt;</span><br><span class="line">	&lt;blockquote cite=&quot;http://www.w3.org/DOM/&quot;&gt;</span><br><span class="line">	&lt;p&gt;</span><br><span class="line">		a platform- and language-neutral interface that will allow programs and scripts to dynamically access and update the content, structure and style of documents.</span><br><span class="line">	&lt;/p&gt;</span><br><span class="line">	&lt;/blockquote&gt;</span><br><span class="line">	&lt;p&gt;</span><br><span class="line">		It is an &lt;abbr title=&quot;Application Programming interface&quot;&gt;API&lt;/abbr&gt; that can be used to navigate &lt;abbr title=&quot;Hypertext Markup Language&quot;&gt;HTML&lt;/abbr&gt;</span><br><span class="line">	&lt;/p&gt;</span><br><span class="line">	&lt;script src=&quot;scripts/displayAbbreviations.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function displayAbbreviations() &#123;</span><br><span class="line">	</span><br><span class="line">	var abbrs = document.getElementByTagName(&quot;abbr&quot;);</span><br><span class="line">	if(abbrs.length &lt; 1)</span><br><span class="line">	&#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var abbr_array = new Array();</span><br><span class="line">	for(var i=0;i&lt;abbrs.length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		var title = abbrs[i].getAttribute(&quot;title&quot;);						//获取title属性</span><br><span class="line">		var key = abbrs.lastChild.nodeValue;							//获取文本</span><br><span class="line"></span><br><span class="line">		abbr_array[key] = title;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var dl = document.createElement(&quot;dl&quot;);</span><br><span class="line"></span><br><span class="line">	for(key in abbr_array)</span><br><span class="line">	&#123;</span><br><span class="line">		var dt = document.createElement(&quot;dt&quot;);</span><br><span class="line">		var dt_text = document.createTextNode(key);</span><br><span class="line">		dt.appendChild(dt_text);</span><br><span class="line"></span><br><span class="line">		var dd = document.createElement(&quot;dd&quot;);</span><br><span class="line">		var dd_text = document.createTextNode(abbr_array[key]);</span><br><span class="line">		dt.appendChild(dd_text);</span><br><span class="line"></span><br><span class="line">		dl.appendChild(dt);</span><br><span class="line">		dl.appendChild(dd);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	document.body.appendChild(dl);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	window.onload = displayAbbreviations;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>20175</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>20175</tag>
      </tags>
  </entry>
  <entry>
    <title>Function</title>
    <url>/2019/11/08/JavaScript/2017_5/Function/</url>
    <content><![CDATA[<h1 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h1><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function abs(x) &#123;</span><br><span class="line">    if (x &gt;= 0) &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var abs = function (x) &#123;</span><br><span class="line">    if (x &gt;= 0) &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>20175</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>20175</tag>
      </tags>
  </entry>
  <entry>
    <title>README</title>
    <url>/2019/11/08/JavaScript/2017_5/README/</url>
    <content><![CDATA[<p>2017/5  </p>
<p>开发URL_SHOT时学习的一点皮毛Javascript知识</p>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>20175</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>20175</tag>
      </tags>
  </entry>
  <entry>
    <title>22</title>
    <url>/2019/11/08/JavaScript/2017_5/22/</url>
    <content><![CDATA[<h1 id="21-Execuse-me"><a href="#21-Execuse-me" class="headerlink" title="21?Execuse me?"></a>21?Execuse me?</h1><p>昨天好像记错日期了，记成了21，实际应当是20号，还是来看一下今天的内容吧</p>
<p><strong>JavaScript 应当用于充实文档内容，应该避免其接触核心内容，否则在禁用JS的浏览器上平稳退化性不好</strong></p>
<h2 id="事件处理函数"><a href="#事件处理函数" class="headerlink" title="事件处理函数"></a>事件处理函数</h2><p>是这样的，  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;li&gt;</span><br><span class="line">	&lt;a href=&quot;images/101200.png&quot; title=&quot;A Flower&quot; onclick=&quot;showPic(this);return false;&quot;&gt;Flower&lt;/a&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">频繁出现 onclick 事件处理函数，这样那个Keith说结构与行为没有分开，所以需要改，怎么改？  </span><br><span class="line">让JS自己添加上对应的事件处理函数，还需要一个 onload 网页加载完毕事件来触发这个函数进行事件绑定？？？？？？？？？？？</span><br></pre></td></tr></table></figure>
<p>function prepareGallery() {</p>
<pre><code>var imageGallery = document.getElementById(&quot;imageGallery&quot;);

var links = imageGallery.getElementsByTagName(&quot;a&quot;);

for(var i=0;i&lt;links.length;i++)
{
    links[i].onclick = function() {                    //进行事件绑定
        showPic(this);
        return false;
    }
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 动态创建标记</span><br><span class="line"></span><br><span class="line">上个改完了，DOM文档真的是剩的皮包骨头了，但是！这还没有完，还有剔去几根骨头，  </span><br><span class="line">那个用于显示图片的，看着也不爽，也不符合“规定”，改吧 </span><br><span class="line"></span><br><span class="line">**属性**  </span><br><span class="line">&gt; - parentNode -- 父节点  </span><br><span class="line">&gt; - lastChild,firstChild  </span><br><span class="line">&gt; - nextSibling --兄弟节点</span><br><span class="line"></span><br><span class="line">**方法**  </span><br><span class="line">&gt; - document.createElement  -- 创建元素节点  </span><br><span class="line">&gt; - document.createTextNode -- 创建文本节点  </span><br><span class="line">&gt; - parentNode.appendChild  -- 添加子节点  </span><br><span class="line">&gt; - parentNode.insertBefore(newElement,targetElement) -- 添加节点到 targetElement 前面  </span><br><span class="line"></span><br><span class="line">*还有一些动态添加的**传统方法**  </span><br><span class="line">&gt; - document.write  方法  </span><br><span class="line">&gt; - innerHTML 属性　</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">造个insertAfter(newElement,targetElement)</span><br></pre></td></tr></table></figure>
<p>function insertAfter(newElement,targetElement)<br>{<br>    var parent = targetElement.parentNode;</p>
<pre><code>if(parent.lastChild == targetElement)                    //是lastChild，则插入到最后
{
    parent.appendChild(newElement);
}
else                                                     //非lastChild，则插入下一个兄弟节点前
{
    parent.insertBefore(newElement,targetElement.nextSibling);
}</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img id="placeholder" src="images/100000.png" alt="my image gallery" />
    <p id="description">Choose an image.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">就它，改它</span><br></pre></td></tr></table></figure>
function preparePlaceHolder() {

<pre><code>var placeholder = document.createElement(&quot;img&quot;);

placeholder.setAttribute(&quot;id&quot;,&quot;placeholder&quot;);
placeholder.setAttribute(&quot;src&quot;,&quot;images/100000.png&quot;);
placeholder.setAttribute(&quot;alt&quot;,&quot;my image gallery&quot;);

var p = document.createElement(&quot;p&quot;);
p.setAttribute(&quot;id&quot;,&quot;description&quot;);

txt = document.createTextNode(&quot;Choose an image&quot;);

p.appendChild(txt);                                        //添加文本子节点

var gallery = document.getElementById(&quot;imageGallery&quot;);

insertAfter(placeholder,gallery);
insertAfter(p,placeholder);</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## window.onload  </span><br><span class="line"></span><br><span class="line">网页加载完毕后即执行这个函数,但仅能对应一个函数，addLoadEvent可用于添加</span><br></pre></td></tr></table></figure>
<p>function addLoadEvent(func) {</p>
<pre><code>var oldLoad = window.onload;                        //onload每次仅能绑定一个函数
if(typeof oldLoad != &quot;function&quot;)
{
    window.onload = func;
}
else
{
    window.onload = function() {
        oldLoad();
        func();
    }
}</code></pre><p>}</p>
<pre><code>
















</code></pre>]]></content>
      <categories>
        <category>JavaScript</category>
        <category>20175</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>20175</tag>
      </tags>
  </entry>
  <entry>
    <title>222</title>
    <url>/2019/11/08/JavaScript/2017_5/22_2/</url>
    <content><![CDATA[<h1 id="HTML杂"><a href="#HTML杂" class="headerlink" title="HTML杂"></a>HTML杂</h1><p>学JS过程中遇到了不少HTML标签的问题查找发现还是学到了不少新东西  </p>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><blockquote>
<ul>
<li>a anchor element 锚标签，创建超链接，常用属性 href,rel,target   </li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;images/101200.png&quot; title=&quot;A Flower&quot;&gt;Flower&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href=&quot;https://developer.mozilla.org/en-US/&quot; target=&quot;_blank&quot;&gt;</span><br><span class="line">  &lt;img src=&quot;https://mdn.mozillademos.org/files/6851/mdn_logo.png&quot;</span><br><span class="line">       alt=&quot;MDN logo&quot; /&gt;</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>li 常用在 ol, ul, menu等元素里</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;first item&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;second item&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;third item&lt;/li&gt;</span><br><span class="line">&lt;/ul</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ol type=&quot;I&quot;&gt;</span><br><span class="line">    &lt;li value=&quot;3&quot;&gt;third item&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;fourth item&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;fifth item&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>dl 定义列表   dt  定义标题 dd 定义描述 </li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dl&gt;</span><br><span class="line">		&lt;dt&gt;Title 1&lt;/dt&gt;</span><br><span class="line">		&lt;dd&gt;Description 1&lt;/dd&gt;</span><br><span class="line">		&lt;dt&gt;Title 2&lt;/dt&gt;</span><br><span class="line">		&lt;dd&gt;Description 2&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>abbr  缩略词  </li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The &lt;abbr title=&quot;World Wide Web Consortium&quot;&gt;W3C&lt;/abbr&gt;</span><br><span class="line">``` </span><br><span class="line">&gt; - meta</span><br></pre></td></tr></table></figure>
<meta charset="utf-8">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; - blockquote  块级元素 </span><br><span class="line">&gt; - cite 引用的地址</span><br></pre></td></tr></table></figure>
<blockquote cite="http://www.w3.org/DOM/">
    <p>
        a platform- and language-neutral interface that will allow programs and scripts to dynamically access and update the content, structure and style of documents.
    </p>
</blockquote>
```









]]></content>
      <categories>
        <category>JavaScript</category>
        <category>20175</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>20175</tag>
      </tags>
  </entry>
  <entry>
    <title>README</title>
    <url>/2019/11/08/Linux/2016/README/</url>
    <content><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>Linux config</p>
<p>Linux 配置的一些命令</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>2016</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title>查找命令</title>
    <url>/2019/11/08/Linux/2016/%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>grep 与 find 的区别主要在于 grep 用于查找匹配的文件内容；find 用于查找匹配的文件名  </p>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><h2 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h2><h2 id="updatedb"><a href="#updatedb" class="headerlink" title="updatedb"></a>updatedb</h2><h2 id="xaegs"><a href="#xaegs" class="headerlink" title="xaegs"></a>xaegs</h2>]]></content>
      <categories>
        <category>Linux</category>
        <category>2016</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title>Proxy</title>
    <url>/2019/11/08/CypherSecurity/2016/Proxy/</url>
    <content><![CDATA[<h1 id="Proxy-For-Use"><a href="#Proxy-For-Use" class="headerlink" title="Proxy For Use"></a>Proxy For Use</h1><h2 id="mitmproxy"><a href="#mitmproxy" class="headerlink" title="mitmproxy"></a>mitmproxy</h2><blockquote>
<ul>
<li>命令: mitmproxy -p 8800 用于设置  mitmproxy 监听端口为 8800  </li>
<li>命令: L 可用于过滤 设置过滤条件，例如,Limit:/.js 仅查看js请求   </li>
<li>命令: I 可用于拦截请求,例如，Intercept filter: -u .php 可用于拦截 php 请求  </li>
</ul>
</blockquote>
<h2 id="Owasp-zap"><a href="#Owasp-zap" class="headerlink" title="Owasp-zap"></a>Owasp-zap</h2><p>OWASP Zed Attak Proxy Project 攻击代理(简称ZAP),功能  “拦截代理”  “自动处理”  “被动处理”  “暴力破解”  “端口扫描”  “蜘蛛搜索”等功能<br>会话类调试工具，调试功能不会产生大量请求，对服务器影响小</p>
]]></content>
      <categories>
        <category>CypherSecurity</category>
        <category>2016</category>
      </categories>
      <tags>
        <tag>CypherSecurity</tag>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title>Firewall</title>
    <url>/2019/11/08/Linux/2016/Firewall/</url>
    <content><![CDATA[<h1 id="关于Firewalld的配制与使用"><a href="#关于Firewalld的配制与使用" class="headerlink" title="关于Firewalld的配制与使用"></a>关于Firewalld的配制与使用</h1><p>引用 <a href="http://www.sa-log.com/282.html" target="_blank" rel="noopener">http://www.sa-log.com/282.html</a></p>
<ul>
<li>FirewallD 提供了支持网络/防火墙区域(zone)定义网络链接以及接口安全等级的动态防火墙管理工具  <blockquote>
<ul>
<li>什么是动态防火墙</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们首先需要弄明白的第一个问题是到底什么是动态防火墙。为了解答这个问题，我们先来回忆一下 iptables service 管理防火墙规则的模式：用户将新的防火墙规则添加进 /etc/sysconfig/iptables 配置文件当中，再执行命令 service iptables reload 使变更的规则生效。在这整个过程的背后，iptables service 首先对旧的防火墙规则进行了清空，然后重新完整地加载所有新的防火墙规则，而如果配置了需要 reload 内核模块的话，过程背后还会包含卸载和重新加载内核模块的动作，而不幸的是，这个动作很可能对运行中的系统产生额外的不良影响，特别是在网络非常繁忙的系统中。</span><br><span class="line"></span><br><span class="line">如果我们把这种哪怕只修改一条规则也要进行所有规则的重新载入的模式称为静态防火墙的话，那么 firewalld 所提供的模式就可以叫做动态防火墙，它的出现就是为了解决这一问题，任何规则的变更都不需要对整个防火墙规则列表进行重新加载，只需要将变更部分保存并更新到运行中的 iptables 即可。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<ul>
<li>什么是区域(zone)</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewalld将网卡对应到不同的区域（zone），zone 默认共有9个，block dmz drop external home internal public trusted work.</span><br><span class="line">不同的区域之间的差异是其对待数据包的默认行为不同，根据区域名字我们可以很直观的知道该区域的特征，在CentOS7系统中，默认区域被设置为public.</span><br><span class="line">在最新版本的fedora（fedora21）当中随着 server 版和 workstation 版的分化则添加了两个不同的自定义 zone FedoraServer 和 FedoraWorkstation 分别对应两个版本。</span><br></pre></td></tr></table></figure>

<h2 id="配置的几条常用命令"><a href="#配置的几条常用命令" class="headerlink" title="配置的几条常用命令"></a>配置的几条常用命令</h2><blockquote>
<ul>
<li>systemctl start firewalld  启用firewalld  </li>
<li>systemctl stop firewalld   停止firewalld  </li>
<li>firewall-cmd –reload      配置完毕后重新加载  </li>
<li>firewall-cmd –get-default-zone   获取默认的zone  </li>
<li>firewall-cmd –get-all-zones     获取所有的zone  </li>
<li>cat /etc/firewalld/zones/public.xml  查看pulic zone 的服务有哪些  </li>
<li>firewall-cmd –state   检查firewalld运行状态  </li>
<li>firewall-cmd –zone=public –add-port=3311/tcp –permanent  添加开放端口</li>
</ul>
</blockquote>
<p>##　关于配置（还是直接更改xml文件比较好）</p>
<blockquote>
<ul>
<li>/etc/firewalld/services    /etc/firewalld/zones   配置完成的服务于区域</li>
<li>/usr/lib/firewalld/services    /usr/lib/firewalld/zones   服务于区域库   </li>
</ul>
</blockquote>
<p><strong>当firewalld加载配置文件的服务时首先读取/etc/firewalld/services,然后会读取/usr/lib/firewalld/services 因此我们可以把/usr/lib/firewalld/services<br>cp 到  /etc 中为了配置方便，当然了这是不必要的</strong>  </p>
<p>除了自己加入系统自带的一些服务外，我们还可以自己定义服务，方法就是在/usr/lib/firewalld/services里 touch xxx.xml文件或者更改一下其他的文件，主要在于port的更改  </p>
<p>——————————更新——————————————————–</p>
<h2 id="shadowsocks入坑详解"><a href="#shadowsocks入坑详解" class="headerlink" title="shadowsocks入坑详解"></a>shadowsocks入坑详解</h2><p>在搬瓦工上配置ss时，遇到了防火墙的一些坑，并且渐渐地明白了这些防火墙运作的原理，主要是对端口与连接的具体方式进行限定来保护<br>我们所开放的端口都是指的是入站的端口，当然端口除了入站的以外还有出站的，这些就不是我们所要考虑的了，操作系统应该会为进程分配对应的端口<br>配置ss时需要开放一个服务器端口，这里我用的是8388默认端口，在services里编辑一条加上去就可以了</p>
<p><strong>最最重要的是reload之后重启才会生效哦</strong></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>2016</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB 调试</title>
    <url>/2019/11/08/Linux/GDB/gdb0/</url>
    <content><![CDATA[<h1 id="GDB常用命令"><a href="#GDB常用命令" class="headerlink" title="GDB常用命令"></a>GDB常用命令</h1><h2 id="调试的运行和终结"><a href="#调试的运行和终结" class="headerlink" title="调试的运行和终结"></a>调试的运行和终结</h2><ul>
<li><code>n</code> 单步运行</li>
<li><code>c</code> 继续运行</li>
</ul>
<h2 id="断点的设置与清除"><a href="#断点的设置与清除" class="headerlink" title="断点的设置与清除"></a>断点的设置与清除</h2><ul>
<li><code>info b</code> 查看断点设置情况</li>
<li><code>b linenum_xxx</code> 设置断点</li>
<li><code>b/break filename_xxx.cpp:linenum_xxx thread all</code> 所有线程都在　filename.cpp 的　linenum　行设置断点</li>
</ul>
<h2 id="变量的查看"><a href="#变量的查看" class="headerlink" title="变量的查看"></a>变量的查看</h2><ul>
<li><code>p value</code> 可以查看当前 value 对应的值</li>
<li><code>p &amp;value</code>　可以查看当前 value 对应的地址</li>
<li><code>watch value</code> 对　value 的值进行监控，每当　value 的值发生变化则停止在对应的位置</li>
</ul>
<h2 id="内存的查看"><a href="#内存的查看" class="headerlink" title="内存的查看"></a>内存的查看</h2><p><code>x number_xxx format_xxx unit_xxx addr_xxx</code> 以　format_xxx　格式显示　number_xxx　个以　unit_xxx　为单位的数据</p>
<ul>
<li><code>number_xxx</code> 显示的内存单元数目</li>
<li><code>format_xxx</code> 显示格式：s– 以字符串形式，i–以指令形式，u–16进制显示无符号整型<br>d– 以十进制形式，f–以浮点格式形式，c–以字符格式形式；</li>
<li><code>unit_xxx</code> 内存单元的字节数：默认为　４　字节，b–单字节，h–双字节，w–四字节，g–八字节</li>
<li><code>addr_xxx</code> 内存的初始地址</li>
</ul>
<h2 id="线程的查看与切换"><a href="#线程的查看与切换" class="headerlink" title="线程的查看与切换"></a>线程的查看与切换</h2><ul>
<li><code>info threads</code> 显示当前所有的线程</li>
<li><code>thread thread_id_xxx</code> 切换线程</li>
<li><code>set scheduler-locking off|on|step</code> 在调式某一个线程时，其他线程是否执行。off，不锁定任何线程，默认值。on，锁定其他线程，只有当前线程执行。step，在step（单步）时，只有被调试线程运行。</li>
<li><code>set non-stop on/off</code> 当调式一个线程时，其他线程是否运行。</li>
<li><code>set pagination on/off</code> 在使用backtrace时，在分页时是否停止。</li>
<li><code>set target-async on/ff</code> 同步和异步。同步，gdb在输出提示符之前等待程序报告一些线程已经终止的信息。而异步的则是直接返回。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://wizardforcel.gitbooks.io/100-gdb-tips/set-watchpoint.html" target="_blank" rel="noopener">gdb技巧</a></li>
<li><a href="https://blog.csdn.net/liangzhao_jay/article/details/79260047" target="_blank" rel="noopener">gdb 多线程调试</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>GDB</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>GDB</tag>
      </tags>
  </entry>
  <entry>
    <title>net-tools</title>
    <url>/2019/11/08/Linux/2016/net-tools/</url>
    <content><![CDATA[<h2 id="net-tools网管工具集"><a href="#net-tools网管工具集" class="headerlink" title="net-tools网管工具集"></a>net-tools网管工具集</h2><p>接上篇，当具体分析连接对应的端口号与查看相应的进程号与名字(PID与program name)时  </p>
<blockquote>
<ul>
<li>netstat -apn  win也可以使用这个命令哦  </li>
</ul>
</blockquote>
<p>嗯？cannot find？惊呆了<br>google一下发现没安装工具集   </p>
<blockquote>
<ul>
<li>yum install net-tools  </li>
</ul>
</blockquote>
<p>再次使用果然可以了，里面会显示开放的所有端口，及对应的PID和文件所在位置，下面会展示出来所有的sockets  </p>
<blockquote>
<ul>
<li>netstat -apn | grep 80  可以具体地查找某个具体端口的开放情况   </li>
</ul>
</blockquote>
<h2 id="ps-PID"><a href="#ps-PID" class="headerlink" title="ps PID"></a>ps PID</h2><p><strong>ps PID 也可以具体地查看某个进程对应的端口及一些详尽信息哦</strong>  </p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>2016</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title>README</title>
    <url>/2019/11/08/Linux/Network_Programming/README/</url>
    <content><![CDATA[<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p>想以 UDPspeeder 这个udp加速项目为例真正地学习一下网络编程，去知乎上搜索了一下技术路线：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.先看 图解tcp/ip 抓重点 。理解面向连接，无连接，tcp粘包，udp有界等</span><br><span class="line">2.然后看 linux/unix系统编程手册 socket几章，号称超越apue的好书。这几章将socket,select,poll,epoll讲的很到位。理解select，poll的原理，大并发为啥epoll有优势，epoll的水平触发和边缘触发区别，如何解决边缘触发饿死问题等等。</span><br><span class="line">3.看 tornado源码，这时候看起来应该比较轻松。比如tornado中用pipe做waker，上本书都有讲解。</span><br><span class="line">4.阅读 effective tcp/ip ...</span><br><span class="line">5.慢慢读 tcp/ip详解卷一和unix网络编程为啥最经典的书最后推荐，主要是让大家刚开始不要太纠结细节，unp实在太厚了，会吓死自己的。当能力够了再回头，才有共鸣，才有大收获。</span><br><span class="line"></span><br><span class="line">作者：罗伊</span><br><span class="line">链接：https://www.zhihu.com/question/29380313/answer/55937044</span><br><span class="line">来源：知乎</span><br></pre></td></tr></table></figure>

<h2 id="学习链接"><a href="#学习链接" class="headerlink" title="学习链接"></a>学习链接</h2><ul>
<li>[中科大linux socket 网络编程]<a href="http://staff.ustc.edu.cn/~mengning/np/linux_socket/new_page_36.htm" target="_blank" rel="noopener">http://staff.ustc.edu.cn/~mengning/np/linux_socket/new_page_36.htm</a></li>
</ul>
<p>加油吧！</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Network_Programming</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Network_Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch07</title>
    <url>/2020/01/05/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Ch07/</url>
    <content><![CDATA[<h1 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h1><h2 id="过拟合矛欠拟合问题的引入"><a href="#过拟合矛欠拟合问题的引入" class="headerlink" title="过拟合矛欠拟合问题的引入"></a>过拟合矛欠拟合问题的引入</h2><p><img src="/2020/01/05/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Ch07/Andrew_01.png" alt="andrew_01"></p>
<ul>
<li>欠拟合（underffit）： 高偏置（high bias）</li>
<li>过拟合（overfit）：   高方差（high variance）</li>
</ul>
<h2 id="代价函数的正则化"><a href="#代价函数的正则化" class="headerlink" title="代价函数的正则化"></a>代价函数的正则化</h2><p><img src="/2020/01/05/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Ch07/Andrew_02.png" alt="andrew_02"></p>
<p><img src="/2020/01/05/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Ch07/Andrew_03.png" alt="andrew_03"></p>
<p><img src="/2020/01/05/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Ch07/Andrew_04.png" alt="andrew_04"></p>
<p>解决正则化的两个思路：</p>
<ul>
<li>减少参数的数量</li>
<li>保持参数的数量，但使用正则化参数控制参数的大小</li>
</ul>
<h2 id="线性回归的正则化"><a href="#线性回归的正则化" class="headerlink" title="线性回归的正则化"></a>线性回归的正则化</h2><p><img src="/2020/01/05/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Ch07/Andrew_05.png" alt="andrew_05"></p>
<p><img src="/2020/01/05/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Ch07/Andrew_06.png" alt="andrew_06"></p>
<p><img src="/2020/01/05/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Ch07/Andrew_07.png" alt="andrew_07"></p>
<p><img src="/2020/01/05/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Ch07/Andrew_08.png" alt="andrew_08"></p>
<p><img src="/2020/01/05/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Ch07/Andrew_09.png" alt="andrew_09"></p>
<p><img src="/2020/01/05/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Ch07/Andrew_10.png" alt="andrew_10"></p>
<p>求导的结果表明，加入正则化参数只是对参数乘上一个比1略小的因子。</p>
<p>使用线性代数的思想来解释（讨论方阵是否可逆）：</p>
<p><img src="/2020/01/05/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Ch07/Andrew_11.png" alt="andrew_11"></p>
<p><img src="/2020/01/05/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Ch07/Andrew_12.png" alt="andrew_12"></p>
<h2 id="Logistic回归的正则化"><a href="#Logistic回归的正则化" class="headerlink" title="Logistic回归的正则化"></a>Logistic回归的正则化</h2><p>对Logistic求解算法的改进</p>
<p><img src="/2020/01/05/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Ch07/Andrew_13.png" alt="andrew_13"></p>
<p><img src="/2020/01/05/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Ch07/Andrew_14.png" alt="andrew_14"></p>
<p><img src="/2020/01/05/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Ch07/Andrew_15.png" alt="andrew_15"></p>
<p><img src="/2020/01/05/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Ch07/Andrew_16.png" alt="andrew_16"></p>
]]></content>
      <categories>
        <category>MLDL</category>
        <category>AndrewNG机器学习</category>
      </categories>
      <tags>
        <tag>MLDL</tag>
        <tag>AndrewNG机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>README</title>
    <url>/2019/12/01/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/README/</url>
    <content><![CDATA[<h1 id="Andrew-N-G-’s-ML-Course"><a href="#Andrew-N-G-’s-ML-Course" class="headerlink" title="Andrew N.G.’s ML Course"></a>Andrew N.G.’s ML Course</h1><p><em>参考：<a href="https://www.bilibili.com/video/av50747658" target="_blank" rel="noopener">https://www.bilibili.com/video/av50747658</a></em></p>
<p>全部视频分为 18 个章节，从基本的机器学习算法到神经网络，侧重于算法的理解与实际运用，以及其中存在的问题和优化方案，2019年争取把这个视频结束掉。</p>
]]></content>
      <categories>
        <category>MLDL</category>
        <category>AndrewNG机器学习</category>
      </categories>
      <tags>
        <tag>MLDL</tag>
        <tag>AndrewNG机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch6_classify</title>
    <url>/2020/01/05/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Ch6_classify/</url>
    <content><![CDATA[<h1 id="Classifier-分类器"><a href="#Classifier-分类器" class="headerlink" title="Classifier 分类器"></a>Classifier 分类器</h1><ul>
<li>Linear Regression</li>
<li>Logistic Regression ！！！</li>
</ul>
<h2 id="1-分类问题"><a href="#1-分类问题" class="headerlink" title="1. 分类问题"></a>1. 分类问题</h2><p><strong>以下考虑的均为二分类问题：<code>y=0/y=1</code></strong></p>
<p>分类问题的引入，由最初的线性函数（<code>linear function</code>），得到的值往往存在于 0 与 1 之外，并且线性函数得出的值往往会受到样本的扰动比较大，因此考虑将线性函数的值再经过映射到0-1的空间内。</p>
<p><img src="/2020/01/05/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Ch6_classify/Andrew_ch06_1.png" alt="classifier"></p>
<h2 id="2-假设（Hypothesis）"><a href="#2-假设（Hypothesis）" class="headerlink" title="2. 假设（Hypothesis）"></a>2. 假设（Hypothesis）</h2><p><img src="/2020/01/05/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Ch6_classify/Andrew_ch06_2.png" alt="hypothesis"></p>
<p><img src="/2020/01/05/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Ch6_classify/Andrew_Ch06_3.png" alt="hypothesis"></p>
<h2 id="3-决策界限（Decision-Boundary）"><a href="#3-决策界限（Decision-Boundary）" class="headerlink" title="3. 决策界限（Decision Boundary）"></a>3. 决策界限（Decision Boundary）</h2><p><img src="/2020/01/05/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Ch6_classify/Andrew_Ch06_4.png" alt="decision_boundary"></p>
<p><img src="/2020/01/05/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Ch6_classify/Andrew_Ch06_5.png" alt="decision_boundary"></p>
<h2 id="4-代价函数（Cost-Function）"><a href="#4-代价函数（Cost-Function）" class="headerlink" title="4. 代价函数（Cost Function）"></a>4. 代价函数（Cost Function）</h2><p><img src="/2020/01/05/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Ch6_classify/Andrew_Ch06_6.png" alt="cost_function"></p>
<p>在线性回归（<code>Linear Regression</code>）里，使用平方差函数作为损失函数是可以的，但是在逻辑回归（<code>Logistic Regression</code>）里，使用平方差函数作为损失函数，该函数并不是凸函数（<code>non-convex function</code>），就不能使用梯度下降 <code>gradient descent</code> 找到全局最小值（<code>global minimum</code>）</p>
<p><img src="/2020/01/05/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Ch6_classify/Andrew_Ch06_7.png" alt="cost_funciton"></p>
<h2 id="5-简化代价函数与梯度下降"><a href="#5-简化代价函数与梯度下降" class="headerlink" title="5. 简化代价函数与梯度下降"></a>5. 简化代价函数与梯度下降</h2><p>对代价函数进行简化，写成一个整体，则成为下面的函数：</p>
<p><img src="/2020/01/05/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Ch6_classify/Andrew_Ch06_8.png" alt="gradient_descent"></p>
<p>对代价函数进行求导：</p>
<p><img src="/2020/01/05/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Ch6_classify/Andrew_Ch06_9.png" alt="gradient_descent"></p>
<h2 id="6-高级优化"><a href="#6-高级优化" class="headerlink" title="6. 高级优化"></a>6. 高级优化</h2><p>梯度下降是一个比较常用算法，但由于其在实际的比较大的问题中，速度较慢，因此往往使用比较快速的方法：</p>
<ul>
<li>Conjugate Descent （共轭梯度）</li>
<li>BFGS</li>
<li>L-BFGS</li>
</ul>
<p>这些算法的优点是不用手工设置学习率<code>α</code>，它们算法的内部往往包含一个内循环来自动设置这些学习率，并且每一步的学习率也比较不同，收敛速度较快。</p>
<p><img src="/2020/01/05/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Ch6_classify/Andrew_Ch06_10.png" alt="gradient_descent"></p>
<p>Andrew NG 使用 Octave 演示的梯度下降的例子:</p>
<p><img src="/2020/01/05/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Ch6_classify/Andrew_Ch06_11.png" alt="gradient_descent"></p>
<h2 id="7-多元分类（Multi-Class-Classification）"><a href="#7-多元分类（Multi-Class-Classification）" class="headerlink" title="7. 多元分类（Multi-Class Classification）"></a>7. 多元分类（Multi-Class Classification）</h2><p><code>one-vs-all</code> 的方法：思想很简单，即把多元分类的问题看成多个二元分类问题，来选取置信度最高的那一个；</p>
<p><img src="/2020/01/05/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Ch6_classify/Andrew_Ch06_12.png" alt="one-vs-all"></p>
<p><img src="/2020/01/05/MLDL/AndrewNG%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Ch6_classify/Andrew_Ch06_13.png" alt="one-vs-all"></p>
]]></content>
      <categories>
        <category>MLDL</category>
        <category>AndrewNG机器学习</category>
      </categories>
      <tags>
        <tag>MLDL</tag>
        <tag>AndrewNG机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>hadoop</title>
    <url>/2019/12/10/BigDataSystem/Batch/hadoop/</url>
    <content><![CDATA[<h1 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h1><h2 id="1-安装与配置"><a href="#1-安装与配置" class="headerlink" title="1. 安装与配置"></a>1. 安装与配置</h2><h2 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h2><h3 id="2-1-对-HDFS-文件的增删改查命令"><a href="#2-1-对-HDFS-文件的增删改查命令" class="headerlink" title="2.1 对 HDFS 文件的增删改查命令"></a>2.1 对 <code>HDFS</code> 文件的增删改查命令</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基本格式</span></span><br><span class="line">hadoop fs -cmd &lt;args&gt;</span><br><span class="line"><span class="comment"># ls</span></span><br><span class="line">hadoop fs -ls /</span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line">hadoop fs -r &lt;file&gt;</span><br><span class="line">hadoop fs -rm -r &lt;dir&gt;</span><br><span class="line"><span class="comment"># 新建文件夹</span></span><br><span class="line">hadoop fs -mkdir &lt;path&gt;</span><br><span class="line">hadoop fs -mkdir -p &lt;recursive path&gt;</span><br><span class="line"><span class="comment"># put</span></span><br><span class="line">hadoop fs -put &lt;local file&gt; &lt;hdfs file&gt;</span><br><span class="line"><span class="comment"># get</span></span><br><span class="line">hadoop fs -get &lt;hdfs file&gt; &lt;local file&gt;</span><br><span class="line"><span class="comment"># moveFromLocal</span></span><br><span class="line">hadoop fs -moveFromLocal &lt;local file&gt; &lt;hdfs dst&gt;</span><br><span class="line"><span class="comment"># copyFromLocal</span></span><br><span class="line">hadoop fs -copyFromLocal &lt;local src&gt; &lt;hdfs dst&gt;</span><br><span class="line"><span class="comment"># mv,cp ...</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-运行-hadoop-jar-包"><a href="#2-2-运行-hadoop-jar-包" class="headerlink" title="2.2 运行 hadoop jar 包"></a>2.2 运行 hadoop jar 包</h3><p><code>hadoop jar NaiveBayesDriver.jar naiveBayesDistribute</code></p>
<h2 id="3-Q-amp-A"><a href="#3-Q-amp-A" class="headerlink" title="3. Q&amp;A"></a>3. Q&amp;A</h2><h3 id="3-1-hadoop-fs-put-当在文件路径中包含空格出现-unexpected-URISyntaxException"><a href="#3-1-hadoop-fs-put-当在文件路径中包含空格出现-unexpected-URISyntaxException" class="headerlink" title="3.1 hadoop fs -put 当在文件路径中包含空格出现 unexpected URISyntaxException"></a>3.1 <code>hadoop fs -put</code> 当在文件路径中包含空格出现 <code>unexpected URISyntaxException</code></h3><p>解决方法：　把空格使用　<code>%20</code>　替代</p>
<h3 id="3-2-如何查看hadoop的库文件路径"><a href="#3-2-如何查看hadoop的库文件路径" class="headerlink" title="3.2 如何查看hadoop的库文件路径"></a>3.2 如何查看hadoop的库文件路径</h3><p><code>./bin/hadoop classpath</code>，当不在 <code>maven</code> 工程下进行编译java文件的时候，需要将这个路径引入 <code>classpath</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export CLASSPATH=$($HADOOP_HOME/bin/hadoop classpath):$CLASSPATH</span><br></pre></td></tr></table></figure>

<h3 id="3-3-单机、伪分布、分布模式的切换"><a href="#3-3-单机、伪分布、分布模式的切换" class="headerlink" title="3.3 单机、伪分布、分布模式的切换"></a>3.3 <code>单机、伪分布、分布</code>模式的切换</h3><p><em>参考： <a href="http://dblab.xmu.edu.cn/blog/install-/2019/12/10/BigDataSystem/Batch/hadoop/" target="_blank" rel="noopener">http://dblab.xmu.edu.cn/blog/install-/2019/12/10/BigDataSystem/Batch/hadoop/</a></em></p>
<p>总共涉及四个文件的修改：</p>
<ul>
<li>core-site.xml</li>
<li>hdfs-site.xml</li>
<li>mapred-site.xml</li>
<li>yarn-site.xml</li>
</ul>
<h4 id="3-3-1-单机模式"><a href="#3-3-1-单机模式" class="headerlink" title="3.3.1 单机模式"></a>3.3.1 单机模式</h4><p>安装完成后，默认模式为单机模式</p>
<ul>
<li>core-site.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-伪分布模式"><a href="#3-3-2-伪分布模式" class="headerlink" title="3.3.2 伪分布模式"></a>3.3.2 伪分布模式</h4><ul>
<li>core-site.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/loca/2019/12/10/BigDataSystem/Batch/hadoop/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">description</span>&gt;</span>Abase for other temporary directories. <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://Master:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>hdfs-site.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>Master:50090<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/loca/2019/12/10/BigDataSystem/Batch/hadoop/tmp/dfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/loca/2019/12/10/BigDataSystem/Batch/hadoop/tmp/dfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>与　<code>yarn</code> 有关的两个配置文件：</p>
<ul>
<li>mapred-site.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span>	</span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>Master:10020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">value</span>&gt;</span>Master:19888<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>yarn-site.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Site specific YARN configuration properties --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">value</span>&gt;</span>Master<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./bin/hdfs namenode -format   # 重新格式化 NameNode</span><br><span class="line">./sbin/start-dfs.sh  # 重启</span><br><span class="line">./sbin/start-yarn.sh      # 启动YARN</span><br><span class="line">./sbin/mr-jobhistory-daemon.sh start historyserver  # 开启历史服务器，才能在Web中查看任务运行情况</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<blockquote>
<p><strong>不启动 YARN 需重命名 mapred-site.xml</strong> 如果不想启动 YARN，务必把配置文件 mapred-site.xml 重命名，改成 mapred-site.xml.template，需要用时改回来就行。否则在该配置文件存在，而未开启 YARN 的情况下，运行程序会提示 “Retrying connect to server: 0.0.0.0/0.0.0.0:8032” 的错误，这也是为何该配置文件初始文件名为 mapred-site.xml.template。</p>
</blockquote>
<h4 id="3-3-3-分布模式"><a href="#3-3-3-分布模式" class="headerlink" title="3.3.3 分布模式"></a>3.3.3 分布模式</h4><p>配置文件相比于伪分布式模式多了一个 <code>slaves</code> 文件，里面包含由所有 slave 节点的 hostname，注意：　hosts　文件中应该加入对于 slave hostname 的解析<br>注意事项：</p>
<blockquote>
<p><strong>伪分布式、分布式配置切换时的注意事项</strong></p>
</blockquote>
<blockquote>
<p>1, 从分布式切换到伪分布式时，不要忘记修改 slaves 配置文件；</p>
</blockquote>
<blockquote>
<p>2, 在两者之间切换时，若遇到无法正常启动的情况，可以删除所涉及节点的临时文件夹，这样虽然之前的数据会被删掉，但能保证集群正确启动。所以如果集群以前能启动，但后来启动不了，特别是 DataNode 无法启动，不妨试着删除所有节点（包括 Slave 节点）上的 /usr/loca/2019/12/10/BigDataSystem/Batch/hadoop/tmp 文件夹，再重新执行一次 hdfs namenode -format，再次启动试试。</p>
</blockquote>
<h2 id="4-hadoop分布式程序开发的一般步骤"><a href="#4-hadoop分布式程序开发的一般步骤" class="headerlink" title="4. hadoop分布式程序开发的一般步骤"></a>4. <code>hadoop</code>分布式程序开发的一般步骤</h2><ul>
<li>使用文件系统的接口，使用<code>FileSystem</code>类的一系列方法进行操作文件，这样具有一般性，既可以添加本地文件系统的路径<code>file://xxxx</code>，也可以使用HDFS文件系统的路径<code>hdfs://xxxxx</code></li>
<li>可在打包成<code>jar</code>之前，先将数据集存放在本地文件系统，使用本地文件系统进行测试，没问题后将路径替换为HDFS文件系统的路径；</li>
</ul>
<p><em>虽然也可以直接在IDE中直接进行运行，操作HDFS</em></p>
]]></content>
      <categories>
        <category>BigDataSystem</category>
        <category>Batch</category>
      </categories>
      <tags>
        <tag>BigDataSystem</tag>
        <tag>Batch</tag>
      </tags>
  </entry>
  <entry>
    <title>Ch1_introduction</title>
    <url>/2019/12/01/MLDL/%E6%9D%8E%E8%BD%A9%E7%94%B0%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%9F%B3/Ch1_introduction/</url>
    <content><![CDATA[<h1 id="林轩田机器学习基石"><a href="#林轩田机器学习基石" class="headerlink" title="林轩田机器学习基石"></a>林轩田机器学习基石</h1><p><em>课程链接：<a href="https://www.bilibili.com/video/av12463015/?p=3" target="_blank" rel="noopener">https://www.bilibili.com/video/av12463015/?p=3</a></em></p>
<p>觉得这么课太基础了，有点浪费时间</p>
]]></content>
      <categories>
        <category>MLDL</category>
        <category>李轩田机器学习基石</category>
      </categories>
      <tags>
        <tag>MLDL</tag>
        <tag>李轩田机器学习基石</tag>
      </tags>
  </entry>
  <entry>
    <title>README</title>
    <url>/2019/12/25/Mathmatics/LinearAlgebra/README/</url>
    <content><![CDATA[<h1 id="Linear-Algebra"><a href="#Linear-Algebra" class="headerlink" title="Linear Algebra"></a>Linear Algebra</h1><p>?????????</p>
<h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><h3 id="mit-18-06sc"><a href="#mit-18-06sc" class="headerlink" title="mit 18.06sc"></a>mit 18.06sc</h3><p><em>Instructor: Prof. Gilbert Strang</em></p>
<p>????</p>
<ul>
<li><a href="https://ocw.mit.edu/courses/mathematics/18-06sc-linear-algebra-fall-2011/" target="_blank" rel="noopener">course home</a></li>
</ul>
<p>????</p>
<ul>
<li>MIT 18.06C????????</li>
</ul>
]]></content>
      <categories>
        <category>Mathmatics</category>
        <category>LinearAlgebra</category>
      </categories>
      <tags>
        <tag>Mathmatics</tag>
        <tag>LinearAlgebra</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake</title>
    <url>/2019/11/08/C/CMake/CMake/</url>
    <content><![CDATA[<h1 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h1><p>首先，CMake是什么？<br>引用官方网站</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CMake is an open-source, cross-platform family of tools designed to build, test and package software. </span><br><span class="line">CMake is used to control the software compilation process using simple platform and compiler independent configuration files, </span><br><span class="line">and generate native makefiles and workspaces that can be used in the compiler environment of your choice. </span><br><span class="line">The suite of CMake tools were created by Kitware in response to the need for a powerful, cross-platform build environment </span><br><span class="line">for open-source projects such as ITK and VTK.</span><br></pre></td></tr></table></figure>

<p>其次，怎么用？<br>1.CMake工具链：cmake  + make    </p>
<p>2.编写  CMakeLists.txt文档，使用cmake语言与语法</p>
<p>2.建议语言： C C++ Java</p>
<p>3.安装：官方网站下载安装(一般Linux发行版都已经包含该组件)   </p>
<p>现在开始……</p>
<h1 id="cmake语言与语法"><a href="#cmake语言与语法" class="headerlink" title="cmake语言与语法"></a>cmake语言与语法</h1><p>一份最简化的  CMakeLists.txt  如下：     </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PROJECT(HELLO)</span><br><span class="line">ADD_EXECUTABLE(hello main.c)</span><br></pre></td></tr></table></figure>

<p>扩充一下，加一些提示性信息：      </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PROJECT(HELLO)</span><br><span class="line">SET(SRC_LIST  main.c)</span><br><span class="line">MESSAGE(STATUS  &quot;This is BINARY DIR&quot;  $&#123;HELLO_BINARY_DIR&#125;)</span><br><span class="line">MESSAGE(STATUS  &quot;This is BINARY DIR&quot;  $&#123;HELLO_SOURCE_DIR&#125;)</span><br><span class="line">ADD_EXECUTABLE(hello main.c)</span><br></pre></td></tr></table></figure>

<p>等等，我知道你用SET设置了变量，并且那个 ${} 就是取变量的值，这和  make  脚本编写是一样的，但  HELLO_BINARY_DIR,HELLO_SOURCE_DIR<br>哪来的？？？    </p>
<p>原来在那个 PROJECT 命令里，隐式地定义了两个  cmake 变量  </p>
<ul>
<li><projectname>_BINARY_DIR, <projectname>_SOURCE_DIR<br>因为我们就一个文件 main.c  所以就都指的是当前目录了      </li>
<li>PROJECT_BINARY_DIR, PROJECT_SOURCE_DIR<br>这两个系统预定义的变量与上述两者的含义是完全一致的</li>
</ul>
<p><strong>下面开始语法</strong></p>
<p>1.PROJECT指令：<br><code>PROJECT(projectname  [CXX] [C] [Java])</code><br>后面是支持的语言list,默认是全部支持，当然你也可以自己指定</p>
<p>2.SET指令：<br><code>SET(VAR  [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</code><br>显式地定义变量     </p>
<p>如：SET(SRC_LIST  main.c  hello.c hello1.c)</p>
<p>3.MESSAGE指令：<br><code>MESSAGE([SEND_ERROR  | STATUS  | FATAL_ERROR]  &quot;messageto display&quot;...)</code><br>用于向终端输出用户定义的消息</p>
<p>4.ADD_EXECUTABLE指令：<br>ADD_EXECUTABLE(HELLO  ${SRC_LIST})        </p>
<p>定义该工程会生成一个名为hello的可执行文件，即最终目标文件，后面是相关的源文件列表</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ol>
<li>变量使用  ${}来取值，但是在  IF  控制语句中是直接使用变量名<br>目前，还没遇到，遇到再说吧 :)</li>
</ol>
<p>2.指令是<strong>大小写无关的</strong>，不过一般的指令都是大写的</p>
]]></content>
      <categories>
        <category>C</category>
        <category>CMake</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title>README</title>
    <url>/2019/12/14/Mathmatics/sympy/README/</url>
    <content><![CDATA[<h1 id="Sympy"><a href="#Sympy" class="headerlink" title="Sympy"></a>Sympy</h1><blockquote>
<p>SymPy is a Python library for symbolic mathematics. If you are new to SymPy, start with the Tutorial.<br>This is the central page for all of SymPy’s documentation.</p>
</blockquote>
<p><em>source: <a href="https://docs.sympy.org/1.4/index.html" target="_blank" rel="noopener">https://docs.sympy.org/1.4/index.html</a></em></p>
]]></content>
      <categories>
        <category>Mathmatics</category>
        <category>sympy</category>
      </categories>
      <tags>
        <tag>Mathmatics</tag>
        <tag>sympy</tag>
      </tags>
  </entry>
  <entry>
    <title>README</title>
    <url>/2019/12/25/Mathmatics/Numerical%20Analysis/README/</url>
    <content><![CDATA[<h1 id="数值分析"><a href="#数值分析" class="headerlink" title="数值分析"></a>数值分析</h1><p>数值分析是从计算机的角度解决数学中常见的运算问题。</p>
<p>这里为了能记得比较清晰一些，找了在<code>python</code>上的实验进行实验，加深印象。</p>
<p>推荐视频</p>
<ul>
<li><a href="https://www.bilibili.com/video/av27803928?from=search&seid=1984628040516151416" target="_blank" rel="noopener">陈妍-中国农大-数值计算方法</a></li>
<li>配套讲义-百度云</li>
</ul>
<p>推荐书籍</p>
<ul>
<li>Burden的《Numerical Analysis》</li>
</ul>
<p>编程书籍</p>
<ul>
<li>《MATLAB 数值计算》（2013修订版） Cleve Moler 《Numerical Computation with MATLAB》2008/2013 修订版</li>
</ul>
<hr>
<p>2019/12/25 update</p>
<p>加入搜集到的一些经典算法的实现</p>
]]></content>
      <categories>
        <category>Mathmatics</category>
        <category>Numerical Analysis</category>
      </categories>
      <tags>
        <tag>Mathmatics</tag>
        <tag>Numerical Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>README</title>
    <url>/2019/11/08/C/CMake/README/</url>
    <content><![CDATA[<h1 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h1><p>用 CLion 写信号处理的软件课设的时候出现了链接找不到函数实现的情况，问了老司机，一眼指出我的 CMakeLists.txt 写的有问题    </p>
<p>这是什么鬼？  查查才知道，于是乎，还是好好学习一下    </p>
<h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul>
<li>《CMake Practice》及网上 blogs</li>
<li>CMake 官方网站  <a href="https://cmake.org/" target="_blank" rel="noopener">https://cmake.org/</a></li>
</ul>
]]></content>
      <categories>
        <category>C</category>
        <category>CMake</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CMake</tag>
      </tags>
  </entry>
  <entry>
    <title>ACE_2005</title>
    <url>/2020/01/04/NLP/CORPUS/ACE_2005/</url>
    <content><![CDATA[<h1 id="ACE-2005-数据集详解"><a href="#ACE-2005-数据集详解" class="headerlink" title="ACE 2005 数据集详解"></a>ACE 2005 数据集详解</h1><p><code>ace_2005_td_v7_LDC2006T06</code></p>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><h2 id="2-事件抽取任务"><a href="#2-事件抽取任务" class="headerlink" title="2. 事件抽取任务"></a>2. 事件抽取任务</h2><ul>
<li>事件检测（Event Detection），主要是根据上下文识别出触发词以及代表的事件类型和子类型；</li>
<li>事件元素识别（Argument Detection）：事件元素是指事件的参与者。</li>
</ul>
<h2 id="3-标注类型"><a href="#3-标注类型" class="headerlink" title="3. 标注类型"></a>3. 标注类型</h2><p>ACE2005定义了8种事件类别以及33种子类别。</p>
<p><img src="/2020/01/04/NLP/CORPUS/ACE_2005/ace_2005.jpg" alt="ace_2005"></p>
<p><img src="/2020/01/04/NLP/CORPUS/ACE_2005/ACE2005_datasets.png" alt="ace_2005"></p>
<h2 id="4-文件类型分析"><a href="#4-文件类型分析" class="headerlink" title="4. 文件类型分析"></a>4. 文件类型分析</h2><h3 id="4-1-xxx-apf-xml-文件"><a href="#4-1-xxx-apf-xml-文件" class="headerlink" title="4.1 xxx.apf.xml 文件"></a>4.1 <code>xxx.apf.xml</code> 文件</h3><p>噶该文件为 <code>ACE annotation file format</code>，里面包含了多种标注：<code>entity</code>、<code>relation</code>、<code>event</code>；</p>
<h4 id="4-1-1-entity-的标注"><a href="#4-1-1-entity-的标注" class="headerlink" title="4.1.1 entity 的标注"></a>4.1.1 <code>entity</code> 的标注</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">entity</span> <span class="attr">ID</span>=<span class="string">"CNN_CF_20030303.1900.00-E1"</span> <span class="attr">TYPE</span>=<span class="string">"PER"</span> <span class="attr">SUBTYPE</span>=<span class="string">"Individual"</span> <span class="attr">CLASS</span>=<span class="string">"SPC"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">entity_mention</span> <span class="attr">ID</span>=<span class="string">"CNN_CF_20030303.1900.00-E1-2"</span> <span class="attr">TYPE</span>=<span class="string">"NOM"</span> <span class="attr">LDCTYPE</span>=<span class="string">"NOMPRE"</span> <span class="attr">LDCATR</span>=<span class="string">"TRUE"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">extent</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">charseq</span> <span class="attr">START</span>=<span class="string">"490"</span> <span class="attr">END</span>=<span class="string">"498"</span>&gt;</span>Secretary<span class="tag">&lt;/<span class="name">charseq</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">extent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">charseq</span> <span class="attr">START</span>=<span class="string">"490"</span> <span class="attr">END</span>=<span class="string">"498"</span>&gt;</span>Secretary<span class="tag">&lt;/<span class="name">charseq</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">entity_mention</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">entity_mention</span> <span class="attr">ID</span>=<span class="string">"CNN_CF_20030303.1900.00-E1-14"</span> <span class="attr">TYPE</span>=<span class="string">"NAM"</span> <span class="attr">LDCTYPE</span>=<span class="string">"NAM"</span> <span class="attr">LDCATR</span>=<span class="string">"FALSE"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">extent</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">charseq</span> <span class="attr">START</span>=<span class="string">"754"</span> <span class="attr">END</span>=<span class="string">"793"</span>&gt;</span>Secretary of Homeland Security Tom Ridge<span class="tag">&lt;/<span class="name">charseq</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">extent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">charseq</span> <span class="attr">START</span>=<span class="string">"785"</span> <span class="attr">END</span>=<span class="string">"793"</span>&gt;</span>Tom Ridge<span class="tag">&lt;/<span class="name">charseq</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">entity_mention</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">entity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-1-2-relation-的标注"><a href="#4-1-2-relation-的标注" class="headerlink" title="4.1.2 relation 的标注"></a>4.1.2 <code>relation</code> 的标注</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">relation</span> <span class="attr">ID</span>=<span class="string">"CNN_CF_20030303.1900.00-R2"</span> <span class="attr">TYPE</span>=<span class="string">"PART-WHOLE"</span> <span class="attr">SUBTYPE</span>=<span class="string">"Geographical"</span> <span class="attr">TENSE</span>=<span class="string">"Unspecified"</span> <span class="attr">MODALITY</span>=<span class="string">"Asserted"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">relation_argument</span> <span class="attr">REFID</span>=<span class="string">"CNN_CF_20030303.1900.00-E99"</span> <span class="attr">ROLE</span>=<span class="string">"Arg-1"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">relation_argument</span> <span class="attr">REFID</span>=<span class="string">"CNN_CF_20030303.1900.00-E3"</span> <span class="attr">ROLE</span>=<span class="string">"Arg-2"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">relation_mention</span> <span class="attr">ID</span>=<span class="string">"CNN_CF_20030303.1900.00-R2-1"</span> <span class="attr">LEXICALCONDITION</span>=<span class="string">"Possessive"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">extent</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">charseq</span> <span class="attr">START</span>=<span class="string">"1873"</span> <span class="attr">END</span>=<span class="string">"1882"</span>&gt;</span>our shores<span class="tag">&lt;/<span class="name">charseq</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">extent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relation_mention_argument</span> <span class="attr">REFID</span>=<span class="string">"CNN_CF_20030303.1900.00-E99-69"</span> <span class="attr">ROLE</span>=<span class="string">"Arg-1"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">charseq</span> <span class="attr">START</span>=<span class="string">"1873"</span> <span class="attr">END</span>=<span class="string">"1882"</span>&gt;</span>our shores<span class="tag">&lt;/<span class="name">charseq</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">extent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">relation_mention_argument</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relation_mention_argument</span> <span class="attr">REFID</span>=<span class="string">"CNN_CF_20030303.1900.00-E3-70"</span> <span class="attr">ROLE</span>=<span class="string">"Arg-2"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">charseq</span> <span class="attr">START</span>=<span class="string">"1873"</span> <span class="attr">END</span>=<span class="string">"1875"</span>&gt;</span>our<span class="tag">&lt;/<span class="name">charseq</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">extent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">relation_mention_argument</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">relation_mention</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">relation</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-1-3-event-的标注"><a href="#4-1-3-event-的标注" class="headerlink" title="4.1.3 event 的标注"></a>4.1.3 <code>event</code> 的标注</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">event</span> <span class="attr">ID</span>=<span class="string">"CNN_CF_20030303.1900.00-EV1"</span> <span class="attr">TYPE</span>=<span class="string">"Movement"</span> <span class="attr">SUBTYPE</span>=<span class="string">"Transport"</span> <span class="attr">MODALITY</span>=<span class="string">"Asserted"</span> <span class="attr">POLARITY</span>=<span class="string">"Positive"</span> <span class="attr">GENERICITY</span>=<span class="string">"Specific"</span> <span class="attr">TENSE</span>=<span class="string">"Past"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">event_argument</span> <span class="attr">REFID</span>=<span class="string">"CNN_CF_20030303.1900.00-E96"</span> <span class="attr">ROLE</span>=<span class="string">"Vehicle"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">event_argument</span> <span class="attr">REFID</span>=<span class="string">"CNN_CF_20030303.1900.00-E98"</span> <span class="attr">ROLE</span>=<span class="string">"Person"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">event_argument</span> <span class="attr">REFID</span>=<span class="string">"CNN_CF_20030303.1900.00-E99"</span> <span class="attr">ROLE</span>=<span class="string">"Destination"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">event_argument</span> <span class="attr">REFID</span>=<span class="string">"CNN_CF_20030303.1900.00-E4"</span> <span class="attr">ROLE</span>=<span class="string">"Agent"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">event_mention</span> <span class="attr">ID</span>=<span class="string">"CNN_CF_20030303.1900.00-EV1-1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">extent</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">charseq</span> <span class="attr">START</span>=<span class="string">"369"</span> <span class="attr">END</span>=<span class="string">"449"</span>&gt;</span>a 30-foot Cuban patrol boat with four heavily armed men landed on</span><br><span class="line">American shores<span class="tag">&lt;/<span class="name">charseq</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">extent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ldc_scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">charseq</span> <span class="attr">START</span>=<span class="string">"277"</span> <span class="attr">END</span>=<span class="string">"514"</span>&gt;</span>Even as the</span><br><span class="line">secretary of homeland security was putting his people on high alert last</span><br><span class="line">month, a 30-foot Cuban patrol boat with four heavily armed men landed on</span><br><span class="line">American shores, utterly undetected by the Coast Guard Secretary Ridge</span><br><span class="line">now leads<span class="tag">&lt;/<span class="name">charseq</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ldc_scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">anchor</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">charseq</span> <span class="attr">START</span>=<span class="string">"425"</span> <span class="attr">END</span>=<span class="string">"430"</span>&gt;</span>landed<span class="tag">&lt;/<span class="name">charseq</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">anchor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">event_mention_argument</span> <span class="attr">REFID</span>=<span class="string">"CNN_CF_20030303.1900.00-E96-178"</span> <span class="attr">ROLE</span>=<span class="string">"Vehicle"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">charseq</span> <span class="attr">START</span>=<span class="string">"369"</span> <span class="attr">END</span>=<span class="string">"423"</span>&gt;</span>a 30-foot Cuban patrol boat with four heavily armed men<span class="tag">&lt;/<span class="name">charseq</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">extent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">event_mention_argument</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">event_mention_argument</span> <span class="attr">REFID</span>=<span class="string">"CNN_CF_20030303.1900.00-E98-180"</span> <span class="attr">ROLE</span>=<span class="string">"Person"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">charseq</span> <span class="attr">START</span>=<span class="string">"402"</span> <span class="attr">END</span>=<span class="string">"423"</span>&gt;</span>four heavily armed men<span class="tag">&lt;/<span class="name">charseq</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">extent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">event_mention_argument</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">event_mention_argument</span> <span class="attr">REFID</span>=<span class="string">"CNN_CF_20030303.1900.00-E99-181"</span> <span class="attr">ROLE</span>=<span class="string">"Destination"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">extent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">charseq</span> <span class="attr">START</span>=<span class="string">"435"</span> <span class="attr">END</span>=<span class="string">"449"</span>&gt;</span>American shores<span class="tag">&lt;/<span class="name">charseq</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">extent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">event_mention_argument</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">event_mention</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">event</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-xxx-sgm-文件"><a href="#4-2-xxx-sgm-文件" class="headerlink" title="4.2 xxx.sgm 文件"></a>4.2 <code>xxx.sgm</code> 文件</h3><p><code>.sgm</code>文件为 SGM 格式的文件，其中保存的为新闻的原文</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">DOC</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">DOCID</span>&gt;</span> CNN_CF_20030303.1900.00 <span class="tag">&lt;/<span class="name">DOCID</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">DOCTYPE</span> <span class="attr">SOURCE</span>=<span class="string">"broadcast conversation"</span>&gt;</span> STORY <span class="tag">&lt;/<span class="name">DOCTYPE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">DATETIME</span>&gt;</span> 2003-03-03T19:00:00-05:00 <span class="tag">&lt;/<span class="name">DATETIME</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">BODY</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">HEADLINE</span>&gt;</span></span><br><span class="line">New Questions About Attacking Iraq; Is Torturing Terrorists Necessary?</span><br><span class="line"><span class="tag">&lt;/<span class="name">HEADLINE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TEXT</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TURN</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">SPEAKER</span>&gt;</span> BEGALA <span class="tag">&lt;/<span class="name">SPEAKER</span>&gt;</span></span><br><span class="line">Well, we'll debate that later on in the show. We'll have a couple of</span><br><span class="line">experts come out, so I'll withhold my comments until then. Even as the</span><br><span class="line">secretary of homeland security was putting his people on high alert last</span><br><span class="line">month, a 30-foot Cuban patrol boat with four heavily armed men landed on</span><br><span class="line">American shores, utterly undetected by the Coast Guard Secretary Ridge</span><br><span class="line">now leads. Now, why has our president placed homeland security in the</span><br><span class="line">hands of Republican political hacks instead of professionals, by the way?</span><br><span class="line">Attorney General John Ashcroft, for example, is a career politician. He</span><br><span class="line">lost an election to a dead man. Secretary of Homeland Security Tom Ridge</span><br><span class="line">is another career politician who was passed over by Mr. Bush for the vice</span><br><span class="line">presidency. And Deputy Secretary of Homeland Security Asa Hutchinson is</span><br><span class="line">yet another career politician and a graduate of the disgraceful Bob Jones</span><br><span class="line">University. Apparently, Mr. Bush only turns to professionals when it's</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="5-事件抽取"><a href="#5-事件抽取" class="headerlink" title="5. 事件抽取"></a>5. 事件抽取</h3><p>因为用ACE2005数据集多用来做事件抽取的任务，这里详细介绍下事件抽取相关。</p>
<p>关于 event-type 以及 event-argument 的相关，可以参考 <a href="https://www.ldc.upenn.edu/sites/www.ldc.upenn.edu/files/english-events-guidelines-v5.4.3.pdf" target="_blank" rel="noopener">ldc-document</a></p>
<h3 id="6-ACE-数据的预处理"><a href="#6-ACE-数据的预处理" class="headerlink" title="6. ACE 数据的预处理"></a>6. ACE 数据的预处理</h3>]]></content>
      <categories>
        <category>NLP</category>
        <category>CORPUS</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>CORPUS</tag>
      </tags>
  </entry>
  <entry>
    <title>Neural_Joint_Model_Of_Entities_And_Events</title>
    <url>/2019/11/18/NLP/Course/Neural_Joint_Model_Of_Entities_And_Events/</url>
    <content><![CDATA[<p>#</p>
<p><em>位置：C:\Users\wangc\Desktop\newsGrid\paper\事件抽取\1812.00195.pdf</em></p>
]]></content>
      <categories>
        <category>NLP</category>
        <category>Course</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>Course</tag>
      </tags>
  </entry>
  <entry>
    <title>Distributed-representation-of-words-and-phrases</title>
    <url>/2019/11/18/NLP/Course/Distributed-representation-of-words-and-phrases/</url>
    <content><![CDATA[<p>#</p>
<p><em>位置：C:\Users\wangc\Desktop\newsGrid\paper\representation\5021-distributed-representations-of-words-and-phrases-and-their-compositionality</em></p>
]]></content>
      <categories>
        <category>NLP</category>
        <category>Course</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>Course</tag>
      </tags>
  </entry>
  <entry>
    <title>word2vec</title>
    <url>/2019/11/18/NLP/Course/word2vec/</url>
    <content><![CDATA[<p>#</p>
<p><em>位置：C:\Users\wangc\Desktop\newsGrid\paper\representation\word2vec.pdf</em></p>
]]></content>
      <categories>
        <category>NLP</category>
        <category>Course</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>Course</tag>
      </tags>
  </entry>
  <entry>
    <title>开放域的事件抽取_刘康</title>
    <url>/2019/12/05/NLP/Course/%E5%BC%80%E6%94%BE%E5%9F%9F%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E5%88%98%E5%BA%B7/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>NLP</category>
        <category>Course</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>Course</tag>
      </tags>
  </entry>
  <entry>
    <title>新闻推荐系统_武楚涵</title>
    <url>/2020/01/04/NLP/Course/%E6%96%B0%E9%97%BB%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F_%E6%AD%A6%E6%A5%9A%E6%B6%B5/</url>
    <content><![CDATA[<h1 id="新闻推荐"><a href="#新闻推荐" class="headerlink" title="新闻推荐"></a>新闻推荐</h1><p><em>清华大学武楚涵博士</em></p>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><p><img src="/2020/01/04/NLP/Course/%E6%96%B0%E9%97%BB%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F_%E6%AD%A6%E6%A5%9A%E6%B6%B5/wu01.jpg" alt="wu_01"></p>
<p><img src="/2020/01/04/NLP/Course/%E6%96%B0%E9%97%BB%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F_%E6%AD%A6%E6%A5%9A%E6%B6%B5/wu02.jpg" alt="wu_02"></p>
<ol>
<li>Google News Personalization: Scalable Online Collaborative Filtering”, WWW’07, pp. 271-280, 2007.</li>
</ol>
<p><img src="/2020/01/04/NLP/Course/%E6%96%B0%E9%97%BB%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F_%E6%AD%A6%E6%A5%9A%E6%B6%B5/wu03.jpg" alt="wu_03"></p>
<ol>
<li>Jeong Woo Son, A.-Yeong Kim, Seong-Bae Park:<br>A location-based news article recommendation with explicit localized semantic analysis. SIGIR 2013: 293-302</li>
<li>Trapit Bansal, Mrinal Kanti Das, Chiranjib Bhattacharyya:<br>Content Driven User Profiling for Comment-Worthy Recommendations of News and Blog Articles. RecSys 2015: 195-202</li>
<li>Jianxun Lian, Fuzheng Zhang, Xing Xie, Guangzhong Sun:<br>Towards Better Representation Learning for Personalized News Recommendation: a Multi-Channel Deep Fusion Approach. IJCAI 2018: 3805-3811</li>
</ol>
<p><img src="/2020/01/04/NLP/Course/%E6%96%B0%E9%97%BB%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F_%E6%AD%A6%E6%A5%9A%E6%B6%B5/wu04.jpg" alt="wu_04"></p>
<ol>
<li>Shumpei Okura, Yukihiro Tagami, Shingo Ono, Akira Tajima:<br>Embedding-based News Recommendation for Millions of Users. 1933-1942</li>
</ol>
<p><img src="/2020/01/04/NLP/Course/%E6%96%B0%E9%97%BB%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F_%E6%AD%A6%E6%A5%9A%E6%B6%B5/wu05.jpg" alt="wu_05"></p>
<ol>
<li>Hongwei Wang, Fuzheng Zhang, Xing Xie, Minyi Guo:<br>DKN: Deep Knowledge-Aware Network for News Recommendation. WWW 2018: 1835-1844</li>
</ol>
<p><img src="/2020/01/04/NLP/Course/%E6%96%B0%E9%97%BB%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F_%E6%AD%A6%E6%A5%9A%E6%B6%B5/wu06.jpg" alt="wu_06"></p>
<ol>
<li>Qiannan Zhu, Xiaofei Zhou, Zeliang Song, Jianlong Tan, Li Guo:<br>DAN: Deep Attention Neural Network for News Recommendation. AAAI 2019: 5973-5980</li>
</ol>
<p><img src="/2020/01/04/NLP/Course/%E6%96%B0%E9%97%BB%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F_%E6%AD%A6%E6%A5%9A%E6%B6%B5/wu07.jpg" alt="wu_07"></p>
<ol>
<li>Dhruv Khattar, Vaibhav Kumar, Vasudeva Varma, Manish Gupta:<br>Weave&amp;Rec: A Word Embedding based 3-D Convolutional Network for News Recommendation. CIKM 2018: 1855-1858</li>
</ol>
<p><img src="/2020/01/04/NLP/Course/%E6%96%B0%E9%97%BB%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F_%E6%AD%A6%E6%A5%9A%E6%B6%B5/wu08.jpg" alt="wu_08"></p>
<p><img src="/2020/01/04/NLP/Course/%E6%96%B0%E9%97%BB%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F_%E6%AD%A6%E6%A5%9A%E6%B6%B5/wu09.jpg" alt="wu_09"></p>
<p><img src="/2020/01/04/NLP/Course/%E6%96%B0%E9%97%BB%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F_%E6%AD%A6%E6%A5%9A%E6%B6%B5/wu10.jpg" alt="wu_10"></p>
<p><img src="/2020/01/04/NLP/Course/%E6%96%B0%E9%97%BB%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F_%E6%AD%A6%E6%A5%9A%E6%B6%B5/wu11.jpg" alt="wu_11"></p>
]]></content>
      <categories>
        <category>NLP</category>
        <category>Course</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>Course</tag>
      </tags>
  </entry>
  <entry>
    <title>事件抽取_陈玉博</title>
    <url>/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/</url>
    <content><![CDATA[<h1 id="事件抽取-讲座"><a href="#事件抽取-讲座" class="headerlink" title="事件抽取-讲座"></a>事件抽取-讲座</h1><p><em>主讲人：陈玉博，中科院自动化所，DmCNN的一作</em></p>
<p><em>参考CSDN公开课视频：<a href="https://edu.csdn.net/course/play/25560/307899" target="_blank" rel="noopener">https://edu.csdn.net/course/play/25560/307899</a></em></p>
<h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_01.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_02.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_03.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_04.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_05.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_06.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_07.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_08.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_09.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_10.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_11.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_12.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_13.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_14.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_15.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_16.png" alt="chen_ee"></p>
<h2 id="1-特征表示"><a href="#1-特征表示" class="headerlink" title="1. 特征表示"></a>1. 特征表示</h2><p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_17.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_18.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_19.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_20.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_21.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_22.png" alt="chen_ee"></p>
<h2 id="2-训练数据生成和扩展"><a href="#2-训练数据生成和扩展" class="headerlink" title="2. 训练数据生成和扩展"></a>2. 训练数据生成和扩展</h2><p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_23.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_24.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_25.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_26.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_27.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_28.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_29.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_30.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_31.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_32.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_33.png" alt="chen_ee"></p>
<h2 id="3-多事件协同抽取"><a href="#3-多事件协同抽取" class="headerlink" title="3. 多事件协同抽取"></a>3. 多事件协同抽取</h2><p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_34.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_35.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_36.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_37.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_38.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_39.png" alt="chen_ee"></p>
<h2 id="4-篇章级事件抽取"><a href="#4-篇章级事件抽取" class="headerlink" title="4. 篇章级事件抽取"></a>4. 篇章级事件抽取</h2><p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_40.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_41.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_42.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_43.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_44.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_45.png" alt="chen_ee"></p>
<p><img src="/2020/01/04/NLP/Course/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96_%E9%99%88%E7%8E%89%E5%8D%9A/chen_47.png" alt="chen_ee"></p>
]]></content>
      <categories>
        <category>NLP</category>
        <category>Course</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>Course</tag>
      </tags>
  </entry>
  <entry>
    <title>中文事件抽取综述</title>
    <url>/2020/01/04/NLP/Course/%E4%B8%AD%E6%96%87%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96%E7%BB%BC%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="中文事件抽取技术研究"><a href="#中文事件抽取技术研究" class="headerlink" title="中文事件抽取技术研究"></a>中文事件抽取技术研究</h2><p><em>C:/Users/wangc/Desktop/newsGrid/paper/事件抽取</em></p>
<h3 id="1-Motivation"><a href="#1-Motivation" class="headerlink" title="1. Motivation"></a>1. Motivation</h3><h4 id="1-1-事件抽取的三大关键技术："><a href="#1-1-事件抽取的三大关键技术：" class="headerlink" title="1.1 事件抽取的三大关键技术："></a>1.1 事件抽取的三大关键技术：</h4><ul>
<li>EMD（Entity Mention Detection），实体识别</li>
<li>ED（Event Detection），事件的识别</li>
<li>ARP（Argument Role Prediction），论元角色的识别</li>
</ul>
<h4 id="1-2-事件抽取的方法："><a href="#1-2-事件抽取的方法：" class="headerlink" title="1.2 事件抽取的方法："></a>1.2 事件抽取的方法：</h4><ul>
<li>基于模式匹配的方法</li>
<li>基于机器学习的方法</li>
</ul>
<h4 id="1-3-基于机器学习的方法把事件抽取的任务看作分类问题，"><a href="#1-3-基于机器学习的方法把事件抽取的任务看作分类问题，" class="headerlink" title="1.3 基于机器学习的方法把事件抽取的任务看作分类问题，"></a>1.3 基于机器学习的方法把事件抽取的任务看作分类问题，</h4><blockquote>
<p>Hai Leong Chieu 和 Hwee Tou<br>Ng 于 2002 年首次在事件抽取中引入最大熵分类<br>器[9 ] ,用于事件元素的识别 ; David Ahn 2006 年结<br>合 MegaM 和 Timbl 两种机器学习方法分别实现了<br>事件抽取中事件类别识别和事件元素识别这两个主<br>要步骤 , 在 ACE 英文语料上均取得了不错的效<br>果[4 ] 。 但 Ahn 的方法由于将每个词作为一个实例<br>来训练机器学习模型 ,引入了大量的反例 ,导致正反<br>例严重不平衡 ;此外 ,事件类别的多元分类以及为每<br>类事件元素单独构造多元分类器在语料规模较小的<br>时候存在着一定的数据稀疏问题 。</p>
</blockquote>
<h3 id="2-Method"><a href="#2-Method" class="headerlink" title="2. Method"></a>2. Method</h3><blockquote>
<p>本文提出一种基于触发<br>词扩展和二元分类相结合的识别方法进行事件类别<br>的识别 ,多元分类模型的方法进行事件元素的识别 ,<br>较好的避免了正反例不平衡和数据稀疏问题 。</p>
</blockquote>
<p><strong>keywords: 基于触发词扩展和二元分类的事件识别，多元分类用于事件元素识别</strong></p>
<h4 id="2-1-系统架构图"><a href="#2-1-系统架构图" class="headerlink" title="2.1 系统架构图"></a>2.1 系统架构图</h4><p><img src="/2020/01/04/NLP/Course/%E4%B8%AD%E6%96%87%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96%E7%BB%BC%E8%BF%B0/Paper_%E4%B8%AD%E6%96%87%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96%E7%BB%BC%E8%BF%B01.png" alt="系统架构图"></p>
<h4 id="2-2-事件类别的识别"><a href="#2-2-事件类别的识别" class="headerlink" title="2.2 事件类别的识别"></a>2.2 事件类别的识别</h4><p>a. 通过对句子的分词查看扩充之后的触发词表，并对每一个候选事件划定一个候选事件类别的范围；</p>
<p>b. 通过将候选事件类别识别看作一个二元分类的问题，判断是否为满足候选类别的事件；<br><img src="/2020/01/04/NLP/Course/%E4%B8%AD%E6%96%87%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96%E7%BB%BC%E8%BF%B0/Paper_%E4%B8%AD%E6%96%87%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96%E7%BB%BC%E8%BF%B02.png" alt="特征描述"></p>
<h4 id="2-3-事件元素的识别"><a href="#2-3-事件元素的识别" class="headerlink" title="2.3 事件元素的识别"></a>2.3 事件元素的识别</h4><p>将事件元素的识别任务看成分类问题，转换为对文本中每个候选元素进行类别标签的识别，再进行挑选</p>
<p>a. 三种多元分类的策略</p>
<p><img src="/2020/01/04/NLP/Course/%E4%B8%AD%E6%96%87%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96%E7%BB%BC%E8%BF%B0/Paper_%E4%B8%AD%E6%96%87%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96%E7%BB%BC%E8%BF%B03.png" alt="分类策略"></p>
<p>b. 特征的选取</p>
<p><img src="/2020/01/04/NLP/Course/%E4%B8%AD%E6%96%87%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96%E7%BB%BC%E8%BF%B0/Paper_%E4%B8%AD%E6%96%87%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96%E7%BB%BC%E8%BF%B04.png" alt="分类特征"></p>
<h3 id="3-Performance"><a href="#3-Performance" class="headerlink" title="3. Performance"></a>3. Performance</h3><p>使用 ACE 2005 中文语料作为实验数据，使用 F值的评价方法进行评测。</p>
<h3 id="4-Conclusion"><a href="#4-Conclusion" class="headerlink" title="4. Conclusion"></a>4. Conclusion</h3><p>这篇文章采用的是对事件识别和事件论元识别的分类方法，一种典型的 Pipe Model，在模型的改进方面并没有多大的创新。</p>
]]></content>
      <categories>
        <category>NLP</category>
        <category>Course</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>Course</tag>
      </tags>
  </entry>
  <entry>
    <title>事件抽取</title>
    <url>/2019/12/10/NLP/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96/%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96/</url>
    <content><![CDATA[<h2 id="事件抽取综述"><a href="#事件抽取综述" class="headerlink" title="事件抽取综述"></a>事件抽取综述</h2><p><em>参考：</em></p>
<ul>
<li><a href="http://topin27.github.io/papers/NLP.html#todo-joint-event-extraction-via-recurrent-neural-networks" target="_blank" rel="noopener">topin27的github：关于时间抽取的论文综述</a><h3 id="1-事件"><a href="#1-事件" class="headerlink" title="1. 事件"></a>1. 事件</h3></li>
</ul>
<h4 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h4><blockquote>
<p>在TDT（Topic Detection Tracking）中，事件是指关于某一具体主题的一组相关描述，这个主题可以是由分类或聚类完成的</p>
</blockquote>
<h4 id="1-2-组成元素"><a href="#1-2-组成元素" class="headerlink" title="1.2 组成元素"></a>1.2 组成元素</h4><p>组成事件的各元素包括：触发词、事件类型、论元及论元角色</p>
<ul>
<li>事件触发词：表示事件发生的核心词，多为动词和名词；</li>
<li>事件类型：ACE2005定义了8种事件类型和33种子类型</li>
<li>事件论元：事件的参与者，主要由实体、值和时间构成。值时一种非实体的参与者，例如：工作岗位等</li>
<li>论元角色：事件论元在事件中充当的角色。</li>
</ul>
<p>ACE2005定义了8种事件类型和33种子类型，35类角色类型。将事件抽取任务转化为基于这些模板的多元分类任务。</p>
<h3 id="2-事件抽取技术"><a href="#2-事件抽取技术" class="headerlink" title="2. 事件抽取技术"></a>2. 事件抽取技术</h3><p>目前的事件抽取任务多为分类任务：可分解为4个子任务：触发词识别、事件类型分类、论元识别和角色分类。</p>
<ul>
<li>事件识别任务： 触发词识别和事件类型分类</li>
<li>论元角色识别： 论元识别和角色分类</li>
</ul>
<p>目前原事件抽取的技术主要有：模式匹配和机器学习两个大类</p>
<h4 id="2-1-模式匹配"><a href="#2-1-模式匹配" class="headerlink" title="2.1 模式匹配"></a>2.1 模式匹配</h4><p>模式匹配是在一些模式的指导下进行事件的抽取和识别。抽取时只要通过各种模式匹配算法找出符合模式约束条件信息即可。其核心是抽取模式的构建。但其限定于特定领域在其中拥有较好的效果，并且模式的创建费时费力。典型的基于模式匹配的事件抽取系统有：ExDisco、GenPAM 等。</p>
<h4 id="2-2-机器学习"><a href="#2-2-机器学习" class="headerlink" title="2.2 机器学习"></a>2.2 机器学习</h4><p>使用机器学习的方法进行事件抽取作为一种多元分类的任务，事件抽取方法包括 特征选择 和 分类模型</p>
<ul>
<li>特征选择：根据所使用特征的方法分为：句子级的事件抽取和篇章级的事件抽取</li>
<li>学习方式：分为基于流水线模型的事件抽取方法和基于联合模型的事件抽取方法</li>
</ul>
<h4 id="2-3-评价指标"><a href="#2-3-评价指标" class="headerlink" title="2.3 评价指标"></a>2.3 评价指标</h4><p>对于事件提取的结果的评测一般采用MUC会议的评测标准，包括三个指标：正确率P、召回率R和F值：</p>
<blockquote>
<p>正确率：提取出的正确信息条数 / 提取出的信息条数<br>召回率：提取出的正确信息条数 / 样本的信息条数<br>F-Measure：是Precision和Recall的加权调和平均</p>
</blockquote>
<h3 id="3-相关博客阅读"><a href="#3-相关博客阅读" class="headerlink" title="3. 相关博客阅读"></a>3. 相关博客阅读</h3><h4 id="3-1-Natural-Language-Processing-—-Event-Extraction-Extracting-events-from-news-articles"><a href="#3-1-Natural-Language-Processing-—-Event-Extraction-Extracting-events-from-news-articles" class="headerlink" title="3.1 Natural Language Processing — Event Extraction (Extracting events from news articles)"></a>3.1 Natural Language Processing — Event Extraction (Extracting events from news articles)</h4><p>原文链接：<a href="https://towardsdatascience.com/natural-language-processing-event-extraction-f20d634661d3" target="_blank" rel="noopener">https://towardsdatascience.com/natural-language-processing-event-extraction-f20d634661d3</a></p>
<ul>
<li>数据源：从 newsapi 调用获得</li>
<li>表示：使用了 SpaCy 预训练模型，SpaCy 也是 BoW 模型（这篇文章还介绍了 Sent2Vec， SkipThoughts等）</li>
<li>聚类算法：DBSCAN 不需要设置 cluster 的数量</li>
<li>选取 cluster 最中心的作为代表性语句（时间线根据新闻发布时间为时间线）</li>
</ul>
<p>最后，作者提出的一些改进思路为：合适地进行数据预处理、包括词性标注、NER等应用较好的向量模型等</p>
<h3 id="4-相关软件包"><a href="#4-相关软件包" class="headerlink" title="4. 相关软件包"></a>4. 相关软件包</h3><p>Stanford CoreNLP 是 Stanford 大学自然语言处理小组用 Java 实现的，提供了 Server方式进行交互，使用 <code>Stanford CoreNLP server</code>的 packages 有：</p>
<ul>
<li><p><code>stanfordcorenlp</code>. A python wrapper to Stanford CoreNLP server.</p>
<p>  使用该方式需要下载 Java version Stanford CoreNLP package，并通过该 Python wrapper 调用它</p>
</li>
</ul>
<p>Stanford官方发布了Python版本的NLP处理工具，该工具不再依赖于Java</p>
<ul>
<li><code>stanfordnlp</code></li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://blog.csdn.net/qq_35203425/article/details/80451243" target="_blank" rel="noopener">https://blog.csdn.net/qq_35203425/article/details/80451243</a></li>
<li><a href="http://www.shuang0420.com/2018/10/15/%E7%9F%A5%E8%AF%86%E6%8A%BD%E5%8F%96-%E4%BA%8B%E4%BB%B6%E6%8A%BD%E5%8F%96/" target="_blank" rel="noopener">徐阿衡</a></li>
<li></li>
</ol>
]]></content>
      <categories>
        <category>NLP</category>
        <category>事件抽取</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>事件抽取</tag>
      </tags>
  </entry>
  <entry>
    <title>句法分析</title>
    <url>/2019/12/10/NLP/%E5%8F%A5%E6%B3%95%E5%88%86%E6%9E%90/%E5%8F%A5%E6%B3%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="句法分析"><a href="#句法分析" class="headerlink" title="句法分析"></a>句法分析</h1><p>句法分析，亦称语法分析（Syntactic parsing）是自然语言处理中的一个重要任务，目标是分析句子的语法结构并将其表示为容易理解的结构（通常为树形结构）。</p>
<h2 id="语法形式"><a href="#语法形式" class="headerlink" title="语法形式"></a>语法形式</h2><ul>
<li>短语结构树</li>
<li>依存句法树</li>
</ul>
<h2 id="短语结构树"><a href="#短语结构树" class="headerlink" title="短语结构树"></a>短语结构树</h2><p>短语结构树，其实是上下文无关文法（Context-Free Grammar，CFG），主要基于语言学中的推导规则进行句子的推导，主要的组件有：</p>
<ul>
<li>终结符（terminal symbol）</li>
<li>非终结符（nonterminal symbol）</li>
<li>推导规则</li>
</ul>
<h2 id="依存句法树"><a href="#依存句法树" class="headerlink" title="依存句法树"></a>依存句法树</h2><p>依存句法树关注的是句子中的词语之间的语法联系，并且将其约束为<strong>树形结构</strong>。依存关系（dependency relation）</p>
]]></content>
      <categories>
        <category>NLP</category>
        <category>句法分析</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>句法分析</tag>
      </tags>
  </entry>
  <entry>
    <title>NER工具</title>
    <url>/2020/03/20/NLP/%E5%AE%9E%E4%BD%93%E4%B8%8E%E5%85%B3%E7%B3%BB%E6%8A%BD%E5%8F%96/NER%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="NER工具"><a href="#NER工具" class="headerlink" title="NER工具"></a>NER工具</h1><h2 id="NLTK"><a href="#NLTK" class="headerlink" title="NLTK"></a>NLTK</h2><h2 id="spacy"><a href="#spacy" class="headerlink" title="spacy"></a>spacy</h2><h3 id="支持的语言"><a href="#支持的语言" class="headerlink" title="支持的语言"></a>支持的语言</h3><p><img src="/2020/03/20/NLP/%E5%AE%9E%E4%BD%93%E4%B8%8E%E5%85%B3%E7%B3%BB%E6%8A%BD%E5%8F%96/NER%E5%B7%A5%E5%85%B7/spacy%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B.png" alt="spacy语言模型"></p>
<h3 id="语言模型的安装"><a href="#语言模型的安装" class="headerlink" title="语言模型的安装"></a>语言模型的安装</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#命令行</span></span><br><span class="line">python -m spacy download xx <span class="comment">#xx表示上面表格中的的NAME</span></span><br><span class="line"><span class="comment">#pip</span></span><br><span class="line">pip install https://github.com/explosion/spacy-models/releases/download/en_core_web_md<span class="number">-1.2</span><span class="number">.0</span>/en_core_web_md<span class="number">-1.2</span><span class="number">.0</span>.tar.gz</span><br><span class="line"><span class="comment">#本地文件</span></span><br><span class="line">pip install /Users/you/en_core_web_md<span class="number">-1.2</span><span class="number">.0</span>.tar.gz</span><br></pre></td></tr></table></figure>

<h3 id="实体抽取的类型"><a href="#实体抽取的类型" class="headerlink" title="实体抽取的类型"></a>实体抽取的类型</h3><p><img src="/2020/03/20/NLP/%E5%AE%9E%E4%BD%93%E4%B8%8E%E5%85%B3%E7%B3%BB%E6%8A%BD%E5%8F%96/NER%E5%B7%A5%E5%85%B7/spacy%E5%AE%9E%E4%BD%93%E6%8A%BD%E5%8F%96.png" alt="entity_recognition"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="comment"># reference： https://towardsdatascience.com/named-entity-recognition-with-nltk-and-spacy-8c4a7d88e7da</span></span><br><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line"><span class="keyword">from</span> spacy <span class="keyword">import</span> displacy</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">import</span> pprint</span><br><span class="line"><span class="keyword">import</span> en_core_web_sm</span><br><span class="line"></span><br><span class="line"><span class="comment"># nlp = spacy.load('en_core_web_sm')</span></span><br><span class="line">nlp = en_core_web_sm.load()</span><br><span class="line">text = <span class="string">'''</span></span><br><span class="line"><span class="string">BEIJING • The seafood market in Wuhan may not be the only source of the novel coronavirus (2019-nCoV) outbreak, according to a Chinese pulmonary disease specialist. </span></span><br><span class="line"><span class="string"> Dr Huang Chaolin, vice-director of Wuhan Jinyintan Hospital, revealed in a recent interview with business magazine Caixin that there might be multiple places where the virus was first transmitted to humans. </span></span><br><span class="line"><span class="string"> Wuhan Jinyintan Hospital is one of the city's designated hospitals to admit patients infected with the new virus. </span></span><br><span class="line"><span class="string"> Dr Huang and his team re-cently published a paper in The Lancet, the world's leading general medical journal, about some early findings from the clinical data of the first 41 novel coronavirus cases. </span></span><br><span class="line"><span class="string"> The first patient, who was admitted to Dr Huang's hospital on Dec 1 last year, had no direct exposure to Wuhan's Huanan Seafood Wholesale Market, which was previously considered the source of the epidemic, and his family had no fever or respiratory symptoms, according to the paper. </span></span><br><span class="line"><span class="string"> Among the subsequent three patients who were admitted on Dec 10, two had no exposure to the seafood market. In total, only 27 of the 41 cases had exposure to the marketplace. </span></span><br><span class="line"><span class="string"> "Judging from the whole situation, the seafood market may not be the only source. (The origin of the novel coronavirus) might be multi-source," Dr Huang said. </span></span><br><span class="line"><span class="string"> But no clues about other sources have been discovered. </span></span><br><span class="line"><span class="string"> The Huanan seafood market is located in the downtown area of Wuhan city's Jianghan district, less than 1km away from the Hankou railway station in Hubei province. </span></span><br><span class="line"><span class="string"> Besides seafood, poultry and game meat were also sold in the market before it was shut down on Jan 1. </span></span><br><span class="line"><span class="string"> Experts at the Chinese Centre for Disease Control and Prevention had previously isolated the novel coronavirus successfully in the environmental samples collected from the market. Thirty-three of 585 samples from the market were found to contain the nucleic acid of the virus. </span></span><br><span class="line"><span class="string"> XINHUA'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># doc = nlp('European authorities fined Google a record $5.1 billion on Wednesday for abusing its power in the mobile phone market and ordered the company to alter its practices')</span></span><br><span class="line">doc = nlp(text)</span><br><span class="line">pprint.pprint([(X.text, X.label_) <span class="keyword">for</span> X <span class="keyword">in</span> doc.ents])</span><br><span class="line"></span><br><span class="line">pprint.pprint([(X, X.ent_iob_, X.ent_type_) <span class="keyword">for</span> X <span class="keyword">in</span> doc])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 词性标注</span></span><br><span class="line">doc = nlp(<span class="string">u'Apple is looking at buying U.K. startup for $1 billion'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> doc:</span><br><span class="line">    print(token.text, token.lemma_, token.pos_, token.tag_, token.dep_,</span><br><span class="line">          token.shape_, token.is_alpha, token.is_stop)</span><br><span class="line"><span class="comment"># 依存树</span></span><br><span class="line">doc = nlp(<span class="string">u'Autonomous cars shift insurance liability toward manufacturers'</span>)</span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> doc:</span><br><span class="line">    print(token.text, token.dep_, token.head.text, token.head.pos_,</span><br><span class="line">          [child <span class="keyword">for</span> child <span class="keyword">in</span> token.children])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命名实体识别</span></span><br><span class="line">doc = nlp(<span class="string">u'Apple is looking at buying U.K. startup for $1 billion'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ent <span class="keyword">in</span> doc.ents:</span><br><span class="line">    print(ent.text, ent.start_char, ent.end_char, ent.label_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 标签化</span></span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> doc:</span><br><span class="line">    print(token.text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># displacy.serve(doc, style="ent")</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Crawl the article</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">url_to_string</span><span class="params">(url)</span>:</span></span><br><span class="line">    res = requests.get(url)</span><br><span class="line">    html = res.text</span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">'html5lib'</span>)</span><br><span class="line">    <span class="keyword">for</span> script <span class="keyword">in</span> soup([<span class="string">"script"</span>, <span class="string">"style"</span>, <span class="string">'aside'</span>]):</span><br><span class="line">        script.extract()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">" "</span>.join(re.split(<span class="string">r'[\n\t]+'</span>, soup.get_text()))</span><br><span class="line">ny_bb = url_to_string(<span class="string">'https://www.nytimes.com/2018/08/13/us/politics/peter-strzok-fired-fbi.html?hp&amp;action=click&amp;pgtype=Homepage&amp;clickSource=story-heading&amp;module=first-column-region&amp;region=top-news&amp;WT.nav=top-news'</span>)</span><br><span class="line">article = nlp(ny_bb)</span><br><span class="line">len(article.ents)</span><br><span class="line"></span><br><span class="line">labels = [x.label_ <span class="keyword">for</span> x <span class="keyword">in</span> article.ents]</span><br><span class="line">Counter(labels)</span><br><span class="line"></span><br><span class="line">items = [x.text <span class="keyword">for</span> x <span class="keyword">in</span> article.ents]</span><br><span class="line">Counter(items).most_common(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">sentences = [x <span class="keyword">for</span> x <span class="keyword">in</span> article.sents]</span><br><span class="line">print(sentences[<span class="number">20</span>])</span><br><span class="line"></span><br><span class="line">displacy.render(nlp(str(sentences[<span class="number">20</span>])), jupyter=<span class="literal">True</span>, style=<span class="string">'ent'</span>)</span><br><span class="line"></span><br><span class="line">displacy.render(nlp(str(sentences[<span class="number">20</span>])), style=<span class="string">'dep'</span>, jupyter = <span class="literal">True</span>, options = &#123;<span class="string">'distance'</span>: <span class="number">120</span>&#125;)</span><br><span class="line"></span><br><span class="line">[(x.orth_,x.pos_, x.lemma_) <span class="keyword">for</span> x <span class="keyword">in</span> [y</span><br><span class="line">                                      <span class="keyword">for</span> y</span><br><span class="line">                                      <span class="keyword">in</span> nlp(str(sentences[<span class="number">20</span>]))</span><br><span class="line">                                      <span class="keyword">if</span> <span class="keyword">not</span> y.is_stop <span class="keyword">and</span> y.pos_ != <span class="string">'PUNCT'</span>]]</span><br><span class="line"></span><br><span class="line">dict([(str(x), x.label_) <span class="keyword">for</span> x <span class="keyword">in</span> nlp(str(sentences[<span class="number">20</span>])).ents])</span><br><span class="line"></span><br><span class="line">print([(x, x.ent_iob_, x.ent_type_) <span class="keyword">for</span> x <span class="keyword">in</span> sentences[<span class="number">20</span>]])</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>NLP</category>
        <category>实体与关系抽取</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>实体与关系抽取</tag>
      </tags>
  </entry>
  <entry>
    <title>spacy 使用记录</title>
    <url>/2019/01/16/NLP/%E5%AE%9E%E4%BD%93%E4%B8%8E%E5%85%B3%E7%B3%BB%E6%8A%BD%E5%8F%96/spacy/</url>
    <content><![CDATA[<h1 id="spacy-使用记录"><a href="#spacy-使用记录" class="headerlink" title="spacy 使用记录"></a>spacy 使用记录</h1><h2 id="NER的使用"><a href="#NER的使用" class="headerlink" title="NER的使用"></a>NER的使用</h2><h2 id="EL的使用"><a href="#EL的使用" class="headerlink" title="EL的使用"></a>EL的使用</h2><p>update on 2020/3/26</p>
<p><code>spacy</code> 并没有提供现成的 EL model，而是要通过spacy提供的 framework 自己训练出一个 model，至于为什么 spacy 不提供一个训练好的 model release 出来，见 <a href="https://github.com/explosion/spaCy/issues/4511" target="_blank" rel="noopener">issues#4511</a> 作者给出了解释。</p>
<p>Model 的训练过程需要耗费较长时间，这里记录一下，步骤参考：<a href="https://github.com/explosion/spaCy/tree/master/bin/wiki_entity_linking" target="_blank" rel="noopener">https://github.com/explosion/spaCy/tree/master/bin/wiki_entity_linking</a></p>
<p>Step 1.</p>
<p><code>python wikidata_pretrain_kb.py wiki/latest-all.json.bz2 wiki/enwiki-latest-pages-articles-multistream.xml.bz2 output/ en_core_web_md</code></p>
<p>这里使用的是 英文的 <code>en_core_web_md</code> 模型，使用 <code>en_core_web_sm</code> 模型会报错。</p>
<p>然后经历的过程大概是这样的：</p>
<ul>
<li>Intel(R) Xeon(R) Gold 6132 CPU @ 2.60GHz 6核</li>
<li>60GB 内存</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-03-25 10:57:56,366 - INFO - __main__ - Creating KB with Wikipedia and WikiData</span><br><span class="line">2020-03-25 10:57:56,366 - INFO - __main__ - STEP 1: Loading NLP model en_core_web_md</span><br><span class="line">2020-03-25 10:58:09,601 - INFO - __main__ - STEP 2: Writing prior probabilities to output/prior_prob.csv</span><br><span class="line">2020-03-25 11:02:19,011 - INFO - bin.wiki_entity_linking.wikipedia_processor - processed 25000000 lines of Wikipedia XML dump</span><br><span class="line">2020-03-25 11:06:06,973 - INFO - bin.wiki_entity_linking.wikipedia_processor - processed 50000000 lines of Wikipedia XML dump</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">2020-03-25 13:04:44,104 - INFO - bin.wiki_entity_linking.wikipedia_processor - Finished. processed 1154673507 lines of Wikipedia XML dump</span><br><span class="line">2020-03-25 13:06:49,519 - INFO - __main__ - STEP 3: Calculating and writing entity frequencies to output/entity_freq.csv</span><br><span class="line">2020-03-25 13:07:47,159 - INFO - __main__ - STEP 4: Parsing and writing Wikidata entity definitions to output/entity_defs.csv</span><br><span class="line">2020-03-25 13:11:46,605 - INFO - bin.wiki_entity_linking.wikidata_processor - processed 500000 lines of WikiData JSON dump</span><br><span class="line">2020-03-25 13:14:44,627 - INFO - bin.wiki_entity_linking.wikidata_processor - processed 1000000 lines of WikiData JSON dump</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">2020-03-25 23:17:48,677 - INFO - bin.wiki_entity_linking.wikidata_processor - Finished. Processed 78951019 lines of WikiData JSON dump</span><br><span class="line">2020-03-25 23:17:52,051 - INFO - __main__ - STEP 4b: Writing Wikidata entity aliases to output/entity_alias.csv</span><br><span class="line">2020-03-25 23:17:56,290 - INFO - __main__ - STEP 4c: Writing Wikidata entity descriptions to output/entity_descriptions.csv</span><br><span class="line">2020-03-25 23:17:58,717 - INFO - __main__ - STEP 5: Parsing and writing Wikipedia gold entities to output/gold_entities.jsonl</span><br><span class="line">2020-03-25 23:19:36,808 - INFO - bin.wiki_entity_linking.wikipedia_processor - Processed 10000 articles</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">2020-03-26 02:17:41,098 - INFO - bin.wiki_entity_linking.wikipedia_processor - Finished. Processed 6890313 articles</span><br><span class="line">2020-03-26 02:17:43,364 - INFO - __main__ - STEP 6: Creating the KB at output/kb</span><br><span class="line">2020-03-26 02:17:52,463 - INFO - bin.wiki_entity_linking.kb_creator - Loaded pretrained vectors of size 300</span><br><span class="line">2020-03-26 02:17:52,463 - INFO - bin.wiki_entity_linking.kb_creator - Filtering entities with fewer than 20 mentions</span><br><span class="line">2020-03-26 02:18:17,807 - INFO - bin.wiki_entity_linking.kb_creator - Kept 1148892 entities from the set of 5763431</span><br><span class="line">2020-03-26 02:18:17,808 - INFO - bin.wiki_entity_linking.kb_creator - Training entity encoder</span><br><span class="line">2020-03-26 02:18:27,323 - INFO - bin.wiki_entity_linking.train_descriptions - loss: 1.0226774291992187 </span><br><span class="line">2020-03-26 02:20:38,614 - INFO - bin.wiki_entity_linking.train_descriptions - loss: 0.3986138000488281 </span><br><span class="line">2020-03-26 02:22:47,917 - INFO - bin.wiki_entity_linking.train_descriptions - loss: 0.22751368713378906 </span><br><span class="line">2020-03-26 02:24:58,512 - INFO - bin.wiki_entity_linking.train_descriptions - loss: 0.15389662170410157 </span><br><span class="line">2020-03-26 02:27:09,470 - INFO - bin.wiki_entity_linking.train_descriptions - loss: 0.11821630859375 </span><br><span class="line">2020-03-26 02:29:19,072 - INFO - bin.wiki_entity_linking.train_descriptions - loss: 0.09795716857910156 </span><br><span class="line">2020-03-26 02:31:27,877 - INFO - bin.wiki_entity_linking.train_descriptions - loss: 0.0902191925048828 </span><br><span class="line">2020-03-26 02:33:37,375 - INFO - bin.wiki_entity_linking.train_descriptions - loss: 0.07779336547851562 </span><br><span class="line">2020-03-26 02:35:46,578 - INFO - bin.wiki_entity_linking.train_descriptions - loss: 0.07243069458007813 </span><br><span class="line">2020-03-26 02:37:56,318 - INFO - bin.wiki_entity_linking.train_descriptions - loss: 0.07262858581542969 </span><br><span class="line">2020-03-26 02:40:06,218 - INFO - bin.wiki_entity_linking.train_descriptions - loss: 0.07191573333740234 </span><br><span class="line">2020-03-26 02:42:16,195 - INFO - bin.wiki_entity_linking.train_descriptions - loss: 0.07062159729003906 </span><br><span class="line">2020-03-26 02:44:26,376 - INFO - bin.wiki_entity_linking.train_descriptions - loss: 0.0659771957397461 </span><br><span class="line">2020-03-26 02:46:36,478 - INFO - bin.wiki_entity_linking.train_descriptions - loss: 0.06245959091186523 </span><br><span class="line">2020-03-26 02:48:08,080 - INFO - bin.wiki_entity_linking.train_descriptions - Trained entity descriptions on 343000 (non-unique) descriptions across 5 epochs</span><br><span class="line">2020-03-26 02:48:08,081 - INFO - bin.wiki_entity_linking.train_descriptions - Final loss: 0.06493917846679688</span><br><span class="line">2020-03-26 02:48:08,081 - INFO - bin.wiki_entity_linking.kb_creator - Getting entity embeddings</span><br><span class="line">2020-03-26 02:49:16,621 - INFO - bin.wiki_entity_linking.train_descriptions - Encoded: 200000 entities</span><br><span class="line">2020-03-26 02:50:26,592 - INFO - bin.wiki_entity_linking.train_descriptions - Encoded: 300000 entities</span><br><span class="line">2020-03-26 02:51:30,845 - INFO - bin.wiki_entity_linking.train_descriptions - Encoded: 400000 entities</span><br><span class="line">2020-03-26 02:52:37,864 - INFO - bin.wiki_entity_linking.train_descriptions - Encoded: 500000 entities</span><br><span class="line">2020-03-26 02:53:41,903 - INFO - bin.wiki_entity_linking.train_descriptions - Encoded: 600000 entities</span><br><span class="line">2020-03-26 02:54:48,951 - INFO - bin.wiki_entity_linking.train_descriptions - Encoded: 700000 entities</span><br><span class="line">2020-03-26 02:55:53,231 - INFO - bin.wiki_entity_linking.train_descriptions - Encoded: 800000 entities</span><br><span class="line">2020-03-26 02:57:01,271 - INFO - bin.wiki_entity_linking.train_descriptions - Encoded: 900000 entities</span><br><span class="line">2020-03-26 02:58:04,693 - INFO - bin.wiki_entity_linking.train_descriptions - Encoded: 1000000 entities</span><br><span class="line">2020-03-26 02:59:13,314 - INFO - bin.wiki_entity_linking.train_descriptions - Encoded: 1100000 entities</span><br><span class="line">2020-03-26 03:00:18,196 - INFO - bin.wiki_entity_linking.train_descriptions - Encoded: 1148892 entities</span><br><span class="line">2020-03-26 03:00:49,433 - INFO - bin.wiki_entity_linking.train_descriptions - Encoded: 1148892 entities</span><br><span class="line">2020-03-26 03:00:49,558 - INFO - bin.wiki_entity_linking.kb_creator - Adding 1148892 entities</span><br><span class="line">2020-03-26 03:00:57,009 - INFO - bin.wiki_entity_linking.kb_creator - Adding aliases from Wikipedia and Wikidata</span><br><span class="line">2020-03-26 03:00:57,011 - INFO - bin.wiki_entity_linking.kb_creator - Adding WP aliases</span><br><span class="line">2020-03-26 03:01:58,750 - INFO - __main__ - kb entities: 1148892</span><br><span class="line">2020-03-26 03:01:58,750 - INFO - __main__ - kb aliases: 1665015</span><br><span class="line">2020-03-26 03:02:09,177 - INFO - __main__ - Done!</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>NLP</category>
        <category>实体与关系抽取</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>实体与关系抽取</tag>
      </tags>
  </entry>
  <entry>
    <title>wiki data 简介</title>
    <url>/2019/01/16/NLP/%E5%AE%9E%E4%BD%93%E4%B8%8E%E5%85%B3%E7%B3%BB%E6%8A%BD%E5%8F%96/wiki_data/</url>
    <content><![CDATA[<h1 id="Wikidata-简介"><a href="#Wikidata-简介" class="headerlink" title="Wikidata 简介"></a>Wikidata 简介</h1><p>这里为什么简要介绍 wiki data，因为实体链接（Entity link）常用到的数据集是 wiki data，</p>
<h2 id="wiki-data-与-wiki-pedia-的关系"><a href="#wiki-data-与-wiki-pedia-的关系" class="headerlink" title="wiki data 与 wiki pedia 的关系"></a>wiki data 与 wiki pedia 的关系</h2><blockquote>
<p>wikidata is a free and open knowledge base that can be read and edited by both humans and machines. Wikidata acts as central storage for the structured data of its Wikimedia sister projects including Wikipedia, Wikivoyage, Wikisource, and others.</p>
</blockquote>
<h2 id="wiki-data-的说明-url"><a href="#wiki-data-的说明-url" class="headerlink" title="wiki data 的说明 url"></a>wiki data 的说明 <a href="https://en.wikipedia.org/wiki/Wikidata" target="_blank" rel="noopener">url</a></h2><ul>
<li>Items: Wikidata is a document-oriented database, focused on items, which represent topics, concepts, or objects.Each item is identified by a unique number, prefixed with the letter Q, known as a “QID”.</li>
<li>Property: A property describes the data value of a statement and can be thought of as a category of data, for example color (P462) for the data value blue (Q1088).</li>
<li>Statements: Statements are how any information known about an item is recorded in Wikidata. </li>
<li>Lexemes: In linguistics, a lexeme is a unit of lexical meaning. Similarly, Wikidata’s lexemes are items with a structure that makes them more suitable to store lexicographical data.</li>
</ul>
<h2 id="Wikidata-api-的使用"><a href="#Wikidata-api-的使用" class="headerlink" title="Wikidata api 的使用"></a>Wikidata api 的使用</h2><ul>
<li><a href="https://www.wikidata.org/w/api.php" target="_blank" rel="noopener">api document</a></li>
<li><a href="https://www.mediawiki.org/wiki/API:Presenting_Wikidata_knowledge" target="_blank" rel="noopener">document2</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">params = dict (</span><br><span class="line">        action=<span class="string">'wbsearchentities'</span>,</span><br><span class="line">        format=<span class="string">'json'</span>,</span><br><span class="line">        language=<span class="string">'en'</span>,</span><br><span class="line">        uselang=<span class="string">'en'</span>,</span><br><span class="line">        <span class="comment"># type='property',</span></span><br><span class="line">        search=<span class="string">'Hubei Province'</span></span><br><span class="line">        )</span><br><span class="line">http_proxies = &#123;</span><br><span class="line">    <span class="string">"http"</span>: <span class="string">"http://127.0.0.1:1080"</span>,</span><br><span class="line">    <span class="string">"https"</span>: <span class="string">"https://127.0.0.1:1080"</span></span><br><span class="line">&#125;</span><br><span class="line">response = requests.get(<span class="string">'https://www.wikidata.org/w/api.php?'</span>, params, proxies=http_proxies).json()</span><br><span class="line">print(response.get(<span class="string">'search'</span>)[<span class="number">0</span>][<span class="string">'id'</span>])</span><br></pre></td></tr></table></figure>

<h2 id="Wikipedia-api-的使用"><a href="#Wikipedia-api-的使用" class="headerlink" title="Wikipedia api 的使用"></a>Wikipedia api 的使用</h2><ul>
<li><a href="https://en.wikipedia.org/w/api.php?action=help&modules=query" target="_blank" rel="noopener">api document</a></li>
<li><a href="https://www.mediawiki.org/wiki/API:Main_page" target="_blank" rel="noopener">document2</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">params_wikipedia = dict (</span><br><span class="line">        action=<span class="string">'query'</span>,</span><br><span class="line">        prop=<span class="string">'pageprops'</span>,</span><br><span class="line">        ppprop=<span class="string">'wikibase_item'</span>,</span><br><span class="line">        redirects=<span class="number">1</span>,</span><br><span class="line">        titles=<span class="string">'trump'</span></span><br><span class="line">)</span><br><span class="line">http_proxies = &#123;</span><br><span class="line">    <span class="string">"http"</span>: <span class="string">"http://127.0.0.1:1080"</span>,</span><br><span class="line">    <span class="string">"https"</span>: <span class="string">"https://127.0.0.1:1080"</span></span><br><span class="line">&#125;</span><br><span class="line">response = requests.get(<span class="string">'https://en.www.wikipedia.org/w/api.php?'</span>, params, proxies=http_proxies).json()</span><br></pre></td></tr></table></figure>

<ul>
<li><code>pip install wikipedia</code> 上述方法的 python 库版本</li>
</ul>
<blockquote>
<p>Wikipedia is a Python library that makes it easy to access and parse data from Wikipedia.<br>Search Wikipedia, get article summaries, get data like links and images from a page, and more. Wikipedia wraps the MediaWiki API so you can focus on using Wikipedia data, not getting it.</p>
</blockquote>
<p>注： wikidata api 与 wikipedia api 所返回的的 QID 都是吧wikidata 中的 QID，但 pageId 不同，它分别代表在 Wikidata 与 Wikipedia 中的 page number.</p>
<h2 id="Wikidata-数据源的下载"><a href="#Wikidata-数据源的下载" class="headerlink" title="Wikidata 数据源的下载"></a>Wikidata 数据源的下载</h2><p><a href="https://www.wikidata.org/wiki/Wikidata:Database_download" target="_blank" rel="noopener">https://www.wikidata.org/wiki/Wikidata:Database_download</a> 可下载 Wikidata 的数据（数据规模较大），进行关系抽取等任务。</p>
<p><code>spacy</code> 的 EL（Entity Link）任务就是利用从 Wikidata 下载的数据进行模型的训练。</p>
<blockquote>
<p>This takes as input the locations of a Wikipedia and a Wikidata dump, and produces a KB directory + training file</p>
<ul>
<li>WikiData: get latest-all.json.bz2 from <a href="https://dumps.wikimedia.org/wikidatawiki/entities/" target="_blank" rel="noopener">https://dumps.wikimedia.org/wikidatawiki/entities/</a></li>
<li>Wikipedia: get enwiki-latest-pages-articles-multistream.xml.bz2 from <a href="https://dumps.wikimedia.org/enwiki/latest/" target="_blank" rel="noopener">https://dumps.wikimedia.org/enwiki/latest/</a> (or for any other language)</li>
</ul>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>两种方式进行 entity 的查询会返回一系列 candidate 进行候选，这种方法往往在 NLP 的 <code>实体对齐、实体消歧</code> 中存在一定的局限性，常作为 EL 的前序步骤。</p>
]]></content>
      <categories>
        <category>NLP</category>
        <category>实体与关系抽取</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>实体与关系抽取</tag>
      </tags>
  </entry>
  <entry>
    <title>关系抽取</title>
    <url>/2019/12/18/NLP/%E5%AE%9E%E4%BD%93%E4%B8%8E%E5%85%B3%E7%B3%BB%E6%8A%BD%E5%8F%96/%E5%85%B3%E7%B3%BB%E6%8A%BD%E5%8F%96/</url>
    <content><![CDATA[<h1 id="关系抽取"><a href="#关系抽取" class="headerlink" title="关系抽取"></a>关系抽取</h1><p><em>这里我所理解的关系抽取是相对于事件抽取而言少了触发词检测和事件类别识别的工作，侧重于在对实体与实体之间的修饰关系的抽取，而不同于实体与动作之间关系的抽取</em></p>
<h2 id="Paper"><a href="#Paper" class="headerlink" title="Paper"></a>Paper</h2><h3 id="Survey"><a href="#Survey" class="headerlink" title="Survey"></a>Survey</h3><ol>
<li><em>A Survey of Deep Learning Methods for Relation Extraction.Shantanu Kumar. 2017.</em></li>
<li><em>Relation Extraction : A Survey.Sachin Pawara,b, Girish K. Palshikara, Pushpak</em></li>
</ol>
<h2 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h2><ol>
<li>project on github: <a href="https://github.com/topics/relation-extraction?l=python" target="_blank" rel="noopener">https://github.com/topics/relation-extraction?l=python</a></li>
</ol>
<p><strong>Star project</strong></p>
<ul>
<li><a href="https://github.com/thunlp/OpenNRE" target="_blank" rel="noopener">OpenNRE</a></li>
</ul>
<blockquote>
<p><a href="https://magi.com/" target="_blank" rel="noopener">Magi</a> is not a supervised system, which means it is open domain relation extraction, this is not included in OpenNRE. If you have an English application, <a href="https://stanfordnlp.github.io/CoreNLP/openie.html" target="_blank" rel="noopener">OpenIE</a>, <a href="http://reverb.cs.washington.edu/" target="_blank" rel="noopener">ReVerb</a> or other open relation extraction tools are worth to have a try.</p>
</blockquote>
<ul>
<li><a href="https://stanfordnlp.github.io/CoreNLP/openie.html#simple-corenlp-api" target="_blank" rel="noopener">OpenIE</a>(stanford open information extraction)</li>
</ul>
<h2 id="预定义的关系抽取"><a href="#预定义的关系抽取" class="headerlink" title="预定义的关系抽取"></a>预定义的关系抽取</h2><p>抽取的关系类别是定义好的，给定的语料的结构也是比较单一的，是预定义的关系抽取。是个有监督的关系抽取技术，例如：<code>OpenNRE</code>，常见的语料有：<code>ACE</code>、<code>SemEval</code>、<code>TAC-KBP</code></p>
<h2 id="开放域的关系抽取"><a href="#开放域的关系抽取" class="headerlink" title="开放域的关系抽取"></a>开放域的关系抽取</h2><p><em>来源：<a href="https://zhuanlan.zhihu.com/p/41207156" target="_blank" rel="noopener">中科院赵军：开放域事件抽取|CCF-GAIR 2018</a></em></p>
<p><code>Freebase</code> 4000多万实体，上万个属性关系，24亿个事实三元组。依靠人工标注的训练集在这方面肯定是行不通的，必须考虑一些自动的或者弱监督的、半监督的方法来做开放域的关系抽取。通常在开放域的关系抽取抽出的关系字段是链接两个实体的文本。</p>
<blockquote>
<p>Typically the relation name is just the text linking two arguments. For example, Barack Obama was born in Hawaii would create a triple (Barack Obama; was born in; Hawaii), corresponding to the open domain relation was-born-in(Barack-Obama, Hawaii). </p>
</blockquote>
<h3 id="如何获取训练语料"><a href="#如何获取训练语料" class="headerlink" title="如何获取训练语料"></a>如何获取训练语料</h3><ul>
<li>基于句法的方法，通过句法分析器，对句子找出同样表达的三元结构，放在一起就是我们需要的知识</li>
<li>基于知识监督的方法</li>
</ul>
<blockquote>
<p>2007 年 CIKM 的论文最早提出这样的思想，在 Wikipedia 中可以分成两个区域，一个区域是结构化部分，我们叫做 Infobox，另一个区域是自然语言表达的部分，这两部分描述的信息有重叠，比如描述清华大学和建校时间的知识，在 Infobox 和自然语言里面有重叠的描述，如果把这两部分对应起来，就可以对应两边区域的知识，一边是它的训练集。这是一个非常简单的思想。如果用 Infobox 的结构化信息在 wikipedia 条目的自然语言文本中进行回标，可以自动产生训练语料。</p>
</blockquote>
<h3 id="thunlp-在关系抽取方面的成果"><a href="#thunlp-在关系抽取方面的成果" class="headerlink" title="thunlp 在关系抽取方面的成果"></a>thunlp 在关系抽取方面的成果</h3><p><a href="https://www.jiqizhixin.com/articles/2019-11-18-2" target="_blank" rel="noopener">机器之心-知识图谱从哪里来：实体关系抽取的现状与未来</a></p>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ol>
<li>thunlp 资料整理：<a href="https://github.com/thunlp/NREPapers" target="_blank" rel="noopener">https://github.com/thunlp/NREPapers</a></li>
<li>知乎用户整理：<a href="https://zhuanlan.zhihu.com/p/73857023" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/73857023</a></li>
<li>一个比较好的网站：<a href="http://nlpprogress.com/english/relationship_extraction.html" target="_blank" rel="noopener">http://nlpprogress.com/english/relationship_extraction.html</a></li>
<li><a href="http://www.shuang0420.com/2018/09/15/%E7%9F%A5%E8%AF%86%E6%8A%BD%E5%8F%96-%E5%AE%9E%E4%BD%93%E5%8F%8A%E5%85%B3%E7%B3%BB%E6%8A%BD%E5%8F%96/" target="_blank" rel="noopener">徐阿衡的博客</a></li>
<li><a href="https://yam.gift/2019/12/11/KG/2019-12-11-Relationship-Extraction/?nsukey=C6qNhMRVv4F%2FfrB0wEm0d8laZp4NeQQhIxPtI4QcWyBc6pesMsAdSSRj6edN80HZT5vwAgaX9oE9BC8r1E%2BKm%2BFPy%2BsryhViv5eojtlJf4g%2ButND7rBNLT3VwGHdOc9Dl75gahGONWGc9rLIRd%2FXcz10kqKjHJxM74C3eVAzjzF0nz9DUIaVzKJJ1p2Pghmh6GXYpaNSiWa8fM4k82EGuA%3D%3D" target="_blank" rel="noopener">Yam大佬的博客</a></li>
</ol>
]]></content>
      <categories>
        <category>NLP</category>
        <category>实体与关系抽取</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>实体与关系抽取</tag>
      </tags>
  </entry>
  <entry>
    <title>关系抽取数据集</title>
    <url>/2019/01/16/NLP/%E5%AE%9E%E4%BD%93%E4%B8%8E%E5%85%B3%E7%B3%BB%E6%8A%BD%E5%8F%96/%E5%85%B3%E7%B3%BB%E6%8A%BD%E5%8F%96%E6%95%B0%E6%8D%AE%E9%9B%86/</url>
    <content><![CDATA[<h1 id="关系抽取数据集"><a href="#关系抽取数据集" class="headerlink" title="关系抽取数据集"></a>关系抽取数据集</h1><h2 id="常用的几种精标关系抽取数据集"><a href="#常用的几种精标关系抽取数据集" class="headerlink" title="常用的几种精标关系抽取数据集"></a>常用的几种精标关系抽取数据集</h2><p><img src="/2019/01/16/NLP/%E5%AE%9E%E4%BD%93%E4%B8%8E%E5%85%B3%E7%B3%BB%E6%8A%BD%E5%8F%96/%E5%85%B3%E7%B3%BB%E6%8A%BD%E5%8F%96%E6%95%B0%E6%8D%AE%E9%9B%86/some-datasets-statistic.png" alt="几种常用的关系抽取数据集"></p>
<ul>
<li><p>FewRel <a href="https://github.com/thunlp/FewRel" target="_blank" rel="noopener">github</a></p>
<blockquote>
<p>以 wikipedia 作为语料库，以 wikipedia 作为知识图谱构建。由孙茂松教授领导的清华大学自然语言处理实验室发布了一个大规模精标注关系抽取数据集 FewRel。据了解，这是目前最大的精标注关系抽取数据集。该数据集包含 100 个类别、70,000 个实例，全面超越了以往的同类精标注数据集。FewRel 不仅可以应用在经典的监督/远监督关系抽取任务中，在新兴的少次学习（few-shot learning）任务上也有极大的探索价值和广阔的应用前景。相关论文《Classification Dataset with State-of-the-Art Evaluation》</p>
</blockquote>
</li>
<li><p>SemEval-2010 Task 8</p>
<blockquote>
<p>SemEval(International Workshop on Semantic Evaluation) 国际语义评测大会，在会上有多个tasks，参赛人员完成相应的任务后可以投 paper 到 SemEval 2020.</p>
</blockquote>
<blockquote>
<p>SemEval-2010的任务8关注的是两个名词之间的语义关系。例如，茶和人参是在“从德里人参的杯子里”的一种物质来源关系中。语义关系的自动识别有许多应用，如信息提取、文档摘要、机器翻译、词汇和语义网络的构建等。它还可以促进辅助任务，如wordsense消除歧义、语言建模、语法分析和识别文本蕴涵。<a href="https://languageresources.github.io/2018/05/13/%E5%8D%A2%E6%A2%A6%E4%BE%9D_SemEval2010%20Task8%20%E5%85%B3%E7%B3%BB%E6%8A%BD%E5%8F%96%E6%95%B0%E6%8D%AE%E9%9B%86/" target="_blank" rel="noopener">来源</a> ， <a href="http://semeval2.fbk.eu/semeval2.php?location=data" target="_blank" rel="noopener">download</a></p>
</blockquote>
</li>
<li><p>MUC（Message Understanding Conference) 关系抽取</p>
<blockquote>
<p>MUC-7的五大评测任务分别是命名实体识别、共指消解、模板元素填充、模板关系确定和场景模板填充。数据语料主要来自新闻语料，限定领域为飞机失事报道和航天器发射事件报道。</p>
</blockquote>
</li>
<li><p>ACE 关系抽取数据集</p>
<blockquote>
<p>MUC会议停开后，ACE将关系抽取任务作为一个子任务从2002至2007年共持续六年。关系抽取任务也被定义的更加规范和系统。其中，获得认可的一届关系抽取任务主要是ACE-2004，其数据来源于语言数据联盟（LDC），分成广播新闻和新闻专线两部分，总共包括451和文档和5702个关系实例。ACE20014提供了丰富的标注信息，从而为信息抽取中的实体识别、指代消解和关系抽取等子任务提供基准的训练和测试语料库。</p>
</blockquote>
</li>
<li><p>TAC-KBP 数据集：<a href="https://nlp.stanford.edu/projects/tacred/" target="_blank" rel="noopener">stanford-nlp-tacred</a></p>
<blockquote>
<p>TAC会议下的KBP评测下的ESF任务，可以视作是传统的关系抽取任务。该任务主要是抽取关于PER的25中属性和ORG的16中属性。主要是使用维基百科快照作为现有的知识库，从现有的新闻或者网络文本中获取关于实体的现有信息和更新信息，以构建知识库。</p>
</blockquote>
<blockquote>
<p>TACRED is a large-scale relation extraction dataset with 106,264 examples built over newswire and web text from the corpus used in the yearly TAC Knowledge Base Population (TAC KBP) challenges. Examples in TACRED cover 41 relation types as used in the TAC KBP challenges (e.g., per:schools_attended and org:members) or are labeled as no_relation if no defined relation is held. These examples are created by combining available human annotations from the TAC KBP challenges and crowdsourcing.</p>
</blockquote>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/lusic01/article/details/94018455" target="_blank" rel="noopener">CSDN-史上最大实体关系抽取数据集</a></li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
        <category>实体与关系抽取</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>实体与关系抽取</tag>
      </tags>
  </entry>
  <entry>
    <title>实体链接（Entity Link）</title>
    <url>/2019/01/16/NLP/%E5%AE%9E%E4%BD%93%E4%B8%8E%E5%85%B3%E7%B3%BB%E6%8A%BD%E5%8F%96/%E5%AE%9E%E4%BD%93%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="实体链接（Entity-Link）"><a href="#实体链接（Entity-Link）" class="headerlink" title="实体链接（Entity Link）"></a>实体链接（Entity Link）</h1><p>实体链接是构建知识图谱中 NER（实体抽取）后续的一步，主要对异构数据源中的不同 mention 对应到 Knowledge Base 中的 Entity.</p>
<p>这里有一篇很不错的总结 <a href="https://mp.weixin.qq.com/s?__biz=MzI0ODcxODk5OA==&mid=2247512392&idx=3&sn=9aa4fcf03743afec55b3ce86526aea8a&chksm=e99e82b1dee90ba7e033a35937720529708042ba9107abf1063f8da582a7259d4e67d62c672e&mpshare=1&scene=1&srcid=0325Li1Uw40dxdp1IwPY0z5B&sharer_sharetime=1585144022945&sharer_shareid=df1013bd655d09f93207e8213ac4db3a#rd" target="_blank" rel="noopener">知识图谱-实体链接综述</a></p>
]]></content>
      <categories>
        <category>NLP</category>
        <category>实体与关系抽取</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>实体与关系抽取</tag>
      </tags>
  </entry>
  <entry>
    <title>词性标注与命名实体的识别</title>
    <url>/2020/01/04/NLP/%E5%AE%9E%E4%BD%93%E4%B8%8E%E5%85%B3%E7%B3%BB%E6%8A%BD%E5%8F%96/%E8%AF%8D%E6%80%A7%E6%A0%87%E6%B3%A8%E4%B8%8E%E5%91%BD%E5%90%8D%E5%AE%9E%E4%BD%93%E7%9A%84%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h3 id="1-词性标注"><a href="#1-词性标注" class="headerlink" title="1.词性标注"></a>1.词性标注</h3><p>词性标注完成的任务是对词性进行标注如动词、名词、形容词等，为下游的任务如句法分析提供预处理步骤，将数量极大的词标注到数百种的词性上。</p>
<p>目前采用的词性标注方法采用的往往和分词方法相同的一些序列标注模型，在中文词性标注中常用到的模型有：</p>
<ul>
<li>基于隐马尔科夫模型的词性标注（Hidden Markov Model）</li>
<li>基于感知机的词性标注</li>
<li>基于条件随机场的词性标注（Conditional Random Field）</li>
</ul>
<h3 id="2-命名实体的识别（Named-Entity-Recognization）"><a href="#2-命名实体的识别（Named-Entity-Recognization）" class="headerlink" title="2.命名实体的识别（Named Entity Recognization）"></a>2.命名实体的识别（Named Entity Recognization）</h3><p>命名实体的识别，是为了识别语料中的人命、地名、机构名等命名实体，往往也可采用基于规则和基于统计的模型，类似于序列标注模型</p>
<h4 id="2-1-NER的相关模型和方法"><a href="#2-1-NER的相关模型和方法" class="headerlink" title="2.1 NER的相关模型和方法"></a>2.1 NER的相关模型和方法</h4><p><img src="%E8%AF%8D%E6%80%A7%E6%A0%87%E6%B3%A8%E4%B8%8E%E5%91%BD%E5%90%8D%E5%AE%9E%E4%BD%93%E8%AF%86%E5%88%AB/NER.png" alt="NER模型"></p>
<h4 id="2-2-常用的技术"><a href="#2-2-常用的技术" class="headerlink" title="2.2 常用的技术"></a>2.2 常用的技术</h4><p>基于规则的方法</p>
<ul>
<li>语言专家手工构造规则模板</li>
</ul>
<p>基于统计的方法</p>
<ul>
<li>隐马尔科夫模型（HMM）</li>
<li>最大熵（ME)</li>
<li>支持向量机（SVM）</li>
<li>条件随机场（CRF)</li>
</ul>
<p>基于深度学习的方法 </p>
<p><em>参考：<a href="https://zhuanlan.zhihu.com/p/43061858" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/43061858</a></em></p>
<ul>
<li>Bert-BiLSTM-CRF: <a href="https://github.com/macanv/BERT-BiLSTM-CRF-NER" target="_blank" rel="noopener">https://github.com/macanv/BERT-BiLSTM-CRF-NER</a></li>
<li>IDCNN/BiLSTM-CRF: <a href="https://github.com/crownpku/Information-Extraction-Chinese/tree/master/NER_IDCNN_CRF" target="_blank" rel="noopener">https://github.com/crownpku/Information-Extraction-Chinese/tree/master/NER_IDCNN_CRF</a></li>
<li>BiLSTM-CRF: <a href="https://github.com/Determined22/zh-NER-TF" target="_blank" rel="noopener">https://github.com/Determined22/zh-NER-TF</a></li>
</ul>
<h4 id="2-3-数据集"><a href="#2-3-数据集" class="headerlink" title="2.3 数据集"></a>2.3 数据集</h4><p>参考：<a href="https://yq.aliyun.com/articles/604048" target="_blank" rel="noopener">https://yq.aliyun.com/articles/604048</a></p>
<ul>
<li><code>CoNLL2003</code> <a href="https://www.clips.uantwerpen.be/conll2003/ner/" target="_blank" rel="noopener">https://www.clips.uantwerpen.be/conll2003/ner/</a></li>
<li>OntoNotes 5.0 / CoNNLL 2012 (<a href="https://catalog.ldc.upenn.edu/ldc2013t19" target="_blank" rel="noopener">https://catalog.ldc.upenn.edu/ldc2013t19</a>)</li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
        <category>实体与关系抽取</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>实体与关系抽取</tag>
      </tags>
  </entry>
  <entry>
    <title>数据集扩展</title>
    <url>/2020/02/05/NLP/%E6%96%87%E6%9C%AC%E6%A0%87%E6%B3%A8/%E6%95%B0%E6%8D%AE%E9%9B%86%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h1 id="数据集扩展"><a href="#数据集扩展" class="headerlink" title="数据集扩展"></a>数据集扩展</h1><p>介绍几种扩展训练数据的思想：</p>
<ul>
<li><p>远程监督（Distant Supervision）</p>
<blockquote>
<p>远程监督将纯文本与现有知识图谱进行对齐，能够自动标注大规模训练数据；</p>
</blockquote>
<p><img src="/2020/02/05/NLP/%E6%96%87%E6%9C%AC%E6%A0%87%E6%B3%A8/%E6%95%B0%E6%8D%AE%E9%9B%86%E6%89%A9%E5%B1%95/%E8%BF%9C%E7%A8%8B%E7%9B%91%E7%9D%A3.png" alt="远程监督"></p>
</li>
<li><p>少次学习（Few-shot learning）</p>
<p>少次学习主要是针对远程监督的缺陷而设计的算法，<br><img src="/2020/02/05/NLP/%E6%96%87%E6%9C%AC%E6%A0%87%E6%B3%A8/%E6%95%B0%E6%8D%AE%E9%9B%86%E6%89%A9%E5%B1%95/%E5%B0%91%E6%AC%A1%E5%AD%A6%E4%B9%A0.png" alt="少次学习"></p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.jiqizhixin.com/articles/2019-11-18-2" target="_blank" rel="noopener">知识图谱从哪里来：实体关系抽取的现状与未来</a></li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
        <category>文本标注</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>文本标注</tag>
      </tags>
  </entry>
  <entry>
    <title>文本标注工具</title>
    <url>/2020/02/05/NLP/%E6%96%87%E6%9C%AC%E6%A0%87%E6%B3%A8/%E6%96%87%E6%9C%AC%E6%A0%87%E6%B3%A8%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="文本标注"><a href="#文本标注" class="headerlink" title="文本标注"></a>文本标注</h1><h2 id="文本标注工具"><a href="#文本标注工具" class="headerlink" title="文本标注工具"></a>文本标注工具</h2><ol>
<li><p>Prodigy</p>
<ul>
<li>Website: <a href="https://prodi.gy/docs/" target="_blank" rel="noopener">https://prodi.gy/docs/</a></li>
<li>Blog: <a href="https://explosion.ai/blog/prodigy-annotation-tool-active-learning" target="_blank" rel="noopener">https://explosion.ai/blog/prodigy-annotation-tool-active-learning</a></li>
<li>收费</li>
</ul>
</li>
<li><p>DeepDive（Mindtagger）</p>
<ul>
<li>Website: <a href="http://deepdive.stanford.edu/labeling" target="_blank" rel="noopener">http://deepdive.stanford.edu/labeling</a></li>
<li>Front-end code repo: <a href="https://github.com/HazyResearch/mindbender" target="_blank" rel="noopener">https://github.com/HazyResearch/mindbender</a></li>
</ul>
</li>
<li><p>BRAT</p>
<ul>
<li>intro: <a href="http://brat.nlplab.org/index.html" target="_blank" rel="noopener">http://brat.nlplab.org/index.html</a></li>
<li>code: <a href="https://github.com/nlplab/brat" target="_blank" rel="noopener">https://github.com/nlplab/brat</a></li>
</ul>
</li>
<li><p>IEPY</p>
<ul>
<li>code: <a href="https://github.com/machinalis/iepy" target="_blank" rel="noopener">https://github.com/machinalis/iepy</a></li>
<li>docs: <a href="http://iepy.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">http://iepy.readthedocs.io/en/latest/index.html</a></li>
</ul>
</li>
<li><p>doccano</p>
<ul>
<li>code: <a href="https://github.com/doccano/doccano" target="_blank" rel="noopener">https://github.com/doccano/doccano</a></li>
<li>特性：合作标注、语言独立性、自动标注</li>
<li>参考：<a href="https://zhuanlan.zhihu.com/p/48320901" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/48320901</a></li>
</ul>
</li>
<li><p>Chinese-Annotator</p>
<ul>
<li>code: <a href="https://github.com/deepwel/Chinese-Annotator" target="_blank" rel="noopener">https://github.com/deepwel/Chinese-Annotator</a></li>
<li>特性：标注过程背后含有智能算法（用于减少大批量的标注），将边缘数据交给人工标注 + 标注界面显而易见地友好</li>
<li>参考：<a href="https://zhuanlan.zhihu.com/p/31149817" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31149817</a></li>
<li>很久没维护了</li>
</ul>
</li>
</ol>
<h2 id="文本标注平台"><a href="#文本标注平台" class="headerlink" title="文本标注平台"></a>文本标注平台</h2><ol>
<li>京东众智</li>
<li>百度众测</li>
<li>figure-eight</li>
</ol>
<h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2>]]></content>
      <categories>
        <category>NLP</category>
        <category>文本标注</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>文本标注</tag>
      </tags>
  </entry>
  <entry>
    <title>README</title>
    <url>/2019/11/08/Python/Crawler/README/</url>
    <content><![CDATA[<h1 id="Crawler（爬虫）"><a href="#Crawler（爬虫）" class="headerlink" title="Crawler（爬虫）"></a>Crawler（爬虫）</h1><p>其实除了上述有的内容外，还应该包括：  </p>
<ul>
<li>Crawler-APP数据抓取  </li>
<li>Crawler-分布式数据抓取  </li>
<li>Crawler-解决IP封锁</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
        <category>Crawler</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Crawler</tag>
      </tags>
  </entry>
  <entry>
    <title>Question_in_stackoverflow</title>
    <url>/2019/08/26/Python/gc/Question_in_stackoverflow/</url>
    <content><![CDATA[<p><strong>Background truths(?):</strong> When python program exits, <code>gc</code>(<code>garbage collection</code>) works to collect memory in a common way <code>reference counting</code>.</p>
<p><strong>Question:</strong> but what’s the order of objects’ destructing or similar with <code>java</code>?</p>
<p>Pls see code below. The reference relationship is:(<code>--&gt;</code> means reference)  </p>
<ul>
<li>ABC <code>--&gt;</code> A </li>
<li>ABC <code>--&gt;</code> B </li>
<li>A <code>--&gt;</code> C      </li>
</ul>
<p>And I could understand <strong>the construct order is abc, a, c, b</strong>, but why the destruct order is c, a, b, abc. <strong>c</strong> has the most reference, why firstly deleted.</p>
<p>python version 3.7.1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">'little a'</span></span><br><span class="line">        print(self.name)</span><br><span class="line">        self._c = C() </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'little a was deleted'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">'little b'</span></span><br><span class="line">        print(self.name)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'little b was deleted'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">'little c'</span></span><br><span class="line">        print(self.name)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'little c was deleted'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ABC</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.name = <span class="string">'little abc'</span></span><br><span class="line">        print(self.name)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_ABC</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._a = A()</span><br><span class="line">        self._b = B()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'little abc was deleted'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    abc = ABC()</span><br><span class="line">    abc.get_ABC()</span><br><span class="line">    print(sys.getrefcount(abc._a))</span><br><span class="line">    print(sys.getrefcount(abc._b))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
        <category>gc</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>gc</tag>
      </tags>
  </entry>
  <entry>
    <title>dynamic_Programming_sum</title>
    <url>/2019/11/08/Algorithm/optimization/DP/dynamic_Programming_sum/</url>
    <content><![CDATA[<h1 id="Dynamic-Programming-总结"><a href="#Dynamic-Programming-总结" class="headerlink" title="Dynamic Programming 总结"></a>Dynamic Programming 总结</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>1.把多阶段决策过程转化成一系列的单阶段决策，利用各个阶段之间的递推关系来逐个确定每个阶段的最优化决策</p>
<h2 id="算法设计步骤"><a href="#算法设计步骤" class="headerlink" title="算法设计步骤"></a>算法设计步骤</h2><p>1.定义最优子问题</p>
<p>2.定义状态</p>
<p>3.定义决策与状态转移方程</p>
<p>4.确定边界条件</p>
<p>重点在于<strong>状态转移方程 + 边界条件</strong></p>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>optimization</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>optimization</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 11 新特性总结</title>
    <url>/2020/03/02/C/CPP/c++11/README/</url>
    <content><![CDATA[<h1 id="c-11-新特性总结"><a href="#c-11-新特性总结" class="headerlink" title="c++ 11 新特性总结"></a>c++ 11 新特性总结</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://zhuanlan.zhihu.com/p/21930436" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/21930436</a></li>
</ol>
]]></content>
      <categories>
        <category>C</category>
        <category>CPP</category>
        <category>c++11</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CPP</tag>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title>dynamic_Programming0</title>
    <url>/2020/01/05/Algorithm/optimization/DP/dynamic_Programming0/</url>
    <content><![CDATA[<h1 id="Dynamic-Programming-（动态规划）"><a href="#Dynamic-Programming-（动态规划）" class="headerlink" title="Dynamic Programming （动态规划）"></a>Dynamic Programming （动态规划）</h1><p>参考：</p>
<p>博客园 <a href="http://www.cnblogs.com/Anker/archive/2013/03/15/2961725.html" target="_blank" rel="noopener">http://www.cnblogs.com/Anker/archive/2013/03/15/2961725.html</a></p>
<p>适合于求解多阶段决策问题的最优解</p>
<p>常见的有以下几类问题：</p>
<ul>
<li>装配站问题</li>
<li>背包问题</li>
<li>最长公共子序列问题</li>
</ul>
<h2 id="装配站问题"><a href="#装配站问题" class="headerlink" title="装配站问题"></a>装配站问题</h2><p>问题描述：</p>
<p>　一个汽车公司在有2条装配线的工厂内生产汽车，每条装配线有n个装配站，不同装配线上对应的装配站执行的功能相同，但是每个站执行的时间是不同的。在装配汽车时，为了提高速度，可以在这两天装配线上的装配站中做出选择，即可以将部分完成的汽车在任何装配站上从一条装配线移到另一条装配线上。装配过程如下图所示：</p>
<p><img src="/2020/01/05/Algorithm/optimization/DP/dynamic_Programming0/dp_zp0.png" alt=""></p>
<p>装配过程的时间包括：进入装配线时间e、每装配线上各个装配站执行时间a、从一条装配线移到另外一条装配线的时间t<br>离开最后一个装配站时间x。举个例子来说明，现在有2条装配线，每条装配线上有6个装配站，各个时间如下图所示：<br><img src="/2020/01/05/Algorithm/optimization/DP/dynamic_Programming0/dp_zp1.png" alt="">  </p>
<p>从图中可以看出按照红色箭头方向进行装配汽车最快，时间为38。分别现在装配线1上的装配站1、3和6，装配线2上装配站2、4和5。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul>
<li>最小子问题与状态：求到第几个站的最短时间 f[0][i],f[1][i]</li>
<li>状态转换方程：f[0][i] = min{f[0][i-1]+a[0][j],f[1][i-1]+t[1][i-1]+a[0][i]},f[2][i]同理</li>
<li>边界条件：f[0][0],f[1][0]，这个可以根据状态转换方程加以确定</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">6</span>] = &#123;&#123;<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">4</span>&#125;,&#123;<span class="number">8</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> t[<span class="number">2</span>][<span class="number">5</span>] = &#123;&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> e[<span class="number">2</span>] = &#123;<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x[<span class="number">2</span>] = &#123;<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">2</span>][<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> l[<span class="number">2</span>][<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> fs,ls;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = e[<span class="number">0</span>]+a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>] = e[<span class="number">1</span>]+a[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;<span class="number">6</span>;j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[<span class="number">0</span>][j<span class="number">-1</span>] + a[<span class="number">0</span>][j] &lt;= f[<span class="number">1</span>][j<span class="number">-1</span>] + t[<span class="number">1</span>][j<span class="number">-1</span>] + a[<span class="number">0</span>][j]) &#123;</span><br><span class="line">            f[<span class="number">0</span>][j] = f[<span class="number">0</span>][j<span class="number">-1</span>] + a[<span class="number">0</span>][j];</span><br><span class="line">            l[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            f[<span class="number">0</span>][j] = f[<span class="number">1</span>][j<span class="number">-1</span>] + t[<span class="number">1</span>][j<span class="number">-1</span>] + a[<span class="number">0</span>][j];</span><br><span class="line">            l[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f[<span class="number">1</span>][j<span class="number">-1</span>] + a[<span class="number">1</span>][j] &lt;= f[<span class="number">0</span>][j<span class="number">-1</span>] + t[<span class="number">0</span>][j<span class="number">-1</span>] + a[<span class="number">1</span>][j]) &#123;</span><br><span class="line">            f[<span class="number">1</span>][j] = f[<span class="number">1</span>][j<span class="number">-1</span>] + a[<span class="number">1</span>][j];</span><br><span class="line">            l[<span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            f[<span class="number">1</span>][j] = f[<span class="number">0</span>][j<span class="number">-1</span>] + t[<span class="number">0</span>][j<span class="number">-1</span>] + a[<span class="number">1</span>][j];</span><br><span class="line">            l[<span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(f[<span class="number">0</span>][<span class="number">5</span>]+x[<span class="number">0</span>] &lt;= f[<span class="number">1</span>][<span class="number">5</span>]+x[<span class="number">1</span>]) &#123;</span><br><span class="line">        fs = f[<span class="number">0</span>][<span class="number">5</span>]+x[<span class="number">0</span>];</span><br><span class="line">        ls = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        fs = f[<span class="number">1</span>][<span class="number">5</span>]+x[<span class="number">1</span>];</span><br><span class="line">        ls =<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_station</span><span class="params">(<span class="keyword">int</span> r,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    r = l[r][i];</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"装配站："</span>&lt;&lt;l[r][i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        print_station(r,i<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"装配站："</span>&lt;&lt;r&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dp();</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"最短时间为"</span>&lt;&lt;fs&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"装配站："</span>&lt;&lt;ls&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    r = ls;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">5</span>;j&gt;<span class="number">0</span>;j--) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"装配站："</span>&lt;&lt;l[r][j]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        r = l[r][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"reverse output!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    print_station(ls,<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"装配站："</span>&lt;&lt;ls&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
        <category>optimization</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>optimization</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>dynamic_Programming1</title>
    <url>/2020/01/05/Algorithm/optimization/DP/dynamic_Programming1/</url>
    <content><![CDATA[<h1 id="Dynamic-Programming-（动态规划）"><a href="#Dynamic-Programming-（动态规划）" class="headerlink" title="Dynamic Programming （动态规划）"></a>Dynamic Programming （动态规划）</h1><h2 id="背包问题（0-1背包问题）"><a href="#背包问题（0-1背包问题）" class="headerlink" title="背包问题（0-1背包问题）"></a>背包问题（0-1背包问题）</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小偷发现了n个商品，第i个商品重量为wi,价值为vi。小偷希望尽量拿走价值高的商品，但是他的背包只能容纳W重的商品。  </span><br><span class="line">求如何取舍这些商品？   </span><br><span class="line">由于对一个商品，要么被拿走要么不被拿走，所以被称为0-1背包问题</span><br></pre></td></tr></table></figure>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul>
<li>最小子问题：拿到第i-1个商品是最优的，这个怎么考虑呢？（即在容量为<strong>w-vi</strong>的背包里，这里其实是错的），拿到第i-1个商品时，此时达到最优情况</li>
<li>状态：由以上分析，状态参数应该至少有2个，g[i][v]代表在v的容量下，第i次是最优的，g当然代表v之和啦</li>
<li><strong>第i次该如何选取呢？</strong>这个不像装配站问题，有前面确定的路可走，这里考虑<strong>拿与不拿</strong>,什么意思？拿，g[i-1][W-Wi]最优；不拿，g[i-1][W]最优；</li>
<li>状态转换方程：<strong>g[i][v] = max{g[i-1][W],g[i-1][W-Wi]+vi}</strong> 为什么会有拿与不拿呢？当然是背包总容量限制啦</li>
<li>边界条件：g[0][0] = 0 肯定是最优的</li>
</ul>
<h3 id="题目引用"><a href="#题目引用" class="headerlink" title="题目引用"></a>题目引用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有编号分别为a,b,c,d,e的五件物品，它们的重量分别是2,2,6,5,4，它们的价值分别是6,3,5,4,6，现在给你个承重为10的背包，如何让背包里装入的物品具有最  </span><br><span class="line">的价值总和</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/05/Algorithm/optimization/DP/dynamic_Programming1/package.png" alt=""></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const int w[6]=&#123;0,2,2,6,5,4&#125;;//商品重量 第一数值为0，为了方便编程</span><br><span class="line">const int v[6]=&#123;0,6,3,5,4,6&#125;;//商品价值 第一数值为0，为了方便编程</span><br><span class="line">const int W = 10; //背包容量</span><br><span class="line">int c[6][11] = &#123;0&#125;;//c[i][j]表示在商品1到i中，背包容量为j时，最大价值</span><br><span class="line">int l[6]=&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">void dp_package() &#123;</span><br><span class="line">    for(int i=1;i&lt;=W;i++)               //i 代表此时背包容量</span><br><span class="line">        for(int j=1;j&lt;6;j++) &#123;          //j 代表第j个背包</span><br><span class="line">            if(i&gt;=w[j]) &#123;</span><br><span class="line">                if(c[j-1][i] &lt; c[j-1][i-w[j]] + v[j]) &#123;</span><br><span class="line">                    c[j][i] = c[j-1][i-w[j]] + v[j];        //此时为拿第i个商品的情况</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    c[j][i] = c[j-1][W];                    //此时为不拿第i个商品的情况</span><br><span class="line">    </span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                c[j][i] = c[j-1][i];                         </span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    dp_package();</span><br><span class="line">    cout&lt;&lt;c[5][10]&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h3><p>第一遍看这个算法，没看明白！后来看到这个<a href="http://blog.csdn.net/mu399/article/details/7722810#reply" target="_blank" rel="noopener">http://blog.csdn.net/mu399/article/details/7722810#reply</a> 才有点头绪；  </p>
<ul>
<li>从容量为1-W递归考虑，这个是由于每次我们需要的是试探i-Wi时的最优情况，因此不得不从头考虑  </li>
</ul>
<h3 id="部分背包问题"><a href="#部分背包问题" class="headerlink" title="部分背包问题"></a>部分背包问题</h3><p>部分背包问题的意思是商品可以拿去部分，这样就可以用<strong>贪心算法</strong>做了，每次寻求<strong>商品价值/商品重量</strong>最大的加入到背包中</p>
<h2 id="最大公共子序列问题-LCS-Longest-Common-Sequence"><a href="#最大公共子序列问题-LCS-Longest-Common-Sequence" class="headerlink" title="最大公共子序列问题(LCS:Longest Common Sequence)"></a>最大公共子序列问题(LCS:Longest Common Sequence)</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><ul>
<li>公共子序列：两个序列中公共的子序列，如:”1A2C3D4B56”与”B1D23CA45B6A” 的公共子序列有 123456 或者其它</li>
<li>最长公共子序列即最长的：上题中，LCS即”123456“与”12C4B6”</li>
</ul>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个字符串str1和str2，返回两个字符串的最长公共子序列</p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LCS的最优子结构定理：设X=&#123;x1，x2，……，xm&#125;和Y=&#123;y1，y2，……，yn&#125;为两个序列，并设Z=&#123;z1、z2、……，zk&#125;为X和Y的任意一个LCS，则：</span><br><span class="line">（1）如果xm=yn，那么zk=xm=yn，而且Zk-1是Xm-1和Yn-1的一个LCS。</span><br><span class="line">（2）如果xm≠yn，那么zk≠xm蕴含Z是是Xm-1和Yn的一个LCS。</span><br><span class="line">（3）如果xm≠yn，那么zk≠yn蕴含Z是是Xm和Yn-1的一个LCS。</span><br><span class="line">定理说明两个序列的一个LCS也包含两个序列的前缀的一个LCS，即LCS问题具有最优子结构性质。</span><br></pre></td></tr></table></figure>
<p>状态转换方程与边界条件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">          |- 0; i,j=0</span><br><span class="line">c[i][j]-- |- c[i-1][j-1]+1; i,j&gt;0,Xi=Yj</span><br><span class="line">          |- max&#123;c[i-1][j],c[i][j-1]&#125;;i,j&gt;0,Xi!=Yj</span><br></pre></td></tr></table></figure>
<p>如何求得该LCS呢？贴出一段伪码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PRINT_LCS(b,X,i,j)</span><br><span class="line">    if i==0 or j==0</span><br><span class="line">        then return</span><br><span class="line">    if b[i][j] == &apos;\&apos;</span><br><span class="line">        then PRINT_LCS(b,X,i-1,j-1)</span><br><span class="line">             print X[i]</span><br><span class="line">     else if b[i][j] == &apos;|&apos;</span><br><span class="line">                then PRINT_LCS(b,X,i-1,j)</span><br><span class="line">             else PRINT_LSC(b,X,i,j-1)</span><br></pre></td></tr></table></figure>
<p>这里分析了一下思想就是在一路走来的路上留下痕迹，最后便于通过递归来寻迹，不过这样开销太大了</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3>]]></content>
      <categories>
        <category>Algorithm</category>
        <category>optimization</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>optimization</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>auto 关键字</title>
    <url>/2020/03/02/C/CPP/c++11/auto/</url>
    <content><![CDATA[<h1 id="auto-关键字的使用"><a href="#auto-关键字的使用" class="headerlink" title="auto 关键字的使用"></a>auto 关键字的使用</h1><p><code>auto</code> 关键字是 c++ 11 引入的自动推导关键字，主要用途有：</p>
<ol>
<li>声明变量时根据初始化表达式自动推断该变量的类型；</li>
<li>声明函数时，函数返回值的占位符</li>
</ol>
<p><strong>auto的类型推导实际上在编译过程中由编译器自动推导完成，实际上是个语法糖，但是很实用！</strong></p>
<p><code>auto</code> 关键字适用于类型冗长复杂时，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vect;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = vect.<span class="built_in">begin</span>(); it != vect.<span class="built_in">end</span>(); ++it)</span><br><span class="line">&#123;  <span class="comment">//it的类型是std::vector&lt;int&gt;::iterator</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者保存 lambda 表达式的变量声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr = [](<span class="keyword">double</span> x)&#123;<span class="keyword">return</span> x*x;&#125;;<span class="comment">//类型为std::function&lt;double(double)&gt;函数对象`</span></span><br></pre></td></tr></table></figure>

<h1 id="auto-与-decltype-区别"><a href="#auto-与-decltype-区别" class="headerlink" title="auto 与 decltype 区别"></a><code>auto</code> 与 <code>decltype</code> 区别</h1><p><code>auto</code> 进行编译器自动类型推导的时候需要指定初始值，但使用 <code>decltype</code> 可以进行不进行初始化进行类型声明。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(i) a; <span class="comment">// double</span></span><br><span class="line">    <span class="keyword">decltype</span>(add()) b; <span class="comment">//int 注意括号。不带括号就是函数指针了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://blog.csdn.net/xiaoquantouer/article/details/51647865" target="_blank" rel="noopener">https://blog.csdn.net/xiaoquantouer/article/details/51647865</a></li>
</ol>
]]></content>
      <categories>
        <category>C</category>
        <category>CPP</category>
        <category>c++11</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CPP</tag>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 11 之 Lambda 表达式</title>
    <url>/2020/03/02/C/CPP/c++11/lambda/</url>
    <content><![CDATA[<h1 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a>lambda 表达式</h1><p>lambda 表达式是 c++ 11 引入的新特性，c++中 lambda 表达式的声明：</p>
<p><code>[capture list] (params list) mutable exception-&gt; return type { function body }</code></p>
<ul>
<li><code>capture list</code> 为外部捕获参数列表</li>
<li><code>params list</code> 为形参列表</li>
<li><code>mutable</code> 用来修饰是否修改捕获的外部变量</li>
<li><code>exception</code> 异常设定</li>
</ul>
<p>常用的几种 lambda 表达式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用了返回类型后置的新特性</span></span><br><span class="line">[capture <span class="built_in">list</span>] (params <span class="built_in">list</span>) -&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br><span class="line">[capture <span class="built_in">list</span>] (params <span class="built_in">list</span>) &#123; function body &#125;</span><br><span class="line">[capture <span class="built_in">list</span>] &#123; function body &#125;</span><br></pre></td></tr></table></figure>

<h2 id="关于外部变量的捕获方式"><a href="#关于外部变量的捕获方式" class="headerlink" title="关于外部变量的捕获方式"></a>关于外部变量的捕获方式</h2><h3 id="1-值捕获"><a href="#1-值捕获" class="headerlink" title="1. 值捕获"></a>1. 值捕获</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [a] &#123; <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">    a = <span class="number">321</span>;</span><br><span class="line">    f(); <span class="comment">// 输出：123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-引用捕获"><a href="#2-引用捕获" class="headerlink" title="2. 引用捕获"></a>2. 引用捕获</h3><p><img src="/2020/03/02/C/CPP/c++11/lambda/value_catch.png" alt="引用捕获"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;a] &#123; <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">    a = <span class="number">321</span>;</span><br><span class="line">    f(); <span class="comment">// 输出：321</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-隐式捕获"><a href="#3-隐式捕获" class="headerlink" title="3. 隐式捕获"></a>3. 隐式捕获</h3><p>不在捕获列表中显式写明需要捕获的变量，使用编译器自动推导</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 隐式值捕获</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [=] &#123; <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">    f(); <span class="comment">// 输出：123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 隐式引用捕获</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;] &#123; <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">    a = <span class="number">321</span>;</span><br><span class="line">    f(); <span class="comment">// 输出：321</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-混合方式"><a href="#4-混合方式" class="headerlink" title="4. 混合方式"></a>4. 混合方式</h3><p>混合方式是对于既有值捕获又有引用捕获的方式，<br><img src="/2020/03/02/C/CPP/c++11/lambda/mixed_mode.png" alt="混合方式"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://www.cnblogs.com/DswCnblog/p/5629165.html" target="_blank" rel="noopener">https://www.cnblogs.com/DswCnblog/p/5629165.html</a></li>
</ol>
]]></content>
      <categories>
        <category>C</category>
        <category>CPP</category>
        <category>c++11</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CPP</tag>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title>8 week</title>
    <url>/2019/11/08/C/CPP/leetcode/README/</url>
    <content><![CDATA[<p>2020/2/12 – 2020/4/12 8周 leetcode 速成</p>
]]></content>
      <categories>
        <category>C</category>
        <category>CPP</category>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CPP</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>智能指针</title>
    <url>/2020/03/02/C/CPP/c++11/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>智能指针在手动管理 c++ 内存对象中起到了一定的作用，使用了boost的智能指针方案，与 <code>java</code> <code>python</code> 等类型进行自动垃圾回收相比，使用该方式进行内存管理的行为更明确！！！</p>
<p>智能指针主要有三种指针类型：</p>
<ul>
<li>unique_ptr，独占指针对象，且指针对象的生命周期与其一致，即不能进行指针对象的复制；</li>
<li>shared_ptr，指针对象可以共享，即可以通过复制将指针赋值给 shared_ptr，weak_ptr。当 shared_ptr 数目减少至0时，指针对象生命周期结束；</li>
<li>weak_ptr，不能决定所指对象的生命周期，引用所指对象时，<strong>需要先 lock 成 shared_ptr 才能访问。</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文件 test-1.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up1(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">11</span>));</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up2 = up1;   <span class="comment">//! 编译时会出错 [1]</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *up1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up3 = <span class="built_in">move</span>(up1);  <span class="comment">//! [2]</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *up3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span> (up1)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *up1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    up3.reset();  <span class="comment">//! [3]</span></span><br><span class="line">    up1.reset();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; sp1(make_shared&lt;<span class="built_in">string</span>&gt;(<span class="string">"Hello"</span>));</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; sp2 = sp1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"*sp1:"</span> &lt;&lt; *sp1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"*sp2:"</span> &lt;&lt; *sp2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    sp1.reset();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"*sp2:"</span> &lt;&lt; *sp2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    weak_ptr&lt;<span class="built_in">string</span>&gt; wp = sp2; <span class="comment">//! [4]</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"*wp.lock():"</span> &lt;&lt; *wp.lock() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    sp2.reset();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"*wp.lock():"</span> &lt;&lt; *wp.lock() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//! 运行时会出错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译命令： g++ -std=c++11 test-1.cpp</span></span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="https://my.oschina.net/hevakelcj/blog/465978" target="_blank" rel="noopener">https://my.oschina.net/hevakelcj/blog/465978</a></li>
</ol>
]]></content>
      <categories>
        <category>C</category>
        <category>CPP</category>
        <category>c++11</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CPP</tag>
        <tag>c++11</tag>
      </tags>
  </entry>
  <entry>
    <title>Adapter</title>
    <url>/2020/02/12/C/CPP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Adapter/</url>
    <content><![CDATA[<h1 id="Adapter"><a href="#Adapter" class="headerlink" title="Adapter"></a>Adapter</h1>]]></content>
      <categories>
        <category>C</category>
        <category>CPP</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CPP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Handle Body</title>
    <url>/2020/02/12/C/CPP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Handle-Body/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C</category>
        <category>CPP</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CPP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Template Method</title>
    <url>/2020/02/12/C/CPP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Template-Method/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>C</category>
        <category>CPP</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CPP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Singleton</title>
    <url>/2020/02/10/C/CPP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Singleton/</url>
    <content><![CDATA[<h1 id="c-中的-单例模式"><a href="#c-中的-单例模式" class="headerlink" title="c++ 中的 单例模式"></a>c++ 中的 单例模式</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSingleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	CSingleton()   <span class="comment">//构造函数是私有的</span></span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	CSingleton(<span class="keyword">const</span> CSingleton &amp;);</span><br><span class="line">	CSingleton &amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> CSingleton &amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> CSingleton &amp; <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">static</span> CSingleton instance;   <span class="comment">//局部静态变量</span></span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C</category>
        <category>CPP</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CPP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>OOP 的三种关系</title>
    <url>/2020/02/12/C/CPP/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/OOP%E7%9A%84%E4%B8%89%E7%A7%8D%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h1 id="OOP的三种关系"><a href="#OOP的三种关系" class="headerlink" title="OOP的三种关系"></a>OOP的三种关系</h1><h2 id="Inheritance（继承）"><a href="#Inheritance（继承）" class="headerlink" title="Inheritance（继承）"></a><code>Inheritance（继承）</code></h2><h2 id="Composition（复合）"><a href="#Composition（复合）" class="headerlink" title="Composition（复合）"></a><code>Composition（复合）</code></h2><h2 id="Delegation（委托）"><a href="#Delegation（委托）" class="headerlink" title="Delegation（委托）"></a><code>Delegation（委托）</code></h2>]]></content>
      <categories>
        <category>C</category>
        <category>CPP</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CPP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>README</title>
    <url>/2019/12/05/NLP/Course/cs224n/README/</url>
    <content><![CDATA[<h1 id="CS224n"><a href="#CS224n" class="headerlink" title="CS224n"></a>CS224n</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ol>
<li>12/5/2019 发现一份写的很易懂的blog：<a href="http://bitjoy.net/2019/08/02/cs224n%ef%bc%881-31%ef%bc%89translation-seq2seq-attention/" target="_blank" rel="noopener">http://bitjoy.net/2019/08/02/cs224n%ef%bc%881-31%ef%bc%89translation-seq2seq-attention/</a></li>
</ol>
]]></content>
      <categories>
        <category>NLP</category>
        <category>Course</category>
        <category>cs224n</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>Course</tag>
        <tag>cs224n</tag>
      </tags>
  </entry>
  <entry>
    <title>CRF</title>
    <url>/2019/11/20/NLP/Course/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/CRF/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>NLP</category>
        <category>Course</category>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>Course</tag>
        <tag>统计学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>Problem 297</title>
    <url>/2020/02/20/C/CPP/leetcode/w1/P297/</url>
    <content><![CDATA[<h1 id="Serialize-and-Deserialize-Binary-Tree"><a href="#Serialize-and-Deserialize-Binary-Tree" class="headerlink" title="Serialize and Deserialize Binary Tree"></a>Serialize and Deserialize Binary Tree</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>对二叉树进行 <code>srialize</code> 与 <code>deserialize</code> 操作实现</p>
<h2 id="解法-1"><a href="#解法-1" class="headerlink" title="解法 1"></a>解法 1</h2><p>主要思想是使用两次遍历得到的序列，进行序列化与反序列化操作</p>
<p>出现的反例是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1</span><br><span class="line">1       1</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">## 解法 <span class="number">2</span></span><br><span class="line"></span><br><span class="line">加入位置记录，如：</span><br></pre></td></tr></table></figure>
<pre><code>1</code></pre><p>1       1<br>序列化成： 1,1,1,2,1,3</p>
<pre><code>    1
2       3
     6      7</code></pre><p>序列化成：1,1,2,2,3,3,6,6,7,7<br>```</p>
]]></content>
      <categories>
        <category>C</category>
        <category>CPP</category>
        <category>leetcode</category>
        <category>w1</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CPP</tag>
        <tag>leetcode</tag>
        <tag>w1</tag>
      </tags>
  </entry>
  <entry>
    <title>Problem 1145</title>
    <url>/2020/02/14/C/CPP/leetcode/w1/P1145/</url>
    <content><![CDATA[<h1 id="1145-Binary-Tree-Coloring-Game"><a href="#1145-Binary-Tree-Coloring-Game" class="headerlink" title="1145. Binary Tree Coloring Game"></a>1145. Binary Tree Coloring Game</h1><h2 id="1-查找子孙数目-error"><a href="#1-查找子孙数目-error" class="headerlink" title="1. 查找子孙数目[error]"></a>1. 查找子孙数目[error]</h2><p>直观的想法是找到 <code>x</code> 对应的子孙数目，当子孙数目超过一半时，返回 <code>false</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">btreeGameWinningMove</span><span class="params">(TreeNode* root, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以使用前序遍历访问子孙节点得到子孙的数目</span></span><br><span class="line">        <span class="comment">// 但这道题目可以使用数学公式计算得到</span></span><br><span class="line">        <span class="comment">// 当子孙节点的数目小于总节点数目的一半即可</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        TreeNode* px;</span><br><span class="line">        px = levelTraversal(root, x);</span><br><span class="line">        frontOrder(px, num);</span><br><span class="line">        <span class="keyword">if</span> (num &lt; n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 层次遍历找到对应的节点</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">levelTraversal</span><span class="params">(TreeNode* root, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">        TreeNode* temp;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">            temp = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (temp -&gt; val == x) <span class="keyword">return</span> temp;</span><br><span class="line">            <span class="keyword">if</span> (temp -&gt; left) q.push(temp -&gt; left);</span><br><span class="line">            <span class="keyword">if</span> (temp -&gt; right) q.push(temp -&gt; right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序遍历找子孙节点的数目</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">frontOrder</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        num++;</span><br><span class="line">        frontOrder(root -&gt; left, num);</span><br><span class="line">        frontOrder(root -&gt; right, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是在 submit 时，发现一个测试用例并不通过，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1,2,3,4,5]</span><br><span class="line">5</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>采用了对于满二叉树的特定判定规则，能够判断这两种情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">case 1</span><br><span class="line">[1,2,3,4,5]</span><br><span class="line">5</span><br><span class="line">1</span><br><span class="line">case 2</span><br><span class="line">[1,2,3,4,5,6,7]</span><br><span class="line">7</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>但出现了新的测试 case 不通过的情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[6,3,null,7,4,null,null,null,2,null,1,null,5]</span><br><span class="line">7</span><br><span class="line">3</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C</category>
        <category>CPP</category>
        <category>leetcode</category>
        <category>w1</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CPP</tag>
        <tag>leetcode</tag>
        <tag>w1</tag>
      </tags>
  </entry>
  <entry>
    <title>Problem 124</title>
    <url>/2020/02/20/C/CPP/leetcode/w1/P124/</url>
    <content><![CDATA[<h1 id="Binary-Tree-Maximum-Path-Sum"><a href="#Binary-Tree-Maximum-Path-Sum" class="headerlink" title="Binary Tree Maximum Path Sum"></a>Binary Tree Maximum Path Sum</h1><h2 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h2><p>这道题与 <code>P.687</code> 有点异曲同工的意味，使用递归解法，关键在于</p>
<ol>
<li>在递归过程中通过比较保存当前遍历过程中的最值；</li>
<li>返回以当前节点为根的树的单边最值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = root -&gt; val;</span><br><span class="line">        maxSum(root, &amp;ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 类似于 687 做法</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span>* ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = maxSum(root -&gt; right, ans);</span><br><span class="line">        <span class="keyword">int</span> l = maxSum(root -&gt; left, ans);</span><br><span class="line">        <span class="keyword">int</span> rsum = r + root -&gt; val;</span><br><span class="line">        <span class="keyword">int</span> lsum = l + root -&gt; val;</span><br><span class="line">        <span class="comment">// 求以 root 为根的树单边产生的最值（左子树+root，root，右子树+root，左子树+root+右子树）</span></span><br><span class="line">        <span class="keyword">int</span> m = ThreeMax(rsum, lsum ,root -&gt; val);</span><br><span class="line">        *ans = ThreeMax(*ans, m, l + r + root -&gt; val);</span><br><span class="line">        <span class="comment">// 返回单边树的最值</span></span><br><span class="line">        <span class="keyword">return</span> ThreeMax(l + root -&gt; val, r + root -&gt; val, root -&gt; val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ThreeMax</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2, <span class="keyword">int</span> v3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(v1 &gt; v2) m = v1;</span><br><span class="line">        <span class="keyword">else</span> m = v2;</span><br><span class="line">        <span class="keyword">if</span>(v3 &gt; m) m = v3;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>竟然在这道题上拿到了最少空间开销，超过了96.7%的时间，棒！</p>
]]></content>
      <categories>
        <category>C</category>
        <category>CPP</category>
        <category>leetcode</category>
        <category>w1</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CPP</tag>
        <tag>leetcode</tag>
        <tag>w1</tag>
      </tags>
  </entry>
  <entry>
    <title>Problem 1305</title>
    <url>/2020/02/14/C/CPP/leetcode/w1/P1305/</url>
    <content><![CDATA[<h1 id="1305-All-Elements-in-Two-Binary-Search-Trees"><a href="#1305-All-Elements-in-Two-Binary-Search-Trees" class="headerlink" title="1305. All Elements in Two Binary Search Trees"></a>1305. All Elements in Two Binary Search Trees</h1><h2 id="1-递归中序遍历-归并排序"><a href="#1-递归中序遍历-归并排序" class="headerlink" title="1. 递归中序遍历 + 归并排序"></a>1. 递归中序遍历 + 归并排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getAllElements(TreeNode* root1, TreeNode* root2) &#123;</span><br><span class="line">        <span class="comment">// 中序遍历 + 归并排序</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; l1, l2, l3;</span><br><span class="line">        middleOrder(root1, l1);</span><br><span class="line">        middleOrder(root2, l2);</span><br><span class="line">        <span class="comment">// 归并排序</span></span><br><span class="line">        <span class="keyword">int</span> n1 = l1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n2 = l2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p1 &lt; n1 || p2 &lt; n2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1 &gt;= n1) &#123;</span><br><span class="line">                l3.push_back(l2[p2++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p2 &gt;= n2) &#123;</span><br><span class="line">                l3.push_back(l1[p1++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (l1[p1] &lt; l2[p2]) &#123;</span><br><span class="line">                l3.push_back(l1[p1++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                l3.push_back(l2[p2++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l3;              </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">middleOrder</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; orderList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        middleOrder(root -&gt; left, orderList);</span><br><span class="line">        orderList.push_back(root -&gt; val);</span><br><span class="line">        middleOrder(root -&gt; right, orderList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>优缺点：</p>
<ul>
<li>优点：递归进行中序遍历，代码简洁，耗时较短</li>
<li>缺点：递归导致的函数栈空间的增大，内存消耗较多</li>
</ul>
]]></content>
      <categories>
        <category>C</category>
        <category>CPP</category>
        <category>leetcode</category>
        <category>w1</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CPP</tag>
        <tag>leetcode</tag>
        <tag>w1</tag>
      </tags>
  </entry>
  <entry>
    <title>Problem 2</title>
    <url>/2020/02/14/C/CPP/leetcode/w1/P2/</url>
    <content><![CDATA[<h1 id="Pro2-Add-Two-Numbers"><a href="#Pro2-Add-Two-Numbers" class="headerlink" title="Pro2. Add Two Numbers"></a>Pro2. Add Two Numbers</h1><h2 id="1-直接想法-error"><a href="#1-直接想法-error" class="headerlink" title="1. 直接想法[error]"></a>1. 直接想法[error]</h2><p>将链表中的值复原成 <code>long</code> 型，直接相加得到的和，写入 <code>l1</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> v1 = <span class="number">0</span>, v2 = <span class="number">0</span>, i = <span class="number">0</span>, result;</span><br><span class="line">        ListNode* index;</span><br><span class="line">        index = l1;</span><br><span class="line">        <span class="keyword">while</span>(index) &#123;</span><br><span class="line">            v1 += <span class="built_in">pow</span>(<span class="number">10</span>, i) * index-&gt;val;</span><br><span class="line">            i++;</span><br><span class="line">            index = index -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        index = l2;</span><br><span class="line">        <span class="keyword">while</span>(index) &#123;</span><br><span class="line">            v2 += <span class="built_in">pow</span>(<span class="number">10</span>, i) * index-&gt;val;</span><br><span class="line">            i++;</span><br><span class="line">            index = index -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        result = v1 + v2;</span><br><span class="line">        index = l1;</span><br><span class="line">        <span class="keyword">while</span>(result) &#123;</span><br><span class="line">            index -&gt; val = result % <span class="number">10</span>;</span><br><span class="line">            result /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (result &amp;&amp; !index -&gt; next) &#123;</span><br><span class="line">                index -&gt; next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            index = index -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>后来发现这种方法测试的时候有些边界案例测试不能通过，数字过大，因此选择采用第二种方法，使用加法运算规则。</p>
<h2 id="2-加法运算规则"><a href="#2-加法运算规则" class="headerlink" title="2. 加法运算规则"></a>2. 加法运算规则</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ListNode* l3;</span><br><span class="line">        ListNode *index1, *index2, *index3, *index3_pre;</span><br><span class="line">        <span class="keyword">char</span> v1, v2, v;</span><br><span class="line">        <span class="keyword">bool</span> ca = <span class="literal">false</span>;</span><br><span class="line">        index1 = l1;</span><br><span class="line">        index2 = l2;</span><br><span class="line">        </span><br><span class="line">        index3_pre = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        l3 = index3_pre;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(index1 || index2 || ca) &#123;</span><br><span class="line">            v1 = index1 ? index1 -&gt; val : <span class="number">0</span>;</span><br><span class="line">            v2 = index2 ? index2 -&gt; val : <span class="number">0</span>;</span><br><span class="line">            v = ca ? v1 + v2 + <span class="number">1</span> : v1 + v2;</span><br><span class="line">            ca = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (v &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">                v = v % <span class="number">10</span>;</span><br><span class="line">                ca = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index1 = index1 ? index1 -&gt; next : index1;</span><br><span class="line">            index2 = index2 ? index2 -&gt; next : index2;</span><br><span class="line">            index3 = <span class="keyword">new</span> ListNode(v);</span><br><span class="line">            index3_pre -&gt; next = index3;</span><br><span class="line">            index3_pre = index3;</span><br><span class="line">            index3 = index3 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l3 -&gt; next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-减少内存使用"><a href="#3-减少内存使用" class="headerlink" title="3. 减少内存使用"></a>3. 减少内存使用</h2><p>采用尽量减少 <code>new</code> 函数对内存空间的分配来减少内存空间的使用；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ListNode* l3;</span><br><span class="line">        ListNode *index1, *index2,  *index1_pre;</span><br><span class="line">        <span class="keyword">char</span> v1, v2, v;</span><br><span class="line">        <span class="keyword">bool</span> ca = <span class="literal">false</span>;</span><br><span class="line">        index1 = l1;</span><br><span class="line">        index2 = l2;</span><br><span class="line">        </span><br><span class="line">        index1_pre = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(index1 || index2 || ca) &#123;</span><br><span class="line">            v1 = index1 ? index1 -&gt; val : <span class="number">0</span>;</span><br><span class="line">            v2 = index2 ? index2 -&gt; val : <span class="number">0</span>;</span><br><span class="line">            v = ca ? v1 + v2 + <span class="number">1</span> : v1 + v2;</span><br><span class="line">            ca = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (v &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">                v = v % <span class="number">10</span>;</span><br><span class="line">                ca = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!index1) &#123;</span><br><span class="line">                index1 = <span class="keyword">new</span> ListNode(v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                index1 -&gt; val = v; </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            index1_pre -&gt; next = index1;</span><br><span class="line">            index1_pre = index1;</span><br><span class="line">            </span><br><span class="line">            index1 = index1 ? index1 -&gt; next : index1;</span><br><span class="line">            index2 = index2 ? index2 -&gt; next : index2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C</category>
        <category>CPP</category>
        <category>leetcode</category>
        <category>w1</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CPP</tag>
        <tag>leetcode</tag>
        <tag>w1</tag>
      </tags>
  </entry>
  <entry>
    <title>Problem 98</title>
    <url>/2020/02/20/C/CPP/leetcode/w1/P98/</url>
    <content><![CDATA[<h1 id="Validate-Binary-Search-Tree"><a href="#Validate-Binary-Search-Tree" class="headerlink" title="Validate Binary Search Tree"></a>Validate Binary Search Tree</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>判断平衡二叉搜索树（Binary Search Tree）</p>
<h2 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h2><p>使用中序遍历得到一个有序数组，当该数组为升序时即为BST</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> isBST = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; orderList;</span><br><span class="line">        middleOrder(root, orderList);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span> ; i &lt; orderList.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(orderList[i] &lt;= orderList[i<span class="number">-1</span>]) isBST = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isBST;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">middleOrder</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; orderList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        middleOrder(root -&gt; left, orderList);</span><br><span class="line">        orderList.push_back(root -&gt; val);</span><br><span class="line">        middleOrder(root -&gt; right, orderList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C</category>
        <category>CPP</category>
        <category>leetcode</category>
        <category>w1</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>CPP</tag>
        <tag>leetcode</tag>
        <tag>w1</tag>
      </tags>
  </entry>
  <entry>
    <title>Mathmatics/Numerical Analysis/experiment/MCMC/README</title>
    <url>/2020/05/30/Mathmatics/Numerical%20Analysis/experiment/MCMC/README/</url>
    <content><![CDATA[<h1 id="MCMC（Markov-Chain-Monte-Carlo）"><a href="#MCMC（Markov-Chain-Monte-Carlo）" class="headerlink" title="MCMC（Markov Chain Monte Carlo）"></a>MCMC（Markov Chain Monte Carlo）</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/google19890102/article/details/51755242" target="_blank" rel="noopener">Metropolis</a></li>
<li><a href="https://blog.csdn.net/google19890102/article/details/51785156" target="_blank" rel="noopener">Metropolis-Hastings</a></li>
<li><a href="https://blog.csdn.net/google19890102/article/details/51755245" target="_blank" rel="noopener">Gibbs</a></li>
</ul>
]]></content>
  </entry>
</search>
